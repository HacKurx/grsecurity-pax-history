diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/Documentation/dontdiff linux-2.6.26.8-pax/Documentation/dontdiff
--- linux-2.6.26.8/Documentation/dontdiff	2008-07-14 03:51:37.000000000 +0200
+++ linux-2.6.26.8-pax/Documentation/dontdiff	2008-07-14 03:52:23.000000000 +0200
@@ -3,6 +3,7 @@
 *.bin
 *.cpio
 *.css
+*.dbg
 *.dvi
 *.eps
 *.gif
@@ -51,9 +52,14 @@ COPYING
 CREDITS
 CVS
 ChangeSet
+GPATH
+GRTAGS
+GSYMS
+GTAGS
 Image
 Kerntypes
 MODS.txt
+Module.markers
 Module.symvers
 PENDING
 SCCS
@@ -72,6 +78,7 @@ bbootsect
 bin2c
 binkernel.spec
 bootsect
+bounds.h
 bsetup
 btfixupprep
 build
@@ -88,6 +95,7 @@ config_data.gz*
 conmakehash
 consolemap_deftbl.c*
 crc32table.h*
+cpustr.h
 cscope.*
 defkeymap.c*
 devlist.h*
@@ -136,6 +144,7 @@ miboot*
 mk_elfconfig
 mkboot
 mkbugboot
+mkcpustr
 mkdep
 mkprep
 mktables
@@ -177,16 +186,20 @@ times.h*
 tkparse
 trix_boot.h
 utsrelease.h*
-vdso.lds
+vdso*.lds
 version.h*
 vmlinux
 vmlinux-*
 vmlinux.aout
-vmlinux*.lds*
+vmlinux.bin.all
+vmlinux*.lds
+vmlinux.relocs
 vmlinux*.scr
-vsyscall.lds
+vsyscall*.lds
+wakeup.lds
 wanxlfw.inc
 uImage
 unifdef
+utsrelease.h
 zImage*
 zconf.hash.c
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/Makefile linux-2.6.26.8-pax/Makefile
--- linux-2.6.26.8/Makefile	2008-11-11 12:51:04.000000000 +0100
+++ linux-2.6.26.8-pax/Makefile	2008-11-11 12:52:22.000000000 +0100
@@ -214,7 +214,7 @@ CONFIG_SHELL := $(shell if [ -x "$$BASH"
 
 HOSTCC       = gcc
 HOSTCXX      = g++
-HOSTCFLAGS   = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS   = -Wall -W -Wno-unused -Wno-sign-compare -Wstrict-prototypes -O2 -fomit-frame-pointer
 HOSTCXXFLAGS = -O2
 
 # Decide whether to build built-in, modular, or both.
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/alpha/kernel/module.c linux-2.6.26.8-pax/arch/alpha/kernel/module.c
--- linux-2.6.26.8/arch/alpha/kernel/module.c	2008-07-14 03:51:37.000000000 +0200
+++ linux-2.6.26.8-pax/arch/alpha/kernel/module.c	2008-07-14 03:52:23.000000000 +0200
@@ -182,7 +182,7 @@ apply_relocate_add(Elf64_Shdr *sechdrs, 
 
 	/* The small sections were sorted to the end of the segment.
 	   The following should definitely cover them.  */
-	gp = (u64)me->module_core + me->core_size - 0x8000;
+	gp = (u64)me->module_core_rw + me->core_size_rw - 0x8000;
 	got = sechdrs[me->arch.gotsecindex].sh_addr;
 
 	for (i = 0; i < n; i++) {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/alpha/kernel/osf_sys.c linux-2.6.26.8-pax/arch/alpha/kernel/osf_sys.c
--- linux-2.6.26.8/arch/alpha/kernel/osf_sys.c	2008-07-14 03:51:37.000000000 +0200
+++ linux-2.6.26.8-pax/arch/alpha/kernel/osf_sys.c	2008-07-14 03:52:23.000000000 +0200
@@ -1227,6 +1227,10 @@ arch_get_unmapped_area(struct file *filp
 	   merely specific addresses, but regions of memory -- perhaps
 	   this feature should be incorporated into all ports?  */
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = arch_get_unmapped_area_1 (PAGE_ALIGN(addr), len, limit);
 		if (addr != (unsigned long) -ENOMEM)
@@ -1234,8 +1238,8 @@ arch_get_unmapped_area(struct file *filp
 	}
 
 	/* Next, try allocating at TASK_UNMAPPED_BASE.  */
-	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(TASK_UNMAPPED_BASE),
-					 len, limit);
+	addr = arch_get_unmapped_area_1 (PAGE_ALIGN(current->mm->mmap_base), len, limit);
+
 	if (addr != (unsigned long) -ENOMEM)
 		return addr;
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/alpha/mm/fault.c linux-2.6.26.8-pax/arch/alpha/mm/fault.c
--- linux-2.6.26.8/arch/alpha/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/alpha/mm/fault.c	2008-08-22 10:23:27.000000000 +0200
@@ -54,6 +54,124 @@ __load_new_mm_context(struct mm_struct *
 	__reload_thread(pcb);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int ldah, ldq, jmp;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(ldq, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmp, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (ldq & 0xFFFF0000U) == 0xA77B0000U &&
+		    jmp == 0x6BFB0000U)
+		{
+			unsigned long r27, addr;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = ldq | 0xFFFFFFFFFFFF0000UL;
+
+			addr = regs->r27 + ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			err = get_user(r27, (unsigned long *)addr);
+			if (err)
+				break;
+
+			regs->r27 = r27;
+			regs->pc = r27;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #2 */
+		unsigned int ldah, lda, br;
+
+		err = get_user(ldah, (unsigned int *)regs->pc);
+		err |= get_user(lda, (unsigned int *)(regs->pc+4));
+		err |= get_user(br, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((ldah & 0xFFFF0000U) == 0x277B0000U &&
+		    (lda & 0xFFFF0000U) == 0xA77B0000U &&
+		    (br & 0xFFE00000U) == 0xC3E00000U)
+		{
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL;
+			unsigned long addrh = (ldah | 0xFFFFFFFFFFFF0000UL) << 16;
+			unsigned long addrl = lda | 0xFFFFFFFFFFFF0000UL;
+
+			regs->r27 += ((addrh ^ 0x80000000UL) + 0x80000000UL) + ((addrl ^ 0x8000UL) + 0x8000UL);
+			regs->pc += 12 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int br;
+
+		err = get_user(br, (unsigned int *)regs->pc);
+
+		if (!err && (br & 0xFFE00000U) == 0xC3800000U) {
+			unsigned int br2, ldq, nop, jmp;
+			unsigned long addr = br | 0xFFFFFFFFFFE00000UL, resolver;
+
+			addr = regs->pc + 4 + (((addr ^ 0x00100000UL) + 0x00100000UL) << 2);
+			err = get_user(br2, (unsigned int *)addr);
+			err |= get_user(ldq, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			err |= get_user(jmp, (unsigned int *)(addr+12));
+			err |= get_user(resolver, (unsigned long *)(addr+16));
+
+			if (err)
+				break;
+
+			if (br2 == 0xC3600000U &&
+			    ldq == 0xA77B000CU &&
+			    nop == 0x47FF041FU &&
+			    jmp == 0x6B7B0000U)
+			{
+				regs->r28 = regs->pc+4;
+				regs->r27 = addr+16;
+				regs->pc = resolver;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -131,8 +249,29 @@ do_page_fault(unsigned long address, uns
  good_area:
 	si_code = SEGV_ACCERR;
 	if (cause < 0) {
-		if (!(vma->vm_flags & VM_EXEC))
+		if (!(vma->vm_flags & VM_EXEC)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->pc)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)regs->pc, (void *)rdusp());
+			do_group_exit(SIGKILL);
+#else
 			goto bad_area;
+#endif
+
+		}
 	} else if (!cause) {
 		/* Allow reads even for write-only mappings */
 		if (!(vma->vm_flags & (VM_READ | VM_WRITE)))
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/arm/mm/mmap.c linux-2.6.26.8-pax/arch/arm/mm/mmap.c
--- linux-2.6.26.8/arch/arm/mm/mmap.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/arm/mm/mmap.c	2008-07-14 03:52:23.000000000 +0200
@@ -60,6 +60,10 @@ arch_get_unmapped_area(struct file *filp
 	if (len > TASK_SIZE)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -72,10 +76,10 @@ arch_get_unmapped_area(struct file *filp
 			return addr;
 	}
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
-	        mm->cached_hole_size = 0;
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
 	}
 
 full_search:
@@ -91,8 +95,8 @@ full_search:
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/avr32/mm/fault.c linux-2.6.26.8-pax/arch/avr32/mm/fault.c
--- linux-2.6.26.8/arch/avr32/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/avr32/mm/fault.c	2008-07-14 03:52:23.000000000 +0200
@@ -41,6 +41,23 @@ static inline int notify_page_fault(stru
 
 int exception_trace = 1;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%02x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults. It determines the address and the
  * problem, and then passes it off to one of the appropriate routines.
@@ -157,6 +174,16 @@ bad_area:
 	up_read(&mm->mmap_sem);
 
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if (ecr == ECR_PROTECTION_X || ecr == ECR_TLB_MISS_X) {
+				pax_report_fault(regs, (void *)regs->pc, (void *)regs->sp);
+				do_group_exit(SIGKILL);
+			}
+		}
+#endif
+
 		if (exception_trace && printk_ratelimit())
 			printk("%s%s[%d]: segfault at %08lx pc %08lx "
 			       "sp %08lx ecr %lu\n",
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/ia32/binfmt_elf32.c linux-2.6.26.8-pax/arch/ia64/ia32/binfmt_elf32.c
--- linux-2.6.26.8/arch/ia64/ia32/binfmt_elf32.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/ia32/binfmt_elf32.c	2008-07-14 03:52:23.000000000 +0200
@@ -45,6 +45,13 @@ randomize_stack_top(unsigned long stack_
 
 #define elf_read_implies_exec(ex, have_pt_gnu_stack)	(!(have_pt_gnu_stack))
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(current->personality == PER_LINUX32 ? 0x08048000UL : 0x4000000000000000UL)
+
+#define PAX_DELTA_MMAP_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#define PAX_DELTA_STACK_LEN	(current->personality == PER_LINUX32 ? 16 : 3*PAGE_SHIFT - 13)
+#endif
+
 /* Ugly but avoids duplication */
 #include "../../../fs/binfmt_elf.c"
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/ia32/ia32priv.h linux-2.6.26.8-pax/arch/ia64/ia32/ia32priv.h
--- linux-2.6.26.8/arch/ia64/ia32/ia32priv.h	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/ia32/ia32priv.h	2008-07-14 03:52:23.000000000 +0200
@@ -303,7 +303,14 @@ struct old_linux32_dirent {
 #define ELF_DATA	ELFDATA2LSB
 #define ELF_ARCH	EM_386
 
-#define IA32_STACK_TOP		IA32_PAGE_OFFSET
+#ifdef CONFIG_PAX_RANDUSTACK
+#define __IA32_DELTA_STACK	(current->mm->delta_stack)
+#else
+#define __IA32_DELTA_STACK	0UL
+#endif
+
+#define IA32_STACK_TOP		(IA32_PAGE_OFFSET - __IA32_DELTA_STACK)
+
 #define IA32_GATE_OFFSET	IA32_PAGE_OFFSET
 #define IA32_GATE_END		IA32_PAGE_OFFSET + PAGE_SIZE
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/kernel/module.c linux-2.6.26.8-pax/arch/ia64/kernel/module.c
--- linux-2.6.26.8/arch/ia64/kernel/module.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/kernel/module.c	2008-07-14 03:52:23.000000000 +0200
@@ -321,7 +321,7 @@ module_alloc (unsigned long size)
 void
 module_free (struct module *mod, void *module_region)
 {
-	if (mod->arch.init_unw_table && module_region == mod->module_init) {
+	if (mod->arch.init_unw_table && module_region == mod->module_init_rx) {
 		unw_remove_unwind_table(mod->arch.init_unw_table);
 		mod->arch.init_unw_table = NULL;
 	}
@@ -499,15 +499,39 @@ module_frob_arch_sections (Elf_Ehdr *ehd
 }
 
 static inline int
+in_init_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rx < mod->init_size_rx;
+}
+
+static inline int
+in_init_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_init_rw < mod->init_size_rw;
+}
+
+static inline int
 in_init (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_init < mod->init_size;
+	return in_init_rx(mod, addr) || in_init_rw(mod, addr);
+}
+
+static inline int
+in_core_rx (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rx < mod->core_size_rx;
+}
+
+static inline int
+in_core_rw (const struct module *mod, uint64_t addr)
+{
+	return addr - (uint64_t) mod->module_core_rw < mod->core_size_rw;
 }
 
 static inline int
 in_core (const struct module *mod, uint64_t addr)
 {
-	return addr - (uint64_t) mod->module_core < mod->core_size;
+	return in_core_rx(mod, addr) || in_core_rw(mod, addr);
 }
 
 static inline int
@@ -691,7 +715,14 @@ do_reloc (struct module *mod, uint8_t r_
 		break;
 
 	      case RV_BDREL:
-		val -= (uint64_t) (in_init(mod, val) ? mod->module_init : mod->module_core);
+		if (in_init_rx(mod, val))
+			val -= (uint64_t) mod->module_init_rx;
+		else if (in_init_rw(mod, val))
+			val -= (uint64_t) mod->module_init_rw;
+		else if (in_core_rx(mod, val))
+			val -= (uint64_t) mod->module_core_rx;
+		else if (in_core_rw(mod, val))
+			val -= (uint64_t) mod->module_core_rw;
 		break;
 
 	      case RV_LTV:
@@ -825,15 +856,15 @@ apply_relocate_add (Elf64_Shdr *sechdrs,
 		 *     addresses have been selected...
 		 */
 		uint64_t gp;
-		if (mod->core_size > MAX_LTOFF)
+		if (mod->core_size_rx + mod->core_size_rw > MAX_LTOFF)
 			/*
 			 * This takes advantage of fact that SHF_ARCH_SMALL gets allocated
 			 * at the end of the module.
 			 */
-			gp = mod->core_size - MAX_LTOFF / 2;
+			gp = mod->core_size_rx + mod->core_size_rw - MAX_LTOFF / 2;
 		else
-			gp = mod->core_size / 2;
-		gp = (uint64_t) mod->module_core + ((gp + 7) & -8);
+			gp = (mod->core_size_rx + mod->core_size_rw) / 2;
+		gp = (uint64_t) mod->module_core_rx + ((gp + 7) & -8);
 		mod->arch.gp = gp;
 		DEBUGP("%s: placing gp at 0x%lx\n", __func__, gp);
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/kernel/sys_ia64.c linux-2.6.26.8-pax/arch/ia64/kernel/sys_ia64.c
--- linux-2.6.26.8/arch/ia64/kernel/sys_ia64.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/kernel/sys_ia64.c	2008-07-14 03:52:23.000000000 +0200
@@ -43,6 +43,13 @@ arch_get_unmapped_area (struct file *fil
 	if (REGION_NUMBER(addr) == RGN_HPAGE)
 		addr = 0;
 #endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if ((mm->pax_flags & MF_PAX_RANDMMAP) && addr && filp)
+		addr = mm->free_area_cache;
+	else
+#endif
+
 	if (!addr)
 		addr = mm->free_area_cache;
 
@@ -61,9 +68,9 @@ arch_get_unmapped_area (struct file *fil
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
 		if (TASK_SIZE - len < addr || RGN_MAP_LIMIT - len < REGION_OFFSET(addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
+			if (start_addr != mm->mmap_base) {
 				/* Start a new search --- just in case we missed some holes.  */
-				addr = TASK_UNMAPPED_BASE;
+				addr = mm->mmap_base;
 				goto full_search;
 			}
 			return -ENOMEM;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/mm/fault.c linux-2.6.26.8-pax/arch/ia64/mm/fault.c
--- linux-2.6.26.8/arch/ia64/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/mm/fault.c	2008-08-22 10:23:57.000000000 +0200
@@ -72,6 +72,23 @@ mapped_kernel_page_is_present (unsigned 
 	return pte_present(pte);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 8; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void __kprobes
 ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *regs)
 {
@@ -145,9 +162,23 @@ ia64_do_page_fault (unsigned long addres
 	mask = (  (((isr >> IA64_ISR_X_BIT) & 1UL) << VM_EXEC_BIT)
 		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT));
 
-	if ((vma->vm_flags & mask) != mask)
+	if ((vma->vm_flags & mask) != mask) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (!(vma->vm_flags & VM_EXEC) && (mask & VM_EXEC)) {
+			if (!(mm->pax_flags & MF_PAX_PAGEEXEC) || address != regs->cr_iip)
+				goto bad_area;
+
+			up_read(&mm->mmap_sem);
+			pax_report_fault(regs, (void *)regs->cr_iip, (void *)regs->r12);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
 
+	}
+
   survive:
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ia64/mm/init.c linux-2.6.26.8-pax/arch/ia64/mm/init.c
--- linux-2.6.26.8/arch/ia64/mm/init.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ia64/mm/init.c	2008-07-14 03:52:23.000000000 +0200
@@ -122,6 +122,19 @@ ia64_init_addr_space (void)
 		vma->vm_start = current->thread.rbs_bot & PAGE_MASK;
 		vma->vm_end = vma->vm_start + PAGE_SIZE;
 		vma->vm_flags = VM_DATA_DEFAULT_FLAGS|VM_GROWSUP|VM_ACCOUNT;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (current->mm->pax_flags & MF_PAX_PAGEEXEC) {
+			vma->vm_flags &= ~VM_EXEC;
+
+#ifdef CONFIG_PAX_MPROTECT
+			if (current->mm->pax_flags & MF_PAX_MPROTECT)
+				vma->vm_flags &= ~VM_MAYEXEC;
+#endif
+
+		}
+#endif
+
 		vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 		down_write(&current->mm->mmap_sem);
 		if (insert_vm_struct(current->mm, vma)) {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/mips/kernel/binfmt_elfn32.c linux-2.6.26.8-pax/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.26.8/arch/mips/kernel/binfmt_elfn32.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/mips/kernel/binfmt_elfn32.c	2008-10-22 12:03:06.000000000 +0200
@@ -50,6 +50,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/elfcore.h>
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/mips/kernel/binfmt_elfo32.c linux-2.6.26.8-pax/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.26.8/arch/mips/kernel/binfmt_elfo32.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/mips/kernel/binfmt_elfo32.c	2008-10-22 12:03:22.000000000 +0200
@@ -52,6 +52,13 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
+#ifdef CONFIG_PAX_ASLR
+#define PAX_ELF_ET_DYN_BASE	(test_thread_flag(TIF_32BIT_ADDR) ? 0x00400000UL : 0x00400000UL)
+
+#define PAX_DELTA_MMAP_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#define PAX_DELTA_STACK_LEN	(test_thread_flag(TIF_32BIT_ADDR) ? 27-PAGE_SHIFT : 36-PAGE_SHIFT)
+#endif
+
 #include <asm/processor.h>
 #include <linux/module.h>
 #include <linux/elfcore.h>
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/mips/kernel/process.c linux-2.6.26.8-pax/arch/mips/kernel/process.c
--- linux-2.6.26.8/arch/mips/kernel/process.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/mips/kernel/process.c	2008-10-23 12:50:15.000000000 +0200
@@ -464,15 +464,3 @@ unsigned long get_wchan(struct task_stru
 out:
 	return pc;
 }
-
-/*
- * Don't forget that the stack pointer must be aligned on a 8 bytes
- * boundary for 32-bits ABI and 16 bytes for 64-bits ABI.
- */
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() & ~PAGE_MASK;
-
-	return sp & ALMASK;
-}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/mips/kernel/syscall.c linux-2.6.26.8-pax/arch/mips/kernel/syscall.c
--- linux-2.6.26.8/arch/mips/kernel/syscall.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/mips/kernel/syscall.c	2008-07-14 03:52:23.000000000 +0200
@@ -93,6 +93,11 @@ unsigned long arch_get_unmapped_area(str
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(current->mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -103,7 +108,7 @@ unsigned long arch_get_unmapped_area(str
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
-	addr = TASK_UNMAPPED_BASE;
+	addr = current->mm->mmap_base;
 	if (do_color_align)
 		addr = COLOUR_ALIGN(addr, pgoff);
 	else
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/mips/mm/fault.c linux-2.6.26.8-pax/arch/mips/mm/fault.c
--- linux-2.6.26.8/arch/mips/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/mips/mm/fault.c	2008-07-14 03:52:23.000000000 +0200
@@ -26,6 +26,23 @@
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_report_insns(void *pc)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * This routine handles page faults.  It determines the address,
  * and the problem, and then passes it off to one of the appropriate
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/parisc/kernel/module.c linux-2.6.26.8-pax/arch/parisc/kernel/module.c
--- linux-2.6.26.8/arch/parisc/kernel/module.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/parisc/kernel/module.c	2008-07-14 03:52:23.000000000 +0200
@@ -73,16 +73,38 @@
 
 /* three functions to determine where in the module core
  * or init pieces the location is */
+static inline int in_init_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rx &&
+		loc < (me->module_init_rx + me->init_size_rx));
+}
+
+static inline int in_init_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_init_rw &&
+		loc < (me->module_init_rw + me->init_size_rw));
+}
+
 static inline int in_init(struct module *me, void *loc)
 {
-	return (loc >= me->module_init &&
-		loc <= (me->module_init + me->init_size));
+	return in_init_rx(me, loc) || in_init_rw(me, loc);
+}
+
+static inline int in_core_rx(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rx &&
+		loc < (me->module_core_rx + me->core_size_rx));
+}
+
+static inline int in_core_rw(struct module *me, void *loc)
+{
+	return (loc >= me->module_core_rw &&
+		loc < (me->module_core_rw + me->core_size_rw));
 }
 
 static inline int in_core(struct module *me, void *loc)
 {
-	return (loc >= me->module_core &&
-		loc <= (me->module_core + me->core_size));
+	return in_core_rx(me, loc) || in_core_rw(me, loc);
 }
 
 static inline int in_local(struct module *me, void *loc)
@@ -296,21 +318,21 @@ int module_frob_arch_sections(CONST Elf_
 	}
 
 	/* align things a bit */
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.got_offset = me->core_size;
-	me->core_size += gots * sizeof(struct got_entry);
-
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.fdesc_offset = me->core_size;
-	me->core_size += fdescs * sizeof(Elf_Fdesc);
-
-	me->core_size = ALIGN(me->core_size, 16);
-	me->arch.stub_offset = me->core_size;
-	me->core_size += stubs * sizeof(struct stub_entry);
-
-	me->init_size = ALIGN(me->init_size, 16);
-	me->arch.init_stub_offset = me->init_size;
-	me->init_size += init_stubs * sizeof(struct stub_entry);
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += gots * sizeof(struct got_entry);
+
+	me->core_size_rw = ALIGN(me->core_size_rw, 16);
+	me->arch.fdesc_offset = me->core_size_rw;
+	me->core_size_rw += fdescs * sizeof(Elf_Fdesc);
+
+	me->core_size_rx = ALIGN(me->core_size_rx, 16);
+	me->arch.stub_offset = me->core_size_rx;
+	me->core_size_rx += stubs * sizeof(struct stub_entry);
+
+	me->init_size_rx = ALIGN(me->init_size_rx, 16);
+	me->arch.init_stub_offset = me->init_size_rx;
+	me->init_size_rx += init_stubs * sizeof(struct stub_entry);
 
 	me->arch.got_max = gots;
 	me->arch.fdesc_max = fdescs;
@@ -330,7 +352,7 @@ static Elf64_Word get_got(struct module 
 
 	BUG_ON(value == 0);
 
-	got = me->module_core + me->arch.got_offset;
+	got = me->module_core_rw + me->arch.got_offset;
 	for (i = 0; got[i].addr; i++)
 		if (got[i].addr == value)
 			goto out;
@@ -348,7 +370,7 @@ static Elf64_Word get_got(struct module 
 #ifdef CONFIG_64BIT
 static Elf_Addr get_fdesc(struct module *me, unsigned long value)
 {
-	Elf_Fdesc *fdesc = me->module_core + me->arch.fdesc_offset;
+	Elf_Fdesc *fdesc = me->module_core_rw + me->arch.fdesc_offset;
 
 	if (!value) {
 		printk(KERN_ERR "%s: zero OPD requested!\n", me->name);
@@ -366,7 +388,7 @@ static Elf_Addr get_fdesc(struct module 
 
 	/* Create new one */
 	fdesc->addr = value;
-	fdesc->gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	fdesc->gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 	return (Elf_Addr)fdesc;
 }
 #endif /* CONFIG_64BIT */
@@ -386,12 +408,12 @@ static Elf_Addr get_stub(struct module *
 	if(init_section) {
 		i = me->arch.init_stub_count++;
 		BUG_ON(me->arch.init_stub_count > me->arch.init_stub_max);
-		stub = me->module_init + me->arch.init_stub_offset + 
+		stub = me->module_init_rx + me->arch.init_stub_offset +
 			i * sizeof(struct stub_entry);
 	} else {
 		i = me->arch.stub_count++;
 		BUG_ON(me->arch.stub_count > me->arch.stub_max);
-		stub = me->module_core + me->arch.stub_offset + 
+		stub = me->module_core_rx + me->arch.stub_offset +
 			i * sizeof(struct stub_entry);
 	}
 
@@ -759,7 +781,7 @@ register_unwind_table(struct module *me,
 
 	table = (unsigned char *)sechdrs[me->arch.unwind_section].sh_addr;
 	end = table + sechdrs[me->arch.unwind_section].sh_size;
-	gp = (Elf_Addr)me->module_core + me->arch.got_offset;
+	gp = (Elf_Addr)me->module_core_rw + me->arch.got_offset;
 
 	DEBUGP("register_unwind_table(), sect = %d at 0x%p - 0x%p (gp=0x%lx)\n",
 	       me->arch.unwind_section, table, end, gp);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/parisc/kernel/sys_parisc.c linux-2.6.26.8-pax/arch/parisc/kernel/sys_parisc.c
--- linux-2.6.26.8/arch/parisc/kernel/sys_parisc.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/parisc/kernel/sys_parisc.c	2008-07-14 03:52:23.000000000 +0200
@@ -98,7 +98,7 @@ unsigned long arch_get_unmapped_area(str
 	if (flags & MAP_FIXED)
 		return addr;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (filp) {
 		addr = get_shared_area(filp->f_mapping, addr, len, pgoff);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/parisc/kernel/traps.c linux-2.6.26.8-pax/arch/parisc/kernel/traps.c
--- linux-2.6.26.8/arch/parisc/kernel/traps.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/parisc/kernel/traps.c	2008-07-14 03:52:23.000000000 +0200
@@ -732,9 +732,7 @@ void handle_interruption(int code, struc
 
 			down_read(&current->mm->mmap_sem);
 			vma = find_vma(current->mm,regs->iaoq[0]);
-			if (vma && (regs->iaoq[0] >= vma->vm_start)
-				&& (vma->vm_flags & VM_EXEC)) {
-
+			if (vma && (regs->iaoq[0] >= vma->vm_start)) {
 				fault_address = regs->iaoq[0];
 				fault_space = regs->iasq[0];
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/parisc/mm/fault.c linux-2.6.26.8-pax/arch/parisc/mm/fault.c
--- linux-2.6.26.8/arch/parisc/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/parisc/mm/fault.c	2008-08-22 10:24:16.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/traps.h>
@@ -53,7 +54,7 @@ DEFINE_PER_CPU(struct exception_data, ex
 static unsigned long
 parisc_acctyp(unsigned long code, unsigned int inst)
 {
-	if (code == 6 || code == 16)
+	if (code == 6 || code == 7 || code == 16)
 	    return VM_EXEC;
 
 	switch (inst & 0xf0000000) {
@@ -139,6 +140,116 @@ parisc_acctyp(unsigned long code, unsign
 			}
 #endif
 
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (instruction_pointer(regs) = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when rt_sigreturn trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: unpatched PLT emulation */
+		unsigned int bl, depwi;
+
+		err = get_user(bl, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(depwi, (unsigned int *)(instruction_pointer(regs)+4));
+
+		if (err)
+			break;
+
+		if (bl == 0xEA9F1FDDU && depwi == 0xD6801C1EU) {
+			unsigned int ldw, bv, ldw2, addr = instruction_pointer(regs)-12;
+
+			err = get_user(ldw, (unsigned int *)addr);
+			err |= get_user(bv, (unsigned int *)(addr+4));
+			err |= get_user(ldw2, (unsigned int *)(addr+8));
+
+			if (err)
+				break;
+
+			if (ldw == 0x0E801096U &&
+			    bv == 0xEAC0C000U &&
+			    ldw2 == 0x0E881095U)
+			{
+				unsigned int resolver, map;
+
+				err = get_user(resolver, (unsigned int *)(instruction_pointer(regs)+8));
+				err |= get_user(map, (unsigned int *)(instruction_pointer(regs)+12));
+				if (err)
+					break;
+
+				regs->gr[20] = instruction_pointer(regs)+8;
+				regs->gr[21] = map;
+				regs->gr[22] = resolver;
+				regs->iaoq[0] = resolver | 3UL;
+				regs->iaoq[1] = regs->iaoq[0] + 4;
+				return 3;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+
+#ifndef CONFIG_PAX_EMUSIGRT
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+#endif
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int ldi1, ldi2, bel, nop;
+
+		err = get_user(ldi1, (unsigned int *)instruction_pointer(regs));
+		err |= get_user(ldi2, (unsigned int *)(instruction_pointer(regs)+4));
+		err |= get_user(bel, (unsigned int *)(instruction_pointer(regs)+8));
+		err |= get_user(nop, (unsigned int *)(instruction_pointer(regs)+12));
+
+		if (err)
+			break;
+
+		if ((ldi1 == 0x34190000U || ldi1 == 0x34190002U) &&
+		    ldi2 == 0x3414015AU &&
+		    bel == 0xE4008200U &&
+		    nop == 0x08000240U)
+		{
+			regs->gr[25] = (ldi1 & 2) >> 1;
+			regs->gr[20] = __NR_rt_sigreturn;
+			regs->gr[31] = regs->iaoq[1] + 16;
+			regs->sr[0] = regs->iasq[1];
+			regs->iaoq[0] = 0x100UL;
+			regs->iaoq[1] = regs->iaoq[0] + 4;
+			regs->iasq[0] = regs->sr[2];
+			regs->iasq[1] = regs->sr[2];
+			return 2;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 void do_page_fault(struct pt_regs *regs, unsigned long code,
 			      unsigned long address)
 {
@@ -165,8 +276,33 @@ good_area:
 
 	acc_type = parisc_acctyp(code,regs->iir);
 
-	if ((vma->vm_flags & acc_type) != acc_type)
+	if ((vma->vm_flags & acc_type) != acc_type) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && (acc_type & VM_EXEC) &&
+		    (address & ~3UL) == instruction_pointer(regs))
+		{
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 3:
+				return;
+#endif
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			case 2:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)instruction_pointer(regs), (void *)regs->gr[30]);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		goto bad_area;
+	}
 
 	/*
 	 * If for any reason at all we couldn't handle the fault, make
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/kernel/module_32.c linux-2.6.26.8-pax/arch/powerpc/kernel/module_32.c
--- linux-2.6.26.8/arch/powerpc/kernel/module_32.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/kernel/module_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -175,7 +175,7 @@ int module_frob_arch_sections(Elf32_Ehdr
 			me->arch.core_plt_section = i;
 	}
 	if (!me->arch.core_plt_section || !me->arch.init_plt_section) {
-		printk("Module doesn't contain .plt or .init.plt sections.\n");
+		printk("Module %s doesn't contain .plt or .init.plt sections.\n", me->name);
 		return -ENOEXEC;
 	}
 
@@ -216,11 +216,16 @@ static uint32_t do_plt_call(void *locati
 
 	DEBUGP("Doing plt for call to 0x%x at 0x%x\n", val, (unsigned int)location);
 	/* Init, or core PLT? */
-	if (location >= mod->module_core
-	    && location < mod->module_core + mod->core_size)
+	if ((location >= mod->module_core_rx && location < mod->module_core_rx + mod->core_size_rx) ||
+	    (location >= mod->module_core_rw && location < mod->module_core_rw + mod->core_size_rw))
 		entry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;
-	else
+	else if ((location >= mod->module_init_rx && location < mod->module_init_rx + mod->init_size_rx) ||
+		 (location >= mod->module_init_rw && location < mod->module_init_rw + mod->init_size_rw))
 		entry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;
+	else {
+		printk(KERN_ERR "%s: invalid R_PPC_REL24 entry found\n", mod->name);
+		return ~0UL;
+	}
 
 	/* Find this entry, or if that fails, the next avail. entry */
 	while (entry->jump[0]) {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/kernel/signal_32.c linux-2.6.26.8-pax/arch/powerpc/kernel/signal_32.c
--- linux-2.6.26.8/arch/powerpc/kernel/signal_32.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/kernel/signal_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -743,7 +743,7 @@ int handle_rt_signal32(unsigned long sig
 	/* Save user registers on the stack */
 	frame = &rt_sf->uc.uc_mcontext;
 	addr = frame;
-	if (vdso32_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso32_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		if (save_user_regs(regs, frame, 0))
 			goto badframe;
 		regs->link = current->mm->context.vdso_base + vdso32_rt_sigtramp;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/kernel/signal_64.c linux-2.6.26.8-pax/arch/powerpc/kernel/signal_64.c
--- linux-2.6.26.8/arch/powerpc/kernel/signal_64.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/kernel/signal_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -371,7 +371,7 @@ int handle_rt_signal64(int signr, struct
 	current->thread.fpscr.val = 0;
 
 	/* Set up to return from userspace. */
-	if (vdso64_rt_sigtramp && current->mm->context.vdso_base) {
+	if (vdso64_rt_sigtramp && current->mm->context.vdso_base != ~0UL) {
 		regs->link = current->mm->context.vdso_base + vdso64_rt_sigtramp;
 	} else {
 		err |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/kernel/vdso.c linux-2.6.26.8-pax/arch/powerpc/kernel/vdso.c
--- linux-2.6.26.8/arch/powerpc/kernel/vdso.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/kernel/vdso.c	2008-07-14 03:52:23.000000000 +0200
@@ -212,7 +212,7 @@ int arch_setup_additional_pages(struct l
 	vdso_base = VDSO32_MBASE;
 #endif
 
-	current->mm->context.vdso_base = 0;
+	current->mm->context.vdso_base = ~0UL;
 
 	/* vDSO has a problem and was disabled, just don't "enable" it for the
 	 * process
@@ -229,7 +229,7 @@ int arch_setup_additional_pages(struct l
 	 */
 	down_write(&mm->mmap_sem);
 	vdso_base = get_unmapped_area(NULL, vdso_base,
-				      vdso_pages << PAGE_SHIFT, 0, 0);
+				      vdso_pages << PAGE_SHIFT, 0, MAP_PRIVATE | MAP_EXECUTABLE);
 	if (IS_ERR_VALUE(vdso_base)) {
 		rc = vdso_base;
 		goto fail_mmapsem;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/mm/fault.c linux-2.6.26.8-pax/arch/powerpc/mm/fault.c
--- linux-2.6.26.8/arch/powerpc/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/mm/fault.c	2008-08-22 10:24:35.000000000 +0200
@@ -29,6 +29,10 @@
 #include <linux/module.h>
 #include <linux/kprobes.h>
 #include <linux/kdebug.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/unistd.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -62,6 +66,363 @@ static inline int notify_page_fault(stru
 }
 #endif
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static int pax_syscall_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.fault = pax_syscall_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int *)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int *)addr);
+			err |= get_user(add, (unsigned int *)(addr+4));
+			err |= get_user(li2, (unsigned int *)(addr+8));
+			err |= get_user(addis2, (unsigned int *)(addr+12));
+			err |= get_user(mtctr, (unsigned int *)(addr+16));
+			err |= get_user(li3, (unsigned int *)(addr+20));
+			err |= get_user(addis3, (unsigned int *)(addr+24));
+			err |= get_user(bctr, (unsigned int *)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int *)addr);
+			err |= get_user(addi, (unsigned int *)(addr+4));
+			err |= get_user(rlwinm, (unsigned int *)(addr+8));
+			err |= get_user(add, (unsigned int *)(addr+12));
+			err |= get_user(li2, (unsigned int *)(addr+16));
+			err |= get_user(addis2, (unsigned int *)(addr+20));
+			err |= get_user(mtctr, (unsigned int *)(addr+24));
+			err |= get_user(li3, (unsigned int *)(addr+28));
+			err |= get_user(addis3, (unsigned int *)(addr+32));
+			err |= get_user(bctr, (unsigned int *)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int *)addr);
+			err |= get_user(lwz, (unsigned int *)(addr+4));
+			err |= get_user(mtctr, (unsigned int *)(addr+8));
+			err |= get_user(bctr, (unsigned int *)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int *)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = __NR_sigreturn;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_rt_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = __NR_rt_sigreturn;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -157,7 +518,7 @@ int __kprobes do_page_fault(struct pt_re
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (trap == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & DSISR_ISSTORE;
 #else
@@ -355,6 +716,37 @@ bad_area:
 bad_area_nosemaphore:
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+#ifdef CONFIG_PPC64
+			if (is_exec && (error_code & DSISR_PROTFAULT)) {
+#else
+			if (is_exec && regs->nip == address) {
+#endif
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return 0;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return 0;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void *)regs->nip, (void *)regs->gpr[PT_R1]);
+				do_group_exit(SIGKILL);
+			}
+		}
+#endif
+
 		_exception(SIGSEGV, regs, code, address);
 		return 0;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/powerpc/mm/mmap.c linux-2.6.26.8-pax/arch/powerpc/mm/mmap.c
--- linux-2.6.26.8/arch/powerpc/mm/mmap.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/powerpc/mm/mmap.c	2008-07-14 03:52:23.000000000 +0200
@@ -75,10 +75,22 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
 		mm->mmap_base = mmap_base();
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/ppc/mm/fault.c linux-2.6.26.8-pax/arch/ppc/mm/fault.c
--- linux-2.6.26.8/arch/ppc/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/ppc/mm/fault.c	2008-08-22 10:24:47.000000000 +0200
@@ -25,6 +25,10 @@
 #include <linux/interrupt.h>
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
+#include <linux/unistd.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -48,6 +52,363 @@ unsigned long pte_misses;	/* updated by 
 unsigned long pte_errors;	/* updated by do_page_fault() */
 unsigned int probingmem;
 
+#ifdef CONFIG_PAX_EMUSIGRT
+void pax_syscall_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_syscall = 0UL;
+}
+
+static int pax_syscall_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x44000002U; /* sc */
+	__flush_dcache_icache(kaddr);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_syscall_close,
+	.fault = pax_syscall_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+/*
+ * PaX: decide what to do with offenders (regs->nip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched GOT trampoline was detected
+ *         3 when patched PLT trampoline was detected
+ *         4 when unpatched PLT trampoline was detected
+ *         5 when sigreturn trampoline was detected
+ *         6 when rt_sigreturn trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#if defined(CONFIG_PAX_EMUPLT) || defined(CONFIG_PAX_EMUSIGRT)
+	int err;
+#endif
+
+#ifdef CONFIG_PAX_EMUPLT
+	do { /* PaX: patched GOT emulation */
+		unsigned int blrl;
+
+		err = get_user(blrl, (unsigned int *)regs->nip);
+
+		if (!err && blrl == 0x4E800021U) {
+			unsigned long temp = regs->nip;
+
+			regs->nip = regs->link & 0xFFFFFFFCUL;
+			regs->link = temp + 4UL;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int b;
+
+		err = get_user(b, (unsigned int *)regs->nip);
+
+		if (!err && (b & 0xFC000003U) == 0x48000000U) {
+			regs->nip += (((b | 0xFC000000UL) ^ 0x02000000UL) + 0x02000000UL);
+			return 3;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation #1 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(rlwinm, (unsigned int *)addr);
+			err |= get_user(add, (unsigned int *)(addr+4));
+			err |= get_user(li2, (unsigned int *)(addr+8));
+			err |= get_user(addis2, (unsigned int *)(addr+12));
+			err |= get_user(mtctr, (unsigned int *)(addr+16));
+			err |= get_user(li3, (unsigned int *)(addr+20));
+			err |= get_user(addis3, (unsigned int *)(addr+24));
+			err |= get_user(bctr, (unsigned int *)(addr+28));
+
+			if (err)
+				break;
+
+			if (rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+
+#if 0
+	do { /* PaX: unpatched PLT emulation #2 */
+		unsigned int lis, lwzu, b, bctr;
+
+		err = get_user(lis, (unsigned int *)regs->nip);
+		err |= get_user(lwzu, (unsigned int *)(regs->nip+4));
+		err |= get_user(b, (unsigned int *)(regs->nip+8));
+		err |= get_user(bctr, (unsigned int *)(regs->nip+12));
+
+		if (err)
+			break;
+
+		if ((lis & 0xFFFF0000U) == 0x39600000U &&
+		    (lwzu & 0xU) == 0xU &&
+		    (b & 0xFC000003U) == 0x48000000U &&
+		    bctr == 0x4E800420U)
+		{
+			unsigned int addis, addi, rlwinm, add, li2, addis2, mtctr, li3, addis3, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 12 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int *)addr);
+			err |= get_user(addi, (unsigned int *)(addr+4));
+			err |= get_user(rlwinm, (unsigned int *)(addr+8));
+			err |= get_user(add, (unsigned int *)(addr+12));
+			err |= get_user(li2, (unsigned int *)(addr+16));
+			err |= get_user(addis2, (unsigned int *)(addr+20));
+			err |= get_user(mtctr, (unsigned int *)(addr+24));
+			err |= get_user(li3, (unsigned int *)(addr+28));
+			err |= get_user(addis3, (unsigned int *)(addr+32));
+			err |= get_user(bctr, (unsigned int *)(addr+36));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (addi & 0xFFFF0000U) == 0x396B0000U &&
+			    rlwinm == 0x556C083CU &&
+			    add == 0x7D6C5A14U &&
+			    (li2 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis2 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    mtctr == 0x7D8903A6U &&
+			    (li3 & 0xFFFF0000U) == 0x39800000U &&
+			    (addis3 & 0xFFFF0000U) == 0x3D8C0000U &&
+			    bctr == 0x4E800420U)
+			{
+				regs->gpr[PT_R11] = 3 * (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] = (((li3 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->gpr[PT_R12] += (addis3 & 0xFFFFU) << 16;
+				regs->ctr = (((li2 | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				regs->ctr += (addis2 & 0xFFFFU) << 16;
+				regs->nip = regs->ctr;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+	do { /* PaX: unpatched PLT emulation #3 */
+		unsigned int li, b;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(b, (unsigned int *)(regs->nip+4));
+
+		if (!err && (li & 0xFFFF0000U) == 0x39600000U && (b & 0xFC000003U) == 0x48000000U) {
+			unsigned int addis, lwz, mtctr, bctr;
+			unsigned long addr = b | 0xFC000000UL;
+
+			addr = regs->nip + 4 + ((addr ^ 0x02000000UL) + 0x02000000UL);
+			err = get_user(addis, (unsigned int *)addr);
+			err |= get_user(lwz, (unsigned int *)(addr+4));
+			err |= get_user(mtctr, (unsigned int *)(addr+8));
+			err |= get_user(bctr, (unsigned int *)(addr+12));
+
+			if (err)
+				break;
+
+			if ((addis & 0xFFFF0000U) == 0x3D6B0000U &&
+			    (lwz & 0xFFFF0000U) == 0x816B0000U &&
+			    mtctr == 0x7D6903A6U &&
+			    bctr == 0x4E800420U)
+			{
+				unsigned int r11;
+
+				addr = (addis << 16) + (((li | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+				addr += (((lwz | 0xFFFF0000UL) ^ 0x00008000UL) + 0x00008000UL);
+
+				err = get_user(r11, (unsigned int *)addr);
+				if (err)
+					break;
+
+				regs->gpr[PT_R11] = r11;
+				regs->ctr = r11;
+				regs->nip = r11;
+				return 4;
+			}
+		}
+	} while (0);
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+	do { /* PaX: sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned long call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto emulate;
+
+			vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				goto emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+emulate:
+			regs->gpr[PT_R0] = __NR_sigreturn;
+			regs->nip = call_syscall;
+			return 5;
+		}
+	} while (0);
+
+	do { /* PaX: rt_sigreturn emulation */
+		unsigned int li, sc;
+
+		err = get_user(li, (unsigned int *)regs->nip);
+		err |= get_user(sc, (unsigned int *)(regs->nip+4));
+
+		if (!err && li == 0x38000000U + __NR_rt_sigreturn && sc == 0x44000002U) {
+			struct vm_area_struct *vma;
+			unsigned int call_syscall;
+
+			down_read(&current->mm->mmap_sem);
+			call_syscall = current->mm->call_syscall;
+			up_read(&current->mm->mmap_sem);
+			if (likely(call_syscall))
+				goto rt_emulate;
+
+			vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+			down_write(&current->mm->mmap_sem);
+			if (current->mm->call_syscall) {
+				call_syscall = current->mm->call_syscall;
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				goto rt_emulate;
+			}
+
+			call_syscall = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+			if (!vma || (call_syscall & ~PAGE_MASK)) {
+				up_write(&current->mm->mmap_sem);
+				if (vma)
+					kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			if (pax_insert_vma(vma, call_syscall)) {
+				up_write(&current->mm->mmap_sem);
+				kmem_cache_free(vm_area_cachep, vma);
+				return 1;
+			}
+
+			current->mm->call_syscall = call_syscall;
+			up_write(&current->mm->mmap_sem);
+
+rt_emulate:
+			regs->gpr[PT_R0] = __NR_rt_sigreturn;
+			regs->nip = call_syscall;
+			return 6;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 /*
  * Check whether the instruction at regs->nip is a store using
  * an update addressing form which will update r1.
@@ -109,7 +470,7 @@ int do_page_fault(struct pt_regs *regs, 
 	 * indicate errors in DSISR but can validly be set in SRR1.
 	 */
 	if (TRAP(regs) == 0x400)
-		error_code &= 0x48200000;
+		error_code &= 0x58200000;
 	else
 		is_write = error_code & 0x02000000;
 #endif /* CONFIG_4xx || CONFIG_BOOKE */
@@ -204,15 +565,14 @@ good_area:
 		pte_t *ptep;
 		pmd_t *pmdp;
 
-#if 0
+#if 1
 		/* It would be nice to actually enforce the VM execute
 		   permission on CPUs which can do so, but far too
 		   much stuff in userspace doesn't get the permissions
 		   right, so we let any page be executed for now. */
 		if (! (vma->vm_flags & VM_EXEC))
 			goto bad_area;
-#endif
-
+#else
 		/* Since 4xx/Book-E supports per-page execute permission,
 		 * we lazily flush dcache to icache. */
 		ptep = NULL;
@@ -235,6 +595,7 @@ good_area:
 			pte_unmap_unlock(ptep, ptl);
 		}
 #endif
+#endif
 	/* a read */
 	} else {
 		/* protection fault */
@@ -278,6 +639,33 @@ bad_area:
 
 	/* User mode accesses cause a SIGSEGV */
 	if (user_mode(regs)) {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if (mm->pax_flags & MF_PAX_PAGEEXEC) {
+			if ((TRAP(regs) == 0x400) && (regs->nip == address)) {
+				switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+				case 2:
+				case 3:
+				case 4:
+					return 0;
+#endif
+
+#ifdef CONFIG_PAX_EMUSIGRT
+				case 5:
+				case 6:
+					return 0;
+#endif
+
+				}
+
+				pax_report_fault(regs, (void *)regs->nip, (void *)regs->gpr[1]);
+				do_group_exit(SIGKILL);
+			}
+		}
+#endif
+
 		_exception(SIGSEGV, regs, code, address);
 		return 0;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/s390/kernel/module.c linux-2.6.26.8-pax/arch/s390/kernel/module.c
--- linux-2.6.26.8/arch/s390/kernel/module.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/s390/kernel/module.c	2008-07-14 03:52:23.000000000 +0200
@@ -166,11 +166,11 @@ module_frob_arch_sections(Elf_Ehdr *hdr,
 
 	/* Increase core size by size of got & plt and set start
 	   offsets for got and plt. */
-	me->core_size = ALIGN(me->core_size, 4);
-	me->arch.got_offset = me->core_size;
-	me->core_size += me->arch.got_size;
-	me->arch.plt_offset = me->core_size;
-	me->core_size += me->arch.plt_size;
+	me->core_size_rw = ALIGN(me->core_size_rw, 4);
+	me->arch.got_offset = me->core_size_rw;
+	me->core_size_rw += me->arch.got_size;
+	me->arch.plt_offset = me->core_size_rx;
+	me->core_size_rx += me->arch.plt_size;
 	return 0;
 }
 
@@ -256,7 +256,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		if (info->got_initialized == 0) {
 			Elf_Addr *gotent;
 
-			gotent = me->module_core + me->arch.got_offset +
+			gotent = me->module_core_rw + me->arch.got_offset +
 				info->got_offset;
 			*gotent = val;
 			info->got_initialized = 1;
@@ -280,7 +280,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		else if (r_type == R_390_GOTENT ||
 			 r_type == R_390_GOTPLTENT)
 			*(unsigned int *) loc =
-				(val + (Elf_Addr) me->module_core - loc) >> 1;
+				(val + (Elf_Addr) me->module_core_rw - loc) >> 1;
 		else if (r_type == R_390_GOT64 ||
 			 r_type == R_390_GOTPLT64)
 			*(unsigned long *) loc = val;
@@ -294,7 +294,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_PLTOFF64:	/* 16 bit offset from GOT to PLT. */
 		if (info->plt_initialized == 0) {
 			unsigned int *ip;
-			ip = me->module_core + me->arch.plt_offset +
+			ip = me->module_core_rx + me->arch.plt_offset +
 				info->plt_offset;
 #ifndef CONFIG_64BIT
 			ip[0] = 0x0d105810; /* basr 1,0; l 1,6(1); br 1 */
@@ -316,7 +316,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 			val = me->arch.plt_offset - me->arch.got_offset +
 				info->plt_offset + rela->r_addend;
 		else
-			val =  (Elf_Addr) me->module_core +
+			val =  (Elf_Addr) me->module_core_rx +
 				me->arch.plt_offset + info->plt_offset + 
 				rela->r_addend - loc;
 		if (r_type == R_390_PLT16DBL)
@@ -336,7 +336,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 	case R_390_GOTOFF32:	/* 32 bit offset to GOT.  */
 	case R_390_GOTOFF64:	/* 64 bit offset to GOT. */
 		val = val + rela->r_addend -
-			((Elf_Addr) me->module_core + me->arch.got_offset);
+			((Elf_Addr) me->module_core_rw + me->arch.got_offset);
 		if (r_type == R_390_GOTOFF16)
 			*(unsigned short *) loc = val;
 		else if (r_type == R_390_GOTOFF32)
@@ -346,7 +346,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 		break;
 	case R_390_GOTPC:	/* 32 bit PC relative offset to GOT. */
 	case R_390_GOTPCDBL:	/* 32 bit PC rel. off. to GOT shifted by 1. */
-		val = (Elf_Addr) me->module_core + me->arch.got_offset +
+		val = (Elf_Addr) me->module_core_rw + me->arch.got_offset +
 			rela->r_addend - loc;
 		if (r_type == R_390_GOTPC)
 			*(unsigned int *) loc = val;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc/kernel/sys_sparc.c linux-2.6.26.8-pax/arch/sparc/kernel/sys_sparc.c
--- linux-2.6.26.8/arch/sparc/kernel/sys_sparc.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc/kernel/sys_sparc.c	2008-07-14 03:52:23.000000000 +0200
@@ -56,7 +56,7 @@ unsigned long arch_get_unmapped_area(str
 	if (ARCH_SUN4C_SUN4 && len > 0x20000000)
 		return -ENOMEM;
 	if (!addr)
-		addr = TASK_UNMAPPED_BASE;
+		addr = current->mm->mmap_base;
 
 	if (flags & MAP_SHARED)
 		addr = COLOUR_ALIGN(addr);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc/mm/fault.c linux-2.6.26.8-pax/arch/sparc/mm/fault.c
--- linux-2.6.26.8/arch/sparc/mm/fault.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc/mm/fault.c	2008-08-22 10:24:59.000000000 +0200
@@ -21,6 +21,9 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/kdebug.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/page.h>
@@ -167,6 +170,249 @@ static unsigned long compute_si_addr(str
 	return safe_compute_effective_address(regs, insn);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+void pax_emuplt_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static int pax_emuplt_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(vmf->page);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.fault = pax_emuplt_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+
+/*
+ * PaX: decide what to do with offenders (regs->pc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int *)regs->pc);
+		err |= get_user(sethi2, (unsigned int *)(regs->pc+4));
+		err |= get_user(jmpl, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned int addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int *)regs->pc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned int addr;
+
+			addr = regs->pc + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->pc);
+		err |= get_user(jmpl, (unsigned int *)(regs->pc+4));
+		err |= get_user(nop, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFE000U) ^ 0x00001000U) + 0x00001000U);
+			regs->pc = addr;
+			regs->npc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->pc);
+		err |= get_user(ba, (unsigned int *)(regs->pc+4));
+		err |= get_user(nop, (unsigned int *)(regs->pc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned int addr, save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->pc + 4 + ((((ba | 0xFFC00000U) ^ 0x00200000U) + 0x00200000U) << 2);
+			else
+				addr = regs->pc + 4 + ((((ba | 0xFFF80000U) ^ 0x00040000U) + 0x00040000U) << 2);
+
+			err = get_user(save, (unsigned int *)addr);
+			err |= get_user(call, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->pc = call_dl_resolve;
+				regs->npc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int *)(regs->pc-4));
+		err |= get_user(call, (unsigned int *)regs->pc);
+		err |= get_user(nop, (unsigned int *)(regs->pc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned int dl_resolve = regs->pc + ((((call | 0xC0000000U) ^ 0x20000000U) + 0x20000000U) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->pc;
+			regs->pc = dl_resolve;
+			regs->npc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 			       unsigned long address)
 {
@@ -231,6 +477,24 @@ good_area:
 		if(!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) && text_fault && !(vma->vm_flags & VM_EXEC)) {
+			up_read(&mm->mmap_sem);
+			switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+			case 2:
+			case 3:
+				return;
+#endif
+
+			}
+			pax_report_fault(regs, (void *)regs->pc, (void *)regs->u_regs[UREG_FP]);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
 		/* Allow reads even for write-only mappings */
 		if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
 			goto bad_area;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc/mm/init.c linux-2.6.26.8-pax/arch/sparc/mm/init.c
--- linux-2.6.26.8/arch/sparc/mm/init.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc/mm/init.c	2008-07-14 03:52:23.000000000 +0200
@@ -311,6 +311,9 @@ extern void device_scan(void);
 pgprot_t PAGE_SHARED __read_mostly;
 EXPORT_SYMBOL(PAGE_SHARED);
 
+pgprot_t PAGE_SHARED_NOEXEC __read_mostly;
+EXPORT_SYMBOL(PAGE_SHARED_NOEXEC);
+
 void __init paging_init(void)
 {
 	switch(sparc_cpu_model) {
@@ -336,17 +339,17 @@ void __init paging_init(void)
 
 	/* Initialize the protection map with non-constant, MMU dependent values. */
 	protection_map[0] = PAGE_NONE;
-	protection_map[1] = PAGE_READONLY;
-	protection_map[2] = PAGE_COPY;
-	protection_map[3] = PAGE_COPY;
+	protection_map[1] = PAGE_READONLY_NOEXEC;
+	protection_map[2] = PAGE_COPY_NOEXEC;
+	protection_map[3] = PAGE_COPY_NOEXEC;
 	protection_map[4] = PAGE_READONLY;
 	protection_map[5] = PAGE_READONLY;
 	protection_map[6] = PAGE_COPY;
 	protection_map[7] = PAGE_COPY;
 	protection_map[8] = PAGE_NONE;
-	protection_map[9] = PAGE_READONLY;
-	protection_map[10] = PAGE_SHARED;
-	protection_map[11] = PAGE_SHARED;
+	protection_map[9] = PAGE_READONLY_NOEXEC;
+	protection_map[10] = PAGE_SHARED_NOEXEC;
+	protection_map[11] = PAGE_SHARED_NOEXEC;
 	protection_map[12] = PAGE_READONLY;
 	protection_map[13] = PAGE_READONLY;
 	protection_map[14] = PAGE_SHARED;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc/mm/srmmu.c linux-2.6.26.8-pax/arch/sparc/mm/srmmu.c
--- linux-2.6.26.8/arch/sparc/mm/srmmu.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc/mm/srmmu.c	2008-07-14 03:52:23.000000000 +0200
@@ -2160,6 +2160,13 @@ void __init ld_mmu_srmmu(void)
 	PAGE_SHARED = pgprot_val(SRMMU_PAGE_SHARED);
 	BTFIXUPSET_INT(page_copy, pgprot_val(SRMMU_PAGE_COPY));
 	BTFIXUPSET_INT(page_readonly, pgprot_val(SRMMU_PAGE_RDONLY));
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	PAGE_SHARED_NOEXEC = pgprot_val(SRMMU_PAGE_SHARED_NOEXEC);
+	BTFIXUPSET_INT(page_copy_noexec, pgprot_val(SRMMU_PAGE_COPY_NOEXEC));
+	BTFIXUPSET_INT(page_readonly_noexec, pgprot_val(SRMMU_PAGE_RDONLY_NOEXEC));
+#endif
+
 	BTFIXUPSET_INT(page_kernel, pgprot_val(SRMMU_PAGE_KERNEL));
 	page_kernel = pgprot_val(SRMMU_PAGE_KERNEL);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc64/kernel/Makefile linux-2.6.26.8-pax/arch/sparc64/kernel/Makefile
--- linux-2.6.26.8/arch/sparc64/kernel/Makefile	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc64/kernel/Makefile	2008-07-14 03:52:23.000000000 +0200
@@ -3,7 +3,7 @@
 #
 
 EXTRA_AFLAGS := -ansi
-EXTRA_CFLAGS := -Werror
+#EXTRA_CFLAGS := -Werror
 
 extra-y		:= head.o init_task.o vmlinux.lds
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc64/kernel/sys_sparc.c linux-2.6.26.8-pax/arch/sparc64/kernel/sys_sparc.c
--- linux-2.6.26.8/arch/sparc64/kernel/sys_sparc.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc64/kernel/sys_sparc.c	2008-07-14 03:52:23.000000000 +0200
@@ -124,7 +124,7 @@ unsigned long arch_get_unmapped_area(str
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) &&
+		if ((filp || (flags & MAP_SHARED)) &&
 		    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))
 			return -EINVAL;
 		return addr;
@@ -139,6 +139,10 @@ unsigned long arch_get_unmapped_area(str
 	if (filp || (flags & MAP_SHARED))
 		do_color_align = 1;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		if (do_color_align)
 			addr = COLOUR_ALIGN(addr, pgoff);
@@ -152,9 +156,9 @@ unsigned long arch_get_unmapped_area(str
 	}
 
 	if (len > mm->cached_hole_size) {
-	        start_addr = addr = mm->free_area_cache;
+		start_addr = addr = mm->free_area_cache;
 	} else {
-	        start_addr = addr = TASK_UNMAPPED_BASE;
+		start_addr = addr = mm->mmap_base;
 	        mm->cached_hole_size = 0;
 	}
 
@@ -174,8 +178,8 @@ full_search:
 			vma = find_vma(mm, VA_EXCLUDE_END);
 		}
 		if (unlikely(task_size < addr)) {
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
@@ -215,7 +219,7 @@ arch_get_unmapped_area_topdown(struct fi
 		/* We do not accept a shared mapping if it would violate
 		 * cache aliasing constraints.
 		 */
-		if ((flags & MAP_SHARED) &&
+		if ((filp || (flags & MAP_SHARED)) &&
 		    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))
 			return -EINVAL;
 		return addr;
@@ -378,6 +382,12 @@ void arch_pick_mmap_layout(struct mm_str
 	    current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY ||
 	    sysctl_legacy_va_layout) {
 		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
@@ -392,6 +402,12 @@ void arch_pick_mmap_layout(struct mm_str
 			gap = (task_size / 6 * 5);
 
 		mm->mmap_base = PAGE_ALIGN(task_size - gap - random_factor);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc64/mm/Makefile linux-2.6.26.8-pax/arch/sparc64/mm/Makefile
--- linux-2.6.26.8/arch/sparc64/mm/Makefile	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc64/mm/Makefile	2008-07-14 03:52:23.000000000 +0200
@@ -2,7 +2,7 @@
 #
 
 EXTRA_AFLAGS := -ansi
-EXTRA_CFLAGS := -Werror
+#EXTRA_CFLAGS := -Werror
 
 obj-y    := ultra.o tlb.o tsb.o fault.o init.o generic.o
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/sparc64/mm/fault.c linux-2.6.26.8-pax/arch/sparc64/mm/fault.c
--- linux-2.6.26.8/arch/sparc64/mm/fault.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/sparc64/mm/fault.c	2008-08-22 10:25:09.000000000 +0200
@@ -20,6 +20,9 @@
 #include <linux/kprobes.h>
 #include <linux/kallsyms.h>
 #include <linux/kdebug.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/compiler.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -262,6 +265,367 @@ cannot_handle:
 	unhandled_fault (address, current, regs);
 }
 
+#ifdef CONFIG_PAX_PAGEEXEC
+#ifdef CONFIG_PAX_EMUPLT
+static void pax_emuplt_close(struct vm_area_struct *vma)
+{
+	vma->vm_mm->call_dl_resolve = 0UL;
+}
+
+static int pax_emuplt_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	unsigned int *kaddr;
+
+	vmf->page = alloc_page(GFP_HIGHUSER);
+	if (!vmf->page)
+		return VM_FAULT_OOM;
+
+	kaddr = kmap(vmf->page);
+	memset(kaddr, 0, PAGE_SIZE);
+	kaddr[0] = 0x9DE3BFA8U; /* save */
+	flush_dcache_page(vmf->page);
+	kunmap(vmf->page);
+	return VM_FAULT_MAJOR;
+}
+
+static struct vm_operations_struct pax_vm_ops = {
+	.close = pax_emuplt_close,
+	.fault = pax_emuplt_fault
+};
+
+static int pax_insert_vma(struct vm_area_struct *vma, unsigned long addr)
+{
+	int ret;
+
+	vma->vm_mm = current->mm;
+	vma->vm_start = addr;
+	vma->vm_end = addr + PAGE_SIZE;
+	vma->vm_flags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYEXEC;
+	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+	vma->vm_ops = &pax_vm_ops;
+
+	ret = insert_vm_struct(current->mm, vma);
+	if (ret)
+		return ret;
+
+	++current->mm->total_vm;
+	return 0;
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->tpc = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when patched PLT trampoline was detected
+ *         3 when unpatched PLT trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+
+#ifdef CONFIG_PAX_EMUPLT
+	int err;
+
+	do { /* PaX: patched PLT emulation #1 */
+		unsigned int sethi1, sethi2, jmpl;
+
+		err = get_user(sethi1, (unsigned int *)regs->tpc);
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+4));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi2 & 0x003FFFFFU) << 10;
+			addr = regs->u_regs[UREG_G1];
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	{ /* PaX: patched PLT emulation #2 */
+		unsigned int ba;
+
+		err = get_user(ba, (unsigned int *)regs->tpc);
+
+		if (!err && (ba & 0xFFC00000U) == 0x30800000U) {
+			unsigned long addr;
+
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	}
+
+	do { /* PaX: patched PLT emulation #3 */
+		unsigned int sethi, jmpl, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (jmpl & 0xFFFFE000U) == 0x81C06000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr += (((jmpl | 0xFFFFFFFFFFFFE000UL) ^ 0x00001000UL) + 0x00001000UL);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #4 */
+		unsigned int mov1, call, mov2;
+
+		err = get_user(mov1, (unsigned int *)regs->tpc);
+		err |= get_user(call, (unsigned int *)(regs->tpc+4));
+		err |= get_user(mov2, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if (mov1 == 0x8210000FU &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    mov2 == 0x9E100001U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = regs->u_regs[UREG_RETPC];
+			addr = regs->tpc + 4 + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #5 */
+		unsigned int sethi1, sethi2, or1, or2, sllx, jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int *)regs->tpc);
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+4));
+		err |= get_user(or1, (unsigned int *)(regs->tpc+8));
+		err |= get_user(or2, (unsigned int *)(regs->tpc+12));
+		err |= get_user(sllx, (unsigned int *)(regs->tpc+16));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+20));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+24));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    (or1 & 0xFFFFE000U) == 0x82106000U &&
+		    (or2 & 0xFFFFE000U) == 0x8A116000U &&
+		    sllx == 0x83287020 &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = ((sethi1 & 0x003FFFFFU) << 10) | (or1 & 0x000003FFU);
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or2 & 0x000003FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #6 */
+		unsigned int sethi1, sethi2, sllx, or,  jmpl, nop;
+
+		err = get_user(sethi1, (unsigned int *)regs->tpc);
+		err |= get_user(sethi2, (unsigned int *)(regs->tpc+4));
+		err |= get_user(sllx, (unsigned int *)(regs->tpc+8));
+		err |= get_user(or, (unsigned int *)(regs->tpc+12));
+		err |= get_user(jmpl, (unsigned int *)(regs->tpc+16));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+20));
+
+		if (err)
+			break;
+
+		if ((sethi1 & 0xFFC00000U) == 0x03000000U &&
+		    (sethi2 & 0xFFC00000U) == 0x0B000000U &&
+		    sllx == 0x83287020 &&
+		    (or & 0xFFFFE000U) == 0x8A116000U &&
+		    jmpl == 0x81C04005U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			regs->u_regs[UREG_G1] = (sethi1 & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] <<= 32;
+			regs->u_regs[UREG_G5] = ((sethi2 & 0x003FFFFFU) << 10) | (or & 0x3FFU);
+			addr = regs->u_regs[UREG_G1] + regs->u_regs[UREG_G5];
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: patched PLT emulation #7 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(ba, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    (ba & 0xFFF00000U) == 0x30600000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+
+			addr = (sethi & 0x003FFFFFU) << 10;
+			regs->u_regs[UREG_G1] = addr;
+			addr = regs->tpc + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+			regs->tpc = addr;
+			regs->tnpc = addr+4;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 1 */
+		unsigned int sethi, ba, nop;
+
+		err = get_user(sethi, (unsigned int *)regs->tpc);
+		err |= get_user(ba, (unsigned int *)(regs->tpc+4));
+		err |= get_user(nop, (unsigned int *)(regs->tpc+8));
+
+		if (err)
+			break;
+
+		if ((sethi & 0xFFC00000U) == 0x03000000U &&
+		    ((ba & 0xFFC00000U) == 0x30800000U || (ba & 0xFFF80000U) == 0x30680000U) &&
+		    nop == 0x01000000U)
+		{
+			unsigned long addr;
+			unsigned int save, call;
+
+			if ((ba & 0xFFC00000U) == 0x30800000U)
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFC00000UL) ^ 0x00200000UL) + 0x00200000UL) << 2);
+			else
+				addr = regs->tpc + 4 + ((((ba | 0xFFFFFFFFFFF80000UL) ^ 0x00040000UL) + 0x00040000UL) << 2);
+
+			err = get_user(save, (unsigned int *)addr);
+			err |= get_user(call, (unsigned int *)(addr+4));
+			err |= get_user(nop, (unsigned int *)(addr+8));
+			if (err)
+				break;
+
+			if (save == 0x9DE3BFA8U &&
+			    (call & 0xC0000000U) == 0x40000000U &&
+			    nop == 0x01000000U)
+			{
+				struct vm_area_struct *vma;
+				unsigned long call_dl_resolve;
+
+				down_read(&current->mm->mmap_sem);
+				call_dl_resolve = current->mm->call_dl_resolve;
+				up_read(&current->mm->mmap_sem);
+				if (likely(call_dl_resolve))
+					goto emulate;
+
+				vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);
+
+				down_write(&current->mm->mmap_sem);
+				if (current->mm->call_dl_resolve) {
+					call_dl_resolve = current->mm->call_dl_resolve;
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					goto emulate;
+				}
+
+				call_dl_resolve = get_unmapped_area(NULL, 0UL, PAGE_SIZE, 0UL, MAP_PRIVATE);
+				if (!vma || (call_dl_resolve & ~PAGE_MASK)) {
+					up_write(&current->mm->mmap_sem);
+					if (vma)
+						kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				if (pax_insert_vma(vma, call_dl_resolve)) {
+					up_write(&current->mm->mmap_sem);
+					kmem_cache_free(vm_area_cachep, vma);
+					return 1;
+				}
+
+				current->mm->call_dl_resolve = call_dl_resolve;
+				up_write(&current->mm->mmap_sem);
+
+emulate:
+				regs->u_regs[UREG_G1] = (sethi & 0x003FFFFFU) << 10;
+				regs->tpc = call_dl_resolve;
+				regs->tnpc = addr+4;
+				return 3;
+			}
+		}
+	} while (0);
+
+	do { /* PaX: unpatched PLT emulation step 2 */
+		unsigned int save, call, nop;
+
+		err = get_user(save, (unsigned int *)(regs->tpc-4));
+		err |= get_user(call, (unsigned int *)regs->tpc);
+		err |= get_user(nop, (unsigned int *)(regs->tpc+4));
+		if (err)
+			break;
+
+		if (save == 0x9DE3BFA8U &&
+		    (call & 0xC0000000U) == 0x40000000U &&
+		    nop == 0x01000000U)
+		{
+			unsigned long dl_resolve = regs->tpc + ((((call | 0xFFFFFFFFC0000000UL) ^ 0x20000000UL) + 0x20000000UL) << 2);
+
+			regs->u_regs[UREG_RETPC] = regs->tpc;
+			regs->tpc = dl_resolve;
+			regs->tnpc = dl_resolve+4;
+			return 3;
+		}
+	} while (0);
+#endif
+
+	return 1;
+}
+
+void pax_report_insns(void *pc, void *sp)
+{
+	unsigned long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 5; i++) {
+		unsigned int c;
+		if (get_user(c, (unsigned int *)pc+i))
+			printk(KERN_CONT "???????? ");
+		else
+			printk(KERN_CONT "%08x ", c);
+	}
+	printk("\n");
+}
+#endif
+
 asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)
 {
 	struct mm_struct *mm = current->mm;
@@ -303,8 +667,10 @@ asmlinkage void __kprobes do_sparc64_fau
 		goto intr_or_no_mm;
 
 	if (test_thread_flag(TIF_32BIT)) {
-		if (!(regs->tstate & TSTATE_PRIV))
+		if (!(regs->tstate & TSTATE_PRIV)) {
 			regs->tpc &= 0xffffffff;
+			regs->tnpc &= 0xffffffff;
+		}
 		address &= 0xffffffff;
 	}
 
@@ -321,6 +687,29 @@ asmlinkage void __kprobes do_sparc64_fau
 	if (!vma)
 		goto bad_area;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	/* PaX: detect ITLB misses on non-exec pages */
+	if ((mm->pax_flags & MF_PAX_PAGEEXEC) && vma->vm_start <= address &&
+	    !(vma->vm_flags & VM_EXEC) && (fault_code & FAULT_CODE_ITLB))
+	{
+		if (address != regs->tpc)
+			goto good_area;
+
+		up_read(&mm->mmap_sem);
+		switch (pax_handle_fetch_fault(regs)) {
+
+#ifdef CONFIG_PAX_EMUPLT
+		case 2:
+		case 3:
+			return;
+#endif
+
+		}
+		pax_report_fault(regs, (void *)regs->tpc, (void *)(regs->u_regs[UREG_FP] + STACK_BIAS));
+		do_group_exit(SIGKILL);
+	}
+#endif
+
 	/* Pure DTLB misses do not tell us whether the fault causing
 	 * load/store/atomic was a write or not, it only says that there
 	 * was no match.  So in such a case we (carefully) read the
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/um/sys-i386/syscalls.c linux-2.6.26.8-pax/arch/um/sys-i386/syscalls.c
--- linux-2.6.26.8/arch/um/sys-i386/syscalls.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/um/sys-i386/syscalls.c	2008-09-20 16:46:21.000000000 +0200
@@ -10,6 +10,21 @@
 #include "asm/uaccess.h"
 #include "asm/unistd.h"
 
+int i386_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)
+{
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size || addr > pax_task_size - len)
+		return -EINVAL;
+
+	return 0;
+}
+
 /*
  * Perform the select(nd, in, out, ex, tv) and mmap() system
  * calls. Linux/i386 didn't use to be able to handle more than
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/v850/kernel/module.c linux-2.6.26.8-pax/arch/v850/kernel/module.c
--- linux-2.6.26.8/arch/v850/kernel/module.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/v850/kernel/module.c	2008-07-14 03:52:23.000000000 +0200
@@ -150,8 +150,8 @@ static uint32_t do_plt_call (void *locat
 	tramp[1] = ((val >> 16) & 0xffff) + 0x610000; /* ...; jmp r1 */
 
 	/* Init, or core PLT? */
-	if (location >= mod->module_core
-	    && location < mod->module_core + mod->core_size)
+	if (location >= mod->module_core_rx
+	    && location < mod->module_core_rx + mod->core_size_rx)
 		entry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;
 	else
 		entry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/Kconfig linux-2.6.26.8-pax/arch/x86/Kconfig
--- linux-2.6.26.8/arch/x86/Kconfig	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/Kconfig	2008-07-14 03:52:23.000000000 +0200
@@ -887,7 +887,7 @@ config PAGE_OFFSET
 	hex
 	default 0xB0000000 if VMSPLIT_3G_OPT
 	default 0x80000000 if VMSPLIT_2G
-	default 0x78000000 if VMSPLIT_2G_OPT
+	default 0x70000000 if VMSPLIT_2G_OPT
 	default 0x40000000 if VMSPLIT_1G
 	default 0xC0000000
 	depends on X86_32
@@ -1206,8 +1206,7 @@ config CRASH_DUMP
 config PHYSICAL_START
 	hex "Physical address where the kernel is loaded" if (EMBEDDED || CRASH_DUMP)
 	default "0x1000000" if X86_NUMAQ
-	default "0x200000" if X86_64
-	default "0x100000"
+	default "0x200000"
 	help
 	  This gives the physical address where the kernel is loaded.
 
@@ -1299,7 +1298,7 @@ config HOTPLUG_CPU
 	  suspend.
 
 config COMPAT_VDSO
-	def_bool y
+	def_bool n
 	prompt "Compat VDSO support"
 	depends on X86_32 || IA32_EMULATION
 	help
@@ -1488,7 +1487,7 @@ config PCI
 choice
 	prompt "PCI access mode"
 	depends on X86_32 && PCI && !X86_VISWS
-	default PCI_GOANY
+	default PCI_GODIRECT
 	---help---
 	  On PCI systems, the BIOS can be used to detect the PCI devices and
 	  determine their configuration. However, some old PCI motherboards
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/Kconfig.cpu linux-2.6.26.8-pax/arch/x86/Kconfig.cpu
--- linux-2.6.26.8/arch/x86/Kconfig.cpu	2008-08-03 19:20:46.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/Kconfig.cpu	2008-08-03 19:21:00.000000000 +0200
@@ -340,7 +340,7 @@ config X86_PPRO_FENCE
 
 config X86_F00F_BUG
 	def_bool y
-	depends on M586MMX || M586TSC || M586 || M486 || M386
+	depends on (M586MMX || M586TSC || M586 || M486 || M386) && !PAX_KERNEXEC
 
 config X86_WP_WORKS_OK
 	def_bool y
@@ -360,7 +360,7 @@ config X86_POPAD_OK
 
 config X86_ALIGNMENT_16
 	def_bool y
-	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK6 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
+	depends on MWINCHIP3D || MWINCHIP2 || MWINCHIPC6 || MCYRIXIII || X86_ELAN || MK8 || MK7 || MK6 || MCORE2 || MPENTIUM4 || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || M586 || M486 || MVIAC3_2 || MGEODEGX1
 
 config X86_GOOD_APIC
 	def_bool y
@@ -403,7 +403,7 @@ config X86_TSC
 # generates cmov.
 config X86_CMOV
 	def_bool y
-	depends on (MK7 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || X86_64)
+	depends on (MK8 || MK7 || MCORE2 || MPSC || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || X86_64)
 
 config X86_MINIMUM_CPU_FAMILY
 	int
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/Kconfig.debug linux-2.6.26.8-pax/arch/x86/Kconfig.debug
--- linux-2.6.26.8/arch/x86/Kconfig.debug	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/Kconfig.debug	2008-07-14 03:52:23.000000000 +0200
@@ -84,7 +84,7 @@ config X86_PTDUMP
 config DEBUG_RODATA
 	bool "Write protect kernel read-only data structures"
 	default y
-	depends on DEBUG_KERNEL
+	depends on DEBUG_KERNEL && BROKEN
 	help
 	  Mark the kernel read-only data as write-protected in the pagetables,
 	  in order to catch accidental (and incorrect) writes to such const
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/Makefile linux-2.6.26.8-pax/arch/x86/Makefile
--- linux-2.6.26.8/arch/x86/Makefile	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/Makefile	2008-09-12 03:13:46.000000000 +0200
@@ -258,3 +258,12 @@ endef
 CLEAN_FILES += arch/x86/boot/fdimage \
 	       arch/x86/boot/image.iso \
 	       arch/x86/boot/mtools.conf
+
+define OLD_LD
+
+*** ${VERSION}.${PATCHLEVEL} PaX kernels no longer build correctly with old versions of binutils.
+*** Please upgrade your binutils to 2.18 or newer
+endef
+
+archprepare:
+	$(if $(LDFLAGS_BUILD_ID),,$(error $(OLD_LD)))
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/bitops.h linux-2.6.26.8-pax/arch/x86/boot/bitops.h
--- linux-2.6.26.8/arch/x86/boot/bitops.h	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/bitops.h	2008-07-14 03:52:23.000000000 +0200
@@ -26,7 +26,7 @@ static inline int variable_test_bit(int 
 	u8 v;
 	const u32 *p = (const u32 *)addr;
 
-	asm("btl %2,%1; setc %0" : "=qm" (v) : "m" (*p), "Ir" (nr));
+	asm volatile("btl %2,%1; setc %0" : "=qm" (v) : "m" (*p), "Ir" (nr));
 	return v;
 }
 
@@ -37,7 +37,7 @@ static inline int variable_test_bit(int 
 
 static inline void set_bit(int nr, void *addr)
 {
-	asm("btsl %1,%0" : "+m" (*(u32 *)addr) : "Ir" (nr));
+	asm volatile("btsl %1,%0" : "+m" (*(u32 *)addr) : "Ir" (nr));
 }
 
 #endif /* BOOT_BITOPS_H */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/boot.h linux-2.6.26.8-pax/arch/x86/boot/boot.h
--- linux-2.6.26.8/arch/x86/boot/boot.h	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/boot.h	2008-08-21 22:47:20.000000000 +0200
@@ -78,7 +78,7 @@ static inline void io_delay(void)
 static inline u16 ds(void)
 {
 	u16 seg;
-	asm("movw %%ds,%0" : "=rm" (seg));
+	asm volatile("movw %%ds,%0" : "=rm" (seg));
 	return seg;
 }
 
@@ -174,7 +174,7 @@ static inline void wrgs32(u32 v, addr_t 
 static inline int memcmp(const void *s1, const void *s2, size_t len)
 {
 	u8 diff;
-	asm("repe; cmpsb; setnz %0"
+	asm volatile("repe; cmpsb; setnz %0"
 	    : "=qm" (diff), "+D" (s1), "+S" (s2), "+c" (len));
 	return diff;
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/compressed/head_32.S linux-2.6.26.8-pax/arch/x86/boot/compressed/head_32.S
--- linux-2.6.26.8/arch/x86/boot/compressed/head_32.S	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/compressed/head_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -70,7 +70,7 @@ startup_32:
 	addl    $(CONFIG_PHYSICAL_ALIGN - 1), %ebx
 	andl    $(~(CONFIG_PHYSICAL_ALIGN - 1)), %ebx
 #else
-	movl $LOAD_PHYSICAL_ADDR, %ebx
+	movl $____LOAD_PHYSICAL_ADDR, %ebx
 #endif
 
 	/* Replace the compressed data size with the uncompressed size */
@@ -105,7 +105,7 @@ startup_32:
 	addl    $(CONFIG_PHYSICAL_ALIGN - 1), %ebp
 	andl    $(~(CONFIG_PHYSICAL_ALIGN - 1)), %ebp
 #else
-	movl	$LOAD_PHYSICAL_ADDR, %ebp
+	movl	$____LOAD_PHYSICAL_ADDR, %ebp
 #endif
 
 /*
@@ -159,16 +159,15 @@ relocated:
  * and where it was actually loaded.
  */
 	movl %ebp, %ebx
-	subl $LOAD_PHYSICAL_ADDR, %ebx
+	subl $____LOAD_PHYSICAL_ADDR, %ebx
 	jz   2f		/* Nothing to be done if loaded at compiled addr. */
 /*
  * Process relocations.
  */
 
 1:	subl $4, %edi
-	movl 0(%edi), %ecx
-	testl %ecx, %ecx
-	jz 2f
+	movl (%edi), %ecx
+	jecxz 2f
 	addl %ebx, -__PAGE_OFFSET(%ebx, %ecx)
 	jmp 1b
 2:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/compressed/misc.c linux-2.6.26.8-pax/arch/x86/boot/compressed/misc.c
--- linux-2.6.26.8/arch/x86/boot/compressed/misc.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/compressed/misc.c	2008-07-14 03:52:23.000000000 +0200
@@ -410,7 +410,7 @@ static void parse_elf(void *output)
 		case PT_LOAD:
 #ifdef CONFIG_RELOCATABLE
 			dest = output;
-			dest += (phdr->p_paddr - LOAD_PHYSICAL_ADDR);
+			dest += (phdr->p_paddr - ____LOAD_PHYSICAL_ADDR);
 #else
 			dest = (void *)(phdr->p_paddr);
 #endif
@@ -459,7 +459,7 @@ asmlinkage void decompress_kernel(void *
 	if (heap > ((-__PAGE_OFFSET-(512<<20)-1) & 0x7fffffff))
 		error("Destination address too large");
 #ifndef CONFIG_RELOCATABLE
-	if ((u32)output != LOAD_PHYSICAL_ADDR)
+	if ((u32)output != ____LOAD_PHYSICAL_ADDR)
 		error("Wrong destination address");
 #endif
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/compressed/relocs.c linux-2.6.26.8-pax/arch/x86/boot/compressed/relocs.c
--- linux-2.6.26.8/arch/x86/boot/compressed/relocs.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/compressed/relocs.c	2008-07-14 03:52:23.000000000 +0200
@@ -10,9 +10,13 @@
 #define USE_BSD
 #include <endian.h>
 
+#include "../../../../include/linux/autoconf.h"
+
+#define MAX_PHDRS 100
 #define MAX_SHDRS 100
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 static Elf32_Ehdr ehdr;
+static Elf32_Phdr phdr[MAX_PHDRS];
 static Elf32_Shdr shdr[MAX_SHDRS];
 static Elf32_Sym  *symtab[MAX_SHDRS];
 static Elf32_Rel  *reltab[MAX_SHDRS];
@@ -241,6 +245,34 @@ static void read_ehdr(FILE *fp)
 	}
 }
 
+static void read_phdrs(FILE *fp)
+{
+	int i;
+	if (ehdr.e_phnum > MAX_PHDRS) {
+		die("%d program headers supported: %d\n",
+			ehdr.e_phnum, MAX_PHDRS);
+	}
+	if (fseek(fp, ehdr.e_phoff, SEEK_SET) < 0) {
+		die("Seek to %d failed: %s\n",
+			ehdr.e_phoff, strerror(errno));
+	}
+	if (fread(&phdr, sizeof(phdr[0]), ehdr.e_phnum, fp) != ehdr.e_phnum) {
+		die("Cannot read ELF program headers: %s\n",
+			strerror(errno));
+	}
+	for(i = 0; i < ehdr.e_phnum; i++) {
+		phdr[i].p_type      = elf32_to_cpu(phdr[i].p_type);
+		phdr[i].p_offset    = elf32_to_cpu(phdr[i].p_offset);
+		phdr[i].p_vaddr     = elf32_to_cpu(phdr[i].p_vaddr);
+		phdr[i].p_paddr     = elf32_to_cpu(phdr[i].p_paddr);
+		phdr[i].p_filesz    = elf32_to_cpu(phdr[i].p_filesz);
+		phdr[i].p_memsz     = elf32_to_cpu(phdr[i].p_memsz);
+		phdr[i].p_flags     = elf32_to_cpu(phdr[i].p_flags);
+		phdr[i].p_align     = elf32_to_cpu(phdr[i].p_align);
+	}
+
+}
+
 static void read_shdrs(FILE *fp)
 {
 	int i;
@@ -327,6 +359,8 @@ static void read_symtabs(FILE *fp)
 static void read_relocs(FILE *fp)
 {
 	int i,j;
+	uint32_t base;
+
 	for(i = 0; i < ehdr.e_shnum; i++) {
 		if (shdr[i].sh_type != SHT_REL) {
 			continue;
@@ -344,8 +378,17 @@ static void read_relocs(FILE *fp)
 			die("Cannot read symbol table: %s\n",
 				strerror(errno));
 		}
+		base = 0;
+		for (j = 0; j < ehdr.e_phnum; j++) {
+			if (phdr[j].p_type != PT_LOAD )
+				continue;
+			if (shdr[shdr[i].sh_info].sh_offset < phdr[j].p_offset || shdr[shdr[i].sh_info].sh_offset > phdr[j].p_offset + phdr[j].p_filesz)
+				continue;
+			base = CONFIG_PAGE_OFFSET + phdr[j].p_paddr - phdr[j].p_vaddr;
+			break;
+		}
 		for(j = 0; j < shdr[i].sh_size/sizeof(reltab[0][0]); j++) {
-			reltab[i][j].r_offset = elf32_to_cpu(reltab[i][j].r_offset);
+			reltab[i][j].r_offset = elf32_to_cpu(reltab[i][j].r_offset) + base;
 			reltab[i][j].r_info   = elf32_to_cpu(reltab[i][j].r_info);
 		}
 	}
@@ -482,6 +525,23 @@ static void walk_relocs(void (*visit)(El
 			if (sym->st_shndx == SHN_ABS) {
 				continue;
 			}
+			/* Don't relocate actual per-cpu variables, they are absolute indices, not addresses */
+			if (!strcmp(sec_name(sym->st_shndx), ".data.percpu") && strncmp(sym_name(sym_strtab, sym), "__per_cpu_", 10))
+				continue;
+#if defined(CONFIG_PAX_KERNEXEC) && defined(CONFIG_X86_32)
+			/* Don't relocate actual code, they are relocated implicitly by the base address of KERNEL_CS */
+			if (!strcmp(sec_name(sym->st_shndx), ".init.text"))
+				continue;
+			if (!strcmp(sec_name(sym->st_shndx), ".exit.text"))
+				continue;
+			if (!strcmp(sec_name(sym->st_shndx), ".text.head")) {
+				if (strcmp(sym_name(sym_strtab, sym), "__init_end") &&
+				    strcmp(sym_name(sym_strtab, sym), "KERNEL_TEXT_OFFSET"))
+					continue;
+			}
+			if (!strcmp(sec_name(sym->st_shndx), ".text"))
+				continue;
+#endif
 			if (r_type == R_386_PC32) {
 				/* PC relative relocations don't need to be adjusted */
 			}
@@ -609,6 +669,7 @@ int main(int argc, char **argv)
 			fname, strerror(errno));
 	}
 	read_ehdr(fp);
+	read_phdrs(fp);
 	read_shdrs(fp);
 	read_strtabs(fp);
 	read_symtabs(fp);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/cpucheck.c linux-2.6.26.8-pax/arch/x86/boot/cpucheck.c
--- linux-2.6.26.8/arch/x86/boot/cpucheck.c	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/cpucheck.c	2008-08-21 22:47:20.000000000 +0200
@@ -76,7 +76,7 @@ static int has_fpu(void)
 	u16 fcw = -1, fsw = -1;
 	u32 cr0;
 
-	asm("movl %%cr0,%0" : "=r" (cr0));
+	asm volatile("movl %%cr0,%0" : "=r" (cr0));
 	if (cr0 & (X86_CR0_EM|X86_CR0_TS)) {
 		cr0 &= ~(X86_CR0_EM|X86_CR0_TS);
 		asm volatile("movl %0,%%cr0" : : "r" (cr0));
@@ -92,7 +92,7 @@ static int has_eflag(u32 mask)
 {
 	u32 f0, f1;
 
-	asm("pushfl ; "
+	asm volatile("pushfl ; "
 	    "pushfl ; "
 	    "popl %0 ; "
 	    "movl %0,%1 ; "
@@ -117,7 +117,7 @@ static void get_flags(void)
 		set_bit(X86_FEATURE_FPU, cpu.flags);
 
 	if (has_eflag(X86_EFLAGS_ID)) {
-		asm("cpuid"
+		asm volatile("cpuid"
 		    : "=a" (max_intel_level),
 		      "=b" (cpu_vendor[0]),
 		      "=d" (cpu_vendor[1]),
@@ -126,7 +126,7 @@ static void get_flags(void)
 
 		if (max_intel_level >= 0x00000001 &&
 		    max_intel_level <= 0x0000ffff) {
-			asm("cpuid"
+			asm volatile("cpuid"
 			    : "=a" (tfms),
 			      "=c" (cpu.flags[4]),
 			      "=d" (cpu.flags[0])
@@ -138,7 +138,7 @@ static void get_flags(void)
 				cpu.model += ((tfms >> 16) & 0xf) << 4;
 		}
 
-		asm("cpuid"
+		asm volatile("cpuid"
 		    : "=a" (max_amd_level)
 		    : "a" (0x80000000)
 		    : "ebx", "ecx", "edx");
@@ -146,7 +146,7 @@ static void get_flags(void)
 		if (max_amd_level >= 0x80000001 &&
 		    max_amd_level <= 0x8000ffff) {
 			u32 eax = 0x80000001;
-			asm("cpuid"
+			asm volatile("cpuid"
 			    : "+a" (eax),
 			      "=c" (cpu.flags[6]),
 			      "=d" (cpu.flags[1])
@@ -205,9 +205,9 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 ecx = MSR_K7_HWCR;
 		u32 eax, edx;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
 		eax &= ~(1 << 15);
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		get_flags();	/* Make sure it really did something */
 		err = check_flags();
@@ -220,9 +220,9 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 ecx = MSR_VIA_FCR;
 		u32 eax, edx;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
 		eax |= (1<<1)|(1<<7);
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		set_bit(X86_FEATURE_CX8, cpu.flags);
 		err = check_flags();
@@ -233,12 +233,12 @@ int check_cpu(int *cpu_level_ptr, int *r
 		u32 eax, edx;
 		u32 level = 1;
 
-		asm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
-		asm("wrmsr" : : "a" (~0), "d" (edx), "c" (ecx));
-		asm("cpuid"
+		asm volatile("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));
+		asm volatile("wrmsr" : : "a" (~0), "d" (edx), "c" (ecx));
+		asm volatile("cpuid"
 		    : "+a" (level), "=d" (cpu.flags[0])
 		    : : "ecx", "ebx");
-		asm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
+		asm volatile("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));
 
 		err = check_flags();
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/edd.c linux-2.6.26.8-pax/arch/x86/boot/edd.c
--- linux-2.6.26.8/arch/x86/boot/edd.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/edd.c	2008-07-14 03:52:23.000000000 +0200
@@ -76,7 +76,7 @@ static int get_edd_info(u8 devno, struct
 	ax = 0x4100;
 	bx = EDDMAGIC1;
 	dx = devno;
-	asm("pushfl; stc; int $0x13; setc %%al; popfl"
+	asm volatile("pushfl; stc; int $0x13; setc %%al; popfl"
 	    : "+a" (ax), "+b" (bx), "=c" (cx), "+d" (dx)
 	    : : "esi", "edi");
 
@@ -95,7 +95,7 @@ static int get_edd_info(u8 devno, struct
 	ei->params.length = sizeof(ei->params);
 	ax = 0x4800;
 	dx = devno;
-	asm("pushfl; int $0x13; popfl"
+	asm volatile("pushfl; int $0x13; popfl"
 	    : "+a" (ax), "+d" (dx), "=m" (ei->params)
 	    : "S" (&ei->params)
 	    : "ebx", "ecx", "edi");
@@ -106,7 +106,7 @@ static int get_edd_info(u8 devno, struct
 	ax = 0x0800;
 	dx = devno;
 	di = 0;
-	asm("pushw %%es; "
+	asm volatile("pushw %%es; "
 	    "movw %%di,%%es; "
 	    "pushfl; stc; int $0x13; setc %%al; popfl; "
 	    "popw %%es"
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/main.c linux-2.6.26.8-pax/arch/x86/boot/main.c
--- linux-2.6.26.8/arch/x86/boot/main.c	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/main.c	2008-08-21 22:47:51.000000000 +0200
@@ -77,7 +77,7 @@ static void query_ist(void)
 	if (cpu.level < 6)
 		return;
 
-	asm("int $0x15"
+	asm volatile("int $0x15"
 	    : "=a" (boot_params.ist_info.signature),
 	      "=b" (boot_params.ist_info.command),
 	      "=c" (boot_params.ist_info.event),
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/mca.c linux-2.6.26.8-pax/arch/x86/boot/mca.c
--- linux-2.6.26.8/arch/x86/boot/mca.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/mca.c	2008-07-14 03:52:23.000000000 +0200
@@ -19,7 +19,7 @@ int query_mca(void)
 	u8 err;
 	u16 es, bx, len;
 
-	asm("pushw %%es ; "
+	asm volatile("pushw %%es ; "
 	    "int $0x15 ; "
 	    "setc %0 ; "
 	    "movw %%es, %1 ; "
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/memory.c linux-2.6.26.8-pax/arch/x86/boot/memory.c
--- linux-2.6.26.8/arch/x86/boot/memory.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/memory.c	2008-07-14 03:52:23.000000000 +0200
@@ -30,7 +30,7 @@ static int detect_memory_e820(void)
 		/* Important: %edx is clobbered by some BIOSes,
 		   so it must be either used for the error output
 		   or explicitly marked clobbered. */
-		asm("int $0x15; setc %0"
+		asm volatile("int $0x15; setc %0"
 		    : "=d" (err), "+b" (next), "=a" (id), "+c" (size),
 		      "=m" (*desc)
 		    : "D" (desc), "d" (SMAP), "a" (0xe820));
@@ -65,7 +65,7 @@ static int detect_memory_e801(void)
 
 	bx = cx = dx = 0;
 	ax = 0xe801;
-	asm("stc; int $0x15; setc %0"
+	asm volatile("stc; int $0x15; setc %0"
 	    : "=m" (err), "+a" (ax), "+b" (bx), "+c" (cx), "+d" (dx));
 
 	if (err)
@@ -95,7 +95,7 @@ static int detect_memory_88(void)
 	u8 err;
 
 	ax = 0x8800;
-	asm("stc; int $0x15; setc %0" : "=bcdm" (err), "+a" (ax));
+	asm volatile("stc; int $0x15; setc %0" : "=bcdm" (err), "+a" (ax));
 
 	boot_params.screen_info.ext_mem_k = ax;
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/video-vesa.c linux-2.6.26.8-pax/arch/x86/boot/video-vesa.c
--- linux-2.6.26.8/arch/x86/boot/video-vesa.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/video-vesa.c	2008-07-14 03:52:23.000000000 +0200
@@ -41,7 +41,7 @@ static int vesa_probe(void)
 
 	ax = 0x4f00;
 	di = (size_t)&vginfo;
-	asm(INT10
+	asm volatile(INT10
 	    : "+a" (ax), "+D" (di), "=m" (vginfo)
 	    : : "ebx", "ecx", "edx", "esi");
 
@@ -68,7 +68,7 @@ static int vesa_probe(void)
 		ax = 0x4f01;
 		cx = mode;
 		di = (size_t)&vminfo;
-		asm(INT10
+		asm volatile(INT10
 		    : "+a" (ax), "+c" (cx), "+D" (di), "=m" (vminfo)
 		    : : "ebx", "edx", "esi");
 
@@ -123,7 +123,7 @@ static int vesa_set_mode(struct mode_inf
 	ax = 0x4f01;
 	cx = vesa_mode;
 	di = (size_t)&vminfo;
-	asm(INT10
+	asm volatile(INT10
 	    : "+a" (ax), "+c" (cx), "+D" (di), "=m" (vminfo)
 	    : : "ebx", "edx", "esi");
 
@@ -203,19 +203,20 @@ static void vesa_dac_set_8bits(void)
 /* Save the VESA protected mode info */
 static void vesa_store_pm_info(void)
 {
-	u16 ax, bx, di, es;
+	u16 ax, bx, cx, di, es;
 
 	ax = 0x4f0a;
-	bx = di = 0;
-	asm("pushw %%es; "INT10"; movw %%es,%0; popw %%es"
-	    : "=d" (es), "+a" (ax), "+b" (bx), "+D" (di)
-	    : : "ecx", "esi");
+	bx = cx = di = 0;
+	asm volatile("pushw %%es; "INT10"; movw %%es,%0; popw %%es"
+	    : "=d" (es), "+a" (ax), "+b" (bx), "+c" (cx), "+D" (di)
+	    : : "esi");
 
 	if (ax != 0x004f)
 		return;
 
 	boot_params.screen_info.vesapm_seg = es;
 	boot_params.screen_info.vesapm_off = di;
+	boot_params.screen_info.vesapm_size = cx;
 }
 
 /*
@@ -269,7 +270,7 @@ void vesa_store_edid(void)
 	/* Note: The VBE DDC spec is different from the main VESA spec;
 	   we genuinely have to assume all registers are destroyed here. */
 
-	asm("pushw %%es; movw %2,%%es; "INT10"; popw %%es"
+	asm volatile("pushw %%es; movw %2,%%es; "INT10"; popw %%es"
 	    : "+a" (ax), "+b" (bx)
 	    :  "c" (cx), "D" (di)
 	    : "esi");
@@ -285,7 +286,7 @@ void vesa_store_edid(void)
 	cx = 0;			/* Controller 0 */
 	dx = 0;			/* EDID block number */
 	di =(size_t) &boot_params.edid_info; /* (ES:)Pointer to block */
-	asm(INT10
+	asm volatile(INT10
 	    : "+a" (ax), "+b" (bx), "+d" (dx), "=m" (boot_params.edid_info)
 	    : "c" (cx), "D" (di)
 	    : "esi");
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/video-vga.c linux-2.6.26.8-pax/arch/x86/boot/video-vga.c
--- linux-2.6.26.8/arch/x86/boot/video-vga.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/video-vga.c	2008-07-14 03:52:23.000000000 +0200
@@ -225,7 +225,7 @@ static int vga_probe(void)
 	};
 	u8 vga_flag;
 
-	asm(INT10
+	asm volatile(INT10
 	    : "=b" (ega_bx)
 	    : "a" (0x1200), "b" (0x10) /* Check EGA/VGA */
 	    : "ecx", "edx", "esi", "edi");
@@ -237,7 +237,7 @@ static int vga_probe(void)
 	/* If we have MDA/CGA/HGC then BL will be unchanged at 0x10 */
 	if ((u8)ega_bx != 0x10) {
 		/* EGA/VGA */
-		asm(INT10
+		asm volatile(INT10
 		    : "=a" (vga_flag)
 		    : "a" (0x1a00)
 		    : "ebx", "ecx", "edx", "esi", "edi");
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/video.c linux-2.6.26.8-pax/arch/x86/boot/video.c
--- linux-2.6.26.8/arch/x86/boot/video.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/video.c	2008-07-14 03:52:23.000000000 +0200
@@ -23,7 +23,7 @@ static void store_cursor_position(void)
 
 	ax = 0x0300;
 	bx = 0;
-	asm(INT10
+	asm volatile(INT10
 	    : "=d" (curpos), "+a" (ax), "+b" (bx)
 	    : : "ecx", "esi", "edi");
 
@@ -38,7 +38,7 @@ static void store_video_mode(void)
 	/* N.B.: the saving of the video page here is a bit silly,
 	   since we pretty much assume page 0 everywhere. */
 	ax = 0x0f00;
-	asm(INT10
+	asm volatile(INT10
 	    : "+a" (ax), "=b" (page)
 	    : : "ecx", "edx", "esi", "edi");
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/boot/voyager.c linux-2.6.26.8-pax/arch/x86/boot/voyager.c
--- linux-2.6.26.8/arch/x86/boot/voyager.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/boot/voyager.c	2008-07-14 03:52:23.000000000 +0200
@@ -23,7 +23,7 @@ int query_voyager(void)
 
 	data_ptr[0] = 0xff;	/* Flag on config not found(?) */
 
-	asm("pushw %%es ; "
+	asm volatile("pushw %%es ; "
 	    "int $0x15 ; "
 	    "setc %0 ; "
 	    "movw %%es, %1 ; "
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/ia32/ia32_signal.c linux-2.6.26.8-pax/arch/x86/ia32/ia32_signal.c
--- linux-2.6.26.8/arch/x86/ia32/ia32_signal.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/ia32/ia32_signal.c	2008-07-14 03:52:23.000000000 +0200
@@ -531,6 +531,7 @@ int ia32_setup_rt_frame(int sig, struct 
 		__NR_ia32_rt_sigreturn,
 		0x80cd,
 		0,
+		0
 	};
 
 	frame = get_sigframe(ka, regs, sizeof(*frame));
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/acpi/boot.c linux-2.6.26.8-pax/arch/x86/kernel/acpi/boot.c
--- linux-2.6.26.8/arch/x86/kernel/acpi/boot.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/acpi/boot.c	2008-07-14 03:52:23.000000000 +0200
@@ -1227,7 +1227,7 @@ static struct dmi_system_id __initdata a
 		     DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		     },
 	 },
-	{}
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 #endif				/* __i386__ */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/acpi/realmode/wakeup.S linux-2.6.26.8-pax/arch/x86/kernel/acpi/realmode/wakeup.S
--- linux-2.6.26.8/arch/x86/kernel/acpi/realmode/wakeup.S	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/acpi/realmode/wakeup.S	2008-07-14 03:52:23.000000000 +0200
@@ -104,7 +104,7 @@ _start:
 	movl	%eax, %ecx
 	orl	%edx, %ecx
 	jz	1f
-	movl	$0xc0000080, %ecx
+	mov	$MSR_EFER, %ecx
 	wrmsr
 1:
 
Files linux-2.6.26.8/arch/x86/kernel/acpi/realmode/wakeup.elf and linux-2.6.26.8-pax/arch/x86/kernel/acpi/realmode/wakeup.elf differ
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/acpi/wakeup_32.S linux-2.6.26.8-pax/arch/x86/kernel/acpi/wakeup_32.S
--- linux-2.6.26.8/arch/x86/kernel/acpi/wakeup_32.S	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/acpi/wakeup_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -30,13 +30,11 @@ wakeup_pmode_return:
 	# and restore the stack ... but you need gdt for this to work
 	movl	saved_context_esp, %esp
 
-	movl	%cs:saved_magic, %eax
-	cmpl	$0x12345678, %eax
+	cmpl	$0x12345678, saved_magic
 	jne	bogus_magic
 
 	# jump to place where we left off
-	movl	saved_eip, %eax
-	jmp	*%eax
+	jmp	*(saved_eip)
 
 bogus_magic:
 	jmp	bogus_magic
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/alternative.c linux-2.6.26.8-pax/arch/x86/kernel/alternative.c
--- linux-2.6.26.8/arch/x86/kernel/alternative.c	2008-10-23 11:01:01.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/alternative.c	2008-10-23 11:01:17.000000000 +0200
@@ -403,7 +403,7 @@ void apply_paravirt(struct paravirt_patc
 
 		BUG_ON(p->len > MAX_PATCH_LEN);
 		/* prep the buffer with the original instructions */
-		memcpy(insnbuf, p->instr, p->len);
+		memcpy(insnbuf, ktla_ktva(p->instr), p->len);
 		used = pv_init_ops.patch(p->instrtype, p->clobbers, insnbuf,
 					 (unsigned long)p->instr, p->len);
 
@@ -483,11 +483,26 @@ void __init alternative_instructions(voi
  * instructions. And on the local CPU you need to be protected again NMI or MCE
  * handlers seeing an inconsistent instruction while you patch.
  */
-void *text_poke_early(void *addr, const void *opcode, size_t len)
+void *__kprobes text_poke_early(void *addr, const void *opcode, size_t len)
 {
 	unsigned long flags;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	local_irq_save(flags);
-	memcpy(addr, opcode, len);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	memcpy(ktla_ktva(addr), opcode, len);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	local_irq_restore(flags);
 	sync_core();
 	/* Could also do a CLFLUSH here to speed up CPU recovery; but
@@ -508,33 +523,27 @@ void *text_poke_early(void *addr, const 
  */
 void *__kprobes text_poke(void *addr, const void *opcode, size_t len)
 {
-	unsigned long flags;
-	char *vaddr;
-	int nr_pages = 2;
+	unsigned char *vaddr = ktla_ktva(addr);
 	struct page *pages[2];
-	int i;
+	size_t i;
+
+	if (!core_kernel_text((unsigned long)addr)
 
-	if (!core_kernel_text((unsigned long)addr)) {
-		pages[0] = vmalloc_to_page(addr);
-		pages[1] = vmalloc_to_page(addr + PAGE_SIZE);
+#if defined(CONFIG_X86_32) && defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	    && (vaddr < MODULES_VADDR || MODULES_END < vaddr)
+#endif
+
+	   ) {
+		pages[0] = vmalloc_to_page(vaddr);
+		pages[1] = vmalloc_to_page(vaddr + PAGE_SIZE);
 	} else {
-		pages[0] = virt_to_page(addr);
+		pages[0] = virt_to_page(vaddr);
 		WARN_ON(!PageReserved(pages[0]));
-		pages[1] = virt_to_page(addr + PAGE_SIZE);
+		pages[1] = virt_to_page(vaddr + PAGE_SIZE);
 	}
 	BUG_ON(!pages[0]);
-	if (!pages[1])
-		nr_pages = 1;
-	vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);
-	BUG_ON(!vaddr);
-	local_irq_save(flags);
-	memcpy(&vaddr[(unsigned long)addr & ~PAGE_MASK], opcode, len);
-	local_irq_restore(flags);
-	vunmap(vaddr);
-	sync_core();
-	/* Could also do a CLFLUSH here to speed up CPU recovery; but
-	   that causes hangs on some VIA CPUs. */
+	text_poke_early(addr, opcode, len);
 	for (i = 0; i < len; i++)
-		BUG_ON(((char *)addr)[i] != ((char *)opcode)[i]);
+		BUG_ON((vaddr)[i] != ((unsigned char *)opcode)[i]);
 	return addr;
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/apm_32.c linux-2.6.26.8-pax/arch/x86/kernel/apm_32.c
--- linux-2.6.26.8/arch/x86/kernel/apm_32.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/apm_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -406,7 +406,7 @@ static DECLARE_WAIT_QUEUE_HEAD(apm_waitq
 static DECLARE_WAIT_QUEUE_HEAD(apm_suspend_waitqueue);
 static struct apm_user *user_list;
 static DEFINE_SPINLOCK(user_list_lock);
-static const struct desc_struct	bad_bios_desc = { { { 0, 0x00409200 } } };
+static const struct desc_struct	bad_bios_desc = { { { 0, 0x00409300 } } };
 
 static const char driver_version[] = "1.16ac";	/* no spaces */
 
@@ -601,19 +601,42 @@ static u8 apm_bios_call(u32 func, u32 eb
 	struct desc_struct	save_desc_40;
 	struct desc_struct	*gdt;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr0;
+#endif
+
 	cpus = apm_save_cpus();
 
 	cpu = get_cpu();
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt[0x40 / 8] = bad_bios_desc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	apm_irq_save(flags);
 	APM_DO_SAVE_SEGS;
 	apm_bios_call_asm(func, ebx_in, ecx_in, eax, ebx, ecx, edx, esi);
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 
@@ -644,19 +667,42 @@ static u8 apm_bios_call_simple(u32 func,
 	struct desc_struct	save_desc_40;
 	struct desc_struct	*gdt;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long		cr0;
+#endif
+
 	cpus = apm_save_cpus();
 
 	cpu = get_cpu();
 	gdt = get_cpu_gdt_table(cpu);
 	save_desc_40 = gdt[0x40 / 8];
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt[0x40 / 8] = bad_bios_desc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	apm_irq_save(flags);
 	APM_DO_SAVE_SEGS;
 	error = apm_bios_call_simple_asm(func, ebx_in, ecx_in, eax);
 	APM_DO_RESTORE_SEGS;
 	apm_irq_restore(flags);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	gdt[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	put_cpu();
 	apm_restore_cpus(cpus);
 	return error;
@@ -928,7 +974,7 @@ recalc:
 
 static void apm_power_off(void)
 {
-	unsigned char po_bios_call[] = {
+	const unsigned char po_bios_call[] = {
 		0xb8, 0x00, 0x10,	/* movw  $0x1000,ax  */
 		0x8e, 0xd0,		/* movw  ax,ss       */
 		0xbc, 0x00, 0xf0,	/* movw  $0xf000,sp  */
@@ -1868,7 +1914,10 @@ static const struct file_operations apm_
 static struct miscdevice apm_device = {
 	APM_MINOR_DEV,
 	"apm_bios",
-	&apm_bios_fops
+	&apm_bios_fops,
+	{NULL, NULL},
+	NULL,
+	NULL
 };
 
 
@@ -2189,7 +2238,7 @@ static struct dmi_system_id __initdata a
 		{	DMI_MATCH(DMI_SYS_VENDOR, "IBM"), },
 	},
 
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 /*
@@ -2207,6 +2256,10 @@ static int __init apm_init(void)
 	struct desc_struct *gdt;
 	int err;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	dmi_check_system(apm_dmi_table);
 
 	if (apm_info.bios.version == 0 || paravirt_enabled()) {
@@ -2280,9 +2333,18 @@ static int __init apm_init(void)
 	 * This is for buggy BIOS's that refer to (real mode) segment 0x40
 	 * even though they are called in protected mode.
 	 */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	set_base(bad_bios_desc, __va((unsigned long)0x40 << 4));
 	_set_limit((char *)&bad_bios_desc, 4095 - (0x40 << 4));
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/*
 	 * Set up the long jump entry point to the APM BIOS, which is called
 	 * from inline assembly.
@@ -2301,6 +2363,11 @@ static int __init apm_init(void)
 	 * code to that CPU.
 	 */
 	gdt = get_cpu_gdt_table(0);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	set_base(gdt[APM_CS >> 3],
 		 __va((unsigned long)apm_info.bios.cseg << 4));
 	set_base(gdt[APM_CS_16 >> 3],
@@ -2308,6 +2375,10 @@ static int __init apm_init(void)
 	set_base(gdt[APM_DS >> 3],
 		 __va((unsigned long)apm_info.bios.dseg << 4));
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	proc_create("apm", 0, NULL, &apm_file_ops);
 
 	kapmd_task = kthread_create(apm, NULL, "kapmd");
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/asm-offsets_32.c linux-2.6.26.8-pax/arch/x86/kernel/asm-offsets_32.c
--- linux-2.6.26.8/arch/x86/kernel/asm-offsets_32.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/asm-offsets_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -100,6 +100,7 @@ void foo(void)
 	DEFINE(PTRS_PER_PTE, PTRS_PER_PTE);
 	DEFINE(PTRS_PER_PMD, PTRS_PER_PMD);
 	DEFINE(PTRS_PER_PGD, PTRS_PER_PGD);
+	DEFINE(PERCPU_MODULE_RESERVE, PERCPU_MODULE_RESERVE);
 
 	OFFSET(crypto_tfm_ctx_offset, crypto_tfm, __crt_ctx);
 
@@ -113,6 +114,7 @@ void foo(void)
 	OFFSET(PV_CPU_iret, pv_cpu_ops, iret);
 	OFFSET(PV_CPU_irq_enable_syscall_ret, pv_cpu_ops, irq_enable_syscall_ret);
 	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);
+	OFFSET(PV_CPU_write_cr0, pv_cpu_ops, write_cr0);
 #endif
 
 #ifdef CONFIG_XEN
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/asm-offsets_64.c linux-2.6.26.8-pax/arch/x86/kernel/asm-offsets_64.c
--- linux-2.6.26.8/arch/x86/kernel/asm-offsets_64.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/asm-offsets_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -117,6 +117,7 @@ int main(void)
 	ENTRY(cr8);
 	BLANK();
 #undef ENTRY
+	DEFINE(TSS_size, sizeof(struct tss_struct));
 	DEFINE(TSS_ist, offsetof(struct tss_struct, x86_tss.ist));
 	BLANK();
 	DEFINE(crypto_tfm_ctx_offset, offsetof(struct crypto_tfm, __crt_ctx));
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/common.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/common.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/common.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/common.c	2008-07-14 03:52:23.000000000 +0200
@@ -4,7 +4,6 @@
 #include <linux/smp.h>
 #include <linux/module.h>
 #include <linux/percpu.h>
-#include <linux/bootmem.h>
 #include <asm/processor.h>
 #include <asm/i387.h>
 #include <asm/msr.h>
@@ -21,42 +20,6 @@
 
 #include "cpu.h"
 
-DEFINE_PER_CPU(struct gdt_page, gdt_page) = { .gdt = {
-	[GDT_ENTRY_KERNEL_CS] = { { { 0x0000ffff, 0x00cf9a00 } } },
-	[GDT_ENTRY_KERNEL_DS] = { { { 0x0000ffff, 0x00cf9200 } } },
-	[GDT_ENTRY_DEFAULT_USER_CS] = { { { 0x0000ffff, 0x00cffa00 } } },
-	[GDT_ENTRY_DEFAULT_USER_DS] = { { { 0x0000ffff, 0x00cff200 } } },
-	/*
-	 * Segments used for calling PnP BIOS have byte granularity.
-	 * They code segments and data segments have fixed 64k limits,
-	 * the transfer segment sizes are set at run time.
-	 */
-	/* 32-bit code */
-	[GDT_ENTRY_PNPBIOS_CS32] = { { { 0x0000ffff, 0x00409a00 } } },
-	/* 16-bit code */
-	[GDT_ENTRY_PNPBIOS_CS16] = { { { 0x0000ffff, 0x00009a00 } } },
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_DS] = { { { 0x0000ffff, 0x00009200 } } },
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_TS1] = { { { 0x00000000, 0x00009200 } } },
-	/* 16-bit data */
-	[GDT_ENTRY_PNPBIOS_TS2] = { { { 0x00000000, 0x00009200 } } },
-	/*
-	 * The APM segments have byte granularity and their bases
-	 * are set at run time.  All have 64k limits.
-	 */
-	/* 32-bit code */
-	[GDT_ENTRY_APMBIOS_BASE] = { { { 0x0000ffff, 0x00409a00 } } },
-	/* 16-bit code */
-	[GDT_ENTRY_APMBIOS_BASE+1] = { { { 0x0000ffff, 0x00009a00 } } },
-	/* data */
-	[GDT_ENTRY_APMBIOS_BASE+2] = { { { 0x0000ffff, 0x00409200 } } },
-
-	[GDT_ENTRY_ESPFIX_SS] = { { { 0x00000000, 0x00c09200 } } },
-	[GDT_ENTRY_PERCPU] = { { { 0x00000000, 0x00000000 } } },
-} };
-EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
-
 __u32 cleared_cpu_caps[NCAPINTS] __cpuinitdata;
 
 static int cachesize_override __cpuinitdata = -1;
@@ -479,6 +442,10 @@ void __cpuinit identify_cpu(struct cpuin
 	 * we do "generic changes."
 	 */
 
+#if defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_KERNEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF)
+	setup_clear_cpu_cap(X86_FEATURE_SEP);
+#endif
+
 	/* If the model name is still unset, do table lookup. */
 	if (!c->x86_model_id[0]) {
 		char *p;
@@ -615,7 +582,7 @@ static __init int setup_disablecpuid(cha
 }
 __setup("clearcpuid=", setup_disablecpuid);
 
-cpumask_t cpu_initialized __cpuinitdata = CPU_MASK_NONE;
+cpumask_t cpu_initialized = CPU_MASK_NONE;
 
 void __init early_cpu_init(void)
 {
@@ -644,7 +611,7 @@ void switch_to_new_gdt(void)
 {
 	struct desc_ptr gdt_descr;
 
-	gdt_descr.address = (long)get_cpu_gdt_table(smp_processor_id());
+	gdt_descr.address = (unsigned long)get_cpu_gdt_table(smp_processor_id());
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 	asm("mov %0, %%fs" : : "r" (__KERNEL_PERCPU) : "memory");
@@ -660,7 +627,7 @@ void __cpuinit cpu_init(void)
 {
 	int cpu = smp_processor_id();
 	struct task_struct *curr = current;
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
 	struct thread_struct *thread = &curr->thread;
 
 	if (cpu_test_and_set(cpu, cpu_initialized)) {
@@ -715,7 +682,7 @@ void __cpuinit cpu_init(void)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-void __cpuinit cpu_uninit(void)
+void cpu_uninit(void)
 {
 	int cpu = raw_smp_processor_id();
 	cpu_clear(cpu, cpu_initialized);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c	2008-07-14 03:52:23.000000000 +0200
@@ -560,7 +560,7 @@ static const struct dmi_system_id sw_any
 			DMI_MATCH(DMI_PRODUCT_NAME, "X6DLP"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/cpufreq/speedstep-centrino.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/cpufreq/speedstep-centrino.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/cpufreq/speedstep-centrino.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/cpufreq/speedstep-centrino.c	2008-07-14 03:52:23.000000000 +0200
@@ -223,7 +223,7 @@ static struct cpu_model models[] =
 	{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL },
 	{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL },
 
-	{ NULL, }
+	{ NULL, NULL, 0, NULL}
 };
 #undef _BANIAS
 #undef BANIAS
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/intel.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/intel.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/intel.c	2008-07-14 03:51:38.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/intel.c	2008-07-14 03:52:23.000000000 +0200
@@ -107,7 +107,7 @@ static void __cpuinit trap_init_f00f_bug
 	 * Update the IDT descriptor and reload the IDT so that
 	 * it uses the read-only mapped virtual address.
 	 */
-	idt_descr.address = fix_to_virt(FIX_F00F_IDT);
+	idt_descr.address = (struct desc_struct *)fix_to_virt(FIX_F00F_IDT);
 	load_idt(&idt_descr);
 }
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/mcheck/mce_64.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/mcheck/mce_64.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/mcheck/mce_64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/mcheck/mce_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -672,6 +672,7 @@ static struct miscdevice mce_log_device 
 	MISC_MCELOG_MINOR,
 	"mcelog",
 	&mce_chrdev_ops,
+	{NULL, NULL}, NULL, NULL
 };
 
 static unsigned long old_cr4 __initdata;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/cpu/mtrr/generic.c linux-2.6.26.8-pax/arch/x86/kernel/cpu/mtrr/generic.c
--- linux-2.6.26.8/arch/x86/kernel/cpu/mtrr/generic.c	2008-09-08 13:54:29.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/cpu/mtrr/generic.c	2008-10-09 23:53:00.000000000 +0200
@@ -31,11 +31,11 @@ static struct fixed_range_block fixed_ra
 	{ MTRRfix64K_00000_MSR, 1 }, /* one  64k MTRR  */
 	{ MTRRfix16K_80000_MSR, 2 }, /* two  16k MTRRs */
 	{ MTRRfix4K_C0000_MSR,  8 }, /* eight 4k MTRRs */
-	{}
+	{ 0, 0 }
 };
 
 static unsigned long smp_changes_mask;
-static struct mtrr_state mtrr_state = {};
+static struct mtrr_state mtrr_state;
 static int mtrr_state_set;
 static u64 tom2;
 
@@ -213,7 +213,7 @@ void __init get_mtrr_state(void)
 	mtrr_state.enabled = (lo & 0xc00) >> 10;
 
 	if (amd_special_default_mtrr()) {
-		unsigned lo, hi;
+		unsigned hi;
 		/* TOP_MEM2 */
 		rdmsr(MSR_K8_TOP_MEM2, lo, hi);
 		tom2 = hi;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/crash.c linux-2.6.26.8-pax/arch/x86/kernel/crash.c
--- linux-2.6.26.8/arch/x86/kernel/crash.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/crash.c	2008-07-14 03:52:23.000000000 +0200
@@ -59,7 +59,7 @@ static int crash_nmi_callback(struct not
 	local_irq_disable();
 
 #ifdef CONFIG_X86_32
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		crash_fixup_ss_esp(&fixed_regs, regs);
 		regs = &fixed_regs;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/doublefault_32.c linux-2.6.26.8-pax/arch/x86/kernel/doublefault_32.c
--- linux-2.6.26.8/arch/x86/kernel/doublefault_32.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/doublefault_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -11,7 +11,7 @@
 
 #define DOUBLEFAULT_STACKSIZE (1024)
 static unsigned long doublefault_stack[DOUBLEFAULT_STACKSIZE];
-#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE)
+#define STACK_START (unsigned long)(doublefault_stack+DOUBLEFAULT_STACKSIZE-2)
 
 #define ptr_ok(x) ((x) > PAGE_OFFSET && (x) < PAGE_OFFSET + MAXMEM)
 
@@ -21,7 +21,7 @@ static void doublefault_fn(void)
 	unsigned long gdt, tss;
 
 	store_gdt(&gdt_desc);
-	gdt = gdt_desc.address;
+	gdt = (unsigned long)gdt_desc.address;
 
 	printk(KERN_EMERG "PANIC: double fault, gdt at %08lx [%d bytes]\n", gdt, gdt_desc.size);
 
@@ -60,10 +60,10 @@ struct tss_struct doublefault_tss __cach
 		/* 0x2 bit is always set */
 		.flags		= X86_EFLAGS_SF | 0x2,
 		.sp		= STACK_START,
-		.es		= __USER_DS,
+		.es		= __KERNEL_DS,
 		.cs		= __KERNEL_CS,
 		.ss		= __KERNEL_DS,
-		.ds		= __USER_DS,
+		.ds		= __KERNEL_DS,
 		.fs		= __KERNEL_PERCPU,
 
 		.__cr3		= __pa(swapper_pg_dir)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/efi_32.c linux-2.6.26.8-pax/arch/x86/kernel/efi_32.c
--- linux-2.6.26.8/arch/x86/kernel/efi_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/efi_32.c	2008-08-30 03:45:09.000000000 +0200
@@ -38,70 +38,37 @@
  */
 
 static unsigned long efi_rt_eflags;
-static pgd_t efi_bak_pg_dir_pointer[2];
+static pgd_t __initdata efi_bak_pg_dir_pointer[KERNEL_PGD_PTRS] __attribute__ ((aligned (4096)));
 
-void efi_call_phys_prelog(void)
+void __init efi_call_phys_prelog(void)
 {
-	unsigned long cr4;
-	unsigned long temp;
 	struct desc_ptr gdt_descr;
 
 	local_irq_save(efi_rt_eflags);
 
-	/*
-	 * If I don't have PAE, I should just duplicate two entries in page
-	 * directory. If I have PAE, I just need to duplicate one entry in
-	 * page directory.
-	 */
-	cr4 = read_cr4();
-
-	if (cr4 & X86_CR4_PAE) {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		swapper_pg_dir[0].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-	} else {
-		efi_bak_pg_dir_pointer[0].pgd =
-		    swapper_pg_dir[pgd_index(0)].pgd;
-		efi_bak_pg_dir_pointer[1].pgd =
-		    swapper_pg_dir[pgd_index(0x400000)].pgd;
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    swapper_pg_dir[pgd_index(PAGE_OFFSET)].pgd;
-		temp = PAGE_OFFSET + 0x400000;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    swapper_pg_dir[pgd_index(temp)].pgd;
-	}
+	clone_pgd_range(efi_bak_pg_dir_pointer, swapper_pg_dir, KERNEL_PGD_PTRS);
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			min_t(unsigned long, KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 
 	/*
 	 * After the lock is released, the original page table is restored.
 	 */
 	__flush_tlb_all();
 
-	gdt_descr.address = __pa(get_cpu_gdt_table(0));
+	gdt_descr.address = (struct desc_struct *)__pa(get_cpu_gdt_table(0));
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 }
 
-void efi_call_phys_epilog(void)
+void __init efi_call_phys_epilog(void)
 {
-	unsigned long cr4;
 	struct desc_ptr gdt_descr;
 
-	gdt_descr.address = (unsigned long)get_cpu_gdt_table(0);
+	gdt_descr.address = get_cpu_gdt_table(0);
 	gdt_descr.size = GDT_SIZE - 1;
 	load_gdt(&gdt_descr);
 
-	cr4 = read_cr4();
-
-	if (cr4 & X86_CR4_PAE) {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-	} else {
-		swapper_pg_dir[pgd_index(0)].pgd =
-		    efi_bak_pg_dir_pointer[0].pgd;
-		swapper_pg_dir[pgd_index(0x400000)].pgd =
-		    efi_bak_pg_dir_pointer[1].pgd;
-	}
+	clone_pgd_range(swapper_pg_dir, efi_bak_pg_dir_pointer, KERNEL_PGD_PTRS);
 
 	/*
 	 * After the lock is released, the original page table is restored.
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/efi_stub_32.S linux-2.6.26.8-pax/arch/x86/kernel/efi_stub_32.S
--- linux-2.6.26.8/arch/x86/kernel/efi_stub_32.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/efi_stub_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -6,6 +6,7 @@
  */
 
 #include <linux/linkage.h>
+#include <linux/init.h>
 #include <asm/page.h>
 
 /*
@@ -20,7 +21,7 @@
  * service functions will comply with gcc calling convention, too.
  */
 
-.text
+__INIT
 ENTRY(efi_call_phys)
 	/*
 	 * 0. The function can only be called in Linux kernel. So CS has been
@@ -36,9 +37,7 @@ ENTRY(efi_call_phys)
 	 * The mapping of lower virtual memory has been created in prelog and
 	 * epilog.
 	 */
-	movl	$1f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	jmp	*%edx
+	jmp	1f-__PAGE_OFFSET
 1:
 
 	/*
@@ -47,14 +46,8 @@ ENTRY(efi_call_phys)
 	 * parameter 2, ..., param n. To make things easy, we save the return
 	 * address of efi_call_phys in a global variable.
 	 */
-	popl	%edx
-	movl	%edx, saved_return_addr
-	/* get the function pointer into ECX*/
-	popl	%ecx
-	movl	%ecx, efi_rt_function_ptr
-	movl	$2f, %edx
-	subl	$__PAGE_OFFSET, %edx
-	pushl	%edx
+	popl	(saved_return_addr)
+	popl	(efi_rt_function_ptr)
 
 	/*
 	 * 3. Clear PG bit in %CR0.
@@ -73,9 +66,8 @@ ENTRY(efi_call_phys)
 	/*
 	 * 5. Call the physical function.
 	 */
-	jmp	*%ecx
+	call	*(efi_rt_function_ptr-__PAGE_OFFSET)
 
-2:
 	/*
 	 * 6. After EFI runtime service returns, control will return to
 	 * following instruction. We'd better readjust stack pointer first.
@@ -88,34 +80,27 @@ ENTRY(efi_call_phys)
 	movl	%cr0, %edx
 	orl	$0x80000000, %edx
 	movl	%edx, %cr0
-	jmp	1f
-1:
+
 	/*
 	 * 8. Now restore the virtual mode from flat mode by
 	 * adding EIP with PAGE_OFFSET.
 	 */
-	movl	$1f, %edx
-	jmp	*%edx
+	jmp	1f+__PAGE_OFFSET
 1:
 
 	/*
 	 * 9. Balance the stack. And because EAX contain the return value,
 	 * we'd better not clobber it.
 	 */
-	leal	efi_rt_function_ptr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
+	pushl	(efi_rt_function_ptr)
 
 	/*
-	 * 10. Push the saved return address onto the stack and return.
+	 * 10. Return to the saved return address.
 	 */
-	leal	saved_return_addr, %edx
-	movl	(%edx), %ecx
-	pushl	%ecx
-	ret
+	jmpl	*(saved_return_addr)
 .previous
 
-.data
+__INITDATA
 saved_return_addr:
 	.long 0
 efi_rt_function_ptr:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/entry_32.S linux-2.6.26.8-pax/arch/x86/kernel/entry_32.S
--- linux-2.6.26.8/arch/x86/kernel/entry_32.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/entry_32.S	2008-09-09 10:26:49.000000000 +0200
@@ -90,7 +90,7 @@
 #define resume_userspace_sig	resume_userspace
 #endif
 
-#define SAVE_ALL \
+#define __SAVE_ALL(_DS) \
 	cld; \
 	pushl %fs; \
 	CFI_ADJUST_CFA_OFFSET 4;\
@@ -122,12 +122,26 @@
 	pushl %ebx; \
 	CFI_ADJUST_CFA_OFFSET 4;\
 	CFI_REL_OFFSET ebx, 0;\
-	movl $(__USER_DS), %edx; \
+	movl $(_DS), %edx; \
 	movl %edx, %ds; \
 	movl %edx, %es; \
 	movl $(__KERNEL_PERCPU), %edx; \
 	movl %edx, %fs
 
+#ifdef CONFIG_PAX_KERNEXEC
+#define SAVE_ALL \
+	__SAVE_ALL(__KERNEL_DS); \
+	GET_CR0_INTO_EDX; \
+	movl %edx, %esi; \
+	orl $X86_CR0_WP, %edx; \
+	xorl %edx, %esi; \
+	SET_CR0_FROM_EDX
+#elif defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC) || defined(CONFIG_PAX_MEMORY_UDEREF)
+#define SAVE_ALL __SAVE_ALL(__KERNEL_DS)
+#else
+#define SAVE_ALL __SAVE_ALL(__USER_DS)
+#endif
+
 #define RESTORE_INT_REGS \
 	popl %ebx;	\
 	CFI_ADJUST_CFA_OFFSET -4;\
@@ -218,6 +232,11 @@ ENTRY(ret_from_fork)
 	CFI_ADJUST_CFA_OFFSET 4
 	popfl
 	CFI_ADJUST_CFA_OFFSET -4
+
+#ifdef CONFIG_PAX_KERNEXEC
+	xorl %esi, %esi
+#endif
+
 	jmp syscall_exit
 	CFI_ENDPROC
 END(ret_from_fork)
@@ -241,7 +260,17 @@ check_userspace:
 	movb PT_CS(%esp), %al
 	andl $(X86_EFLAGS_VM | SEGMENT_RPL_MASK), %eax
 	cmpl $USER_RPL, %eax
+
+#ifdef CONFIG_PAX_KERNEXEC
+	jae resume_userspace
+	
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+	jmp resume_kernel
+#else
 	jb resume_kernel		# not returning to v8086 or userspace
+#endif
 
 ENTRY(resume_userspace)
 	LOCKDEP_SYS_EXIT
@@ -303,10 +332,9 @@ sysenter_past_esp:
 	/*CFI_REL_OFFSET cs, 0*/
 	/*
 	 * Push current_thread_info()->sysenter_return to the stack.
-	 * A tiny bit of offset fixup is necessary - 4*4 means the 4 words
-	 * pushed above; +8 corresponds to copy_thread's esp0 setting.
 	 */
-	pushl (TI_sysenter_return-THREAD_SIZE+8+4*4)(%esp)
+	GET_THREAD_INFO(%ebp)
+	pushl TI_sysenter_return(%ebp)
 	CFI_ADJUST_CFA_OFFSET 4
 	CFI_REL_OFFSET eip, 0
 
@@ -319,9 +347,17 @@ sysenter_past_esp:
  * Load the potential sixth argument from user stack.
  * Careful about security.
  */
+	movl PT_OLDESP(%esp),%ebp
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	mov PT_OLDSS(%esp),%ds
+1:	movl %ds:(%ebp),%ebp
+#else
 	cmpl $__PAGE_OFFSET-3,%ebp
 	jae syscall_fault
 1:	movl (%ebp),%ebp
+#endif
+
 	movl %ebp,PT_EBP(%esp)
 .section __ex_table,"a"
 	.align 4
@@ -343,20 +379,37 @@ sysenter_past_esp:
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
 	jne syscall_exit_work
+
+#ifdef CONFIG_PAX_RANDKSTACK
+	pushl %eax
+	CFI_ADJUST_CFA_OFFSET 4
+	call pax_randomize_kstack
+	popl %eax
+	CFI_ADJUST_CFA_OFFSET -4
+#endif
+
 /* if something modifies registers it must also disable sysexit */
 	movl PT_EIP(%esp), %edx
 	movl PT_OLDESP(%esp), %ecx
 	xorl %ebp,%ebp
 	TRACE_IRQS_ON
 1:	mov  PT_FS(%esp), %fs
+2:	mov  PT_DS(%esp), %ds
+3:	mov  PT_ES(%esp), %es
 	ENABLE_INTERRUPTS_SYSCALL_RET
 	CFI_ENDPROC
 .pushsection .fixup,"ax"
-2:	movl $0,PT_FS(%esp)
+4:	movl $0,PT_FS(%esp)
+	jmp 1b
+5:	movl $0,PT_DS(%esp)
+	jmp 1b
+6:	movl $0,PT_ES(%esp)
 	jmp 1b
 .section __ex_table,"a"
 	.align 4
-	.long 1b,2b
+	.long 1b,4b
+	.long 2b,5b
+	.long 3b,6b
 .popsection
 ENDPROC(ia32_sysenter_target)
 
@@ -390,6 +443,10 @@ no_singlestep:
 	testw $_TIF_ALLWORK_MASK, %cx	# current->work
 	jne syscall_exit_work
 
+#ifdef CONFIG_PAX_RANDKSTACK
+	call pax_randomize_kstack
+#endif
+
 restore_all:
 	movl PT_EFLAGS(%esp), %eax	# mix EFLAGS, SS and CS
 	# Warning: PT_OLDSS(%esp) contains the wrong/random values if we
@@ -483,25 +540,19 @@ work_resched:
 
 work_notifysig:				# deal with pending signals and
 					# notify-resume requests
+	movl %esp, %eax
 #ifdef CONFIG_VM86
 	testl $X86_EFLAGS_VM, PT_EFLAGS(%esp)
-	movl %esp, %eax
-	jne work_notifysig_v86		# returning to kernel-space or
+	jz 1f				# returning to kernel-space or
 					# vm86-space
-	xorl %edx, %edx
-	call do_notify_resume
-	jmp resume_userspace_sig
 
-	ALIGN
-work_notifysig_v86:
 	pushl %ecx			# save ti_flags for do_notify_resume
 	CFI_ADJUST_CFA_OFFSET 4
 	call save_v86_state		# %eax contains pt_regs pointer
 	popl %ecx
 	CFI_ADJUST_CFA_OFFSET -4
 	movl %eax, %esp
-#else
-	movl %esp, %eax
+1:
 #endif
 	xorl %edx, %edx
 	call do_notify_resume
@@ -552,17 +603,24 @@ syscall_badsys:
 END(syscall_badsys)
 	CFI_ENDPROC
 
-#define FIXUP_ESPFIX_STACK \
-	/* since we are on a wrong stack, we cant make it a C code :( */ \
-	PER_CPU(gdt_page, %ebx); \
-	GET_DESC_BASE(GDT_ENTRY_ESPFIX_SS, %ebx, %eax, %ax, %al, %ah); \
-	addl %esp, %eax; \
-	pushl $__KERNEL_DS; \
-	CFI_ADJUST_CFA_OFFSET 4; \
-	pushl %eax; \
-	CFI_ADJUST_CFA_OFFSET 4; \
-	lss (%esp), %esp; \
+.macro FIXUP_ESPFIX_STACK
+	/* since we are on a wrong stack, we cant make it a C code :( */
+#ifdef CONFIG_SMP
+	movl PER_CPU_VAR(cpu_number), %ebx;
+	shll $PAGE_SHIFT_asm, %ebx;
+	addl $cpu_gdt_table, %ebx;
+#else
+	movl $cpu_gdt_table, %ebx;
+#endif
+	GET_DESC_BASE(GDT_ENTRY_ESPFIX_SS, %ebx, %eax, %ax, %al, %ah);
+	addl %esp, %eax;
+	pushl $__KERNEL_DS;
+	CFI_ADJUST_CFA_OFFSET 4;
+	pushl %eax;
+	CFI_ADJUST_CFA_OFFSET 4;
+	lss (%esp), %esp;
 	CFI_ADJUST_CFA_OFFSET -8;
+.endm
 #define UNWIND_ESPFIX_STACK \
 	movl %ss, %eax; \
 	/* see if on espfix stack */ \
@@ -579,7 +637,7 @@ END(syscall_badsys)
  * Build the entry stubs and pointer table with
  * some assembler magic.
  */
-.section .rodata,"a"
+.section .rodata,"a",@progbits
 ENTRY(interrupt)
 .text
 
@@ -679,12 +737,21 @@ error_code:
 	popl %ecx
 	CFI_ADJUST_CFA_OFFSET -4
 	/*CFI_REGISTER es, ecx*/
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	movl %edx, %esi
+	orl $X86_CR0_WP, %edx
+	xorl %edx, %esi
+	SET_CR0_FROM_EDX
+#endif
+
 	movl PT_FS(%esp), %edi		# get the function address
 	movl PT_ORIG_EAX(%esp), %edx	# get the error code
 	movl $-1, PT_ORIG_EAX(%esp)	# no syscall to restart
 	mov  %ecx, PT_FS(%esp)
 	/*CFI_REL_OFFSET fs, ES*/
-	movl $(__USER_DS), %ecx
+	movl $(__KERNEL_DS), %ecx
 	movl %ecx, %ds
 	movl %ecx, %es
 	movl %esp,%eax			# pt_regs pointer
@@ -818,6 +885,13 @@ nmi_stack_correct:
 	xorl %edx,%edx		# zero error code
 	movl %esp,%eax		# pt_regs pointer
 	call do_nmi
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+#endif
+
 	jmp restore_nocheck_notrace
 	CFI_ENDPROC
 
@@ -858,6 +932,13 @@ nmi_espfix_stack:
 	FIXUP_ESPFIX_STACK		# %eax == %esp
 	xorl %edx,%edx			# zero error code
 	call do_nmi
+
+#ifdef CONFIG_PAX_KERNEXEC
+	GET_CR0_INTO_EDX
+	xorl %esi, %edx
+	SET_CR0_FROM_EDX
+#endif
+
 	RESTORE_REGS
 	lss 12+4(%esp), %esp		# back to espfix stack
 	CFI_ADJUST_CFA_OFFSET -24
@@ -1110,7 +1191,6 @@ ENDPROC(xen_failsafe_callback)
 
 #endif	/* CONFIG_XEN */
 
-.section .rodata,"a"
 #include "syscall_table_32.S"
 
 syscall_table_size=(.-sys_call_table)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/entry_64.S linux-2.6.26.8-pax/arch/x86/kernel/entry_64.S
--- linux-2.6.26.8/arch/x86/kernel/entry_64.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/entry_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -767,17 +767,18 @@ END(spurious_interrupt)
 	xorl  %ebx,%ebx
 1:
 	.if \ist
-	movq	%gs:pda_data_offset, %rbp
+	imul	$TSS_size, %gs:pda_cpunumber, %ebp
+	lea	init_tss(%rbp), %rbp
 	.endif
 	movq %rsp,%rdi
 	movq ORIG_RAX(%rsp),%rsi
 	movq $-1,ORIG_RAX(%rsp)
 	.if \ist
-	subq	$EXCEPTION_STKSZ, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	subq	$EXCEPTION_STKSZ, TSS_ist + (\ist - 1) * 8(%rbp)
 	.endif
 	call \sym
 	.if \ist
-	addq	$EXCEPTION_STKSZ, per_cpu__init_tss + TSS_ist + (\ist - 1) * 8(%rbp)
+	addq	$EXCEPTION_STKSZ, TSS_ist + (\ist - 1) * 8(%rbp)
 	.endif
 	DISABLE_INTERRUPTS(CLBR_NONE)
 	.if \irqtrace
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/head64.c linux-2.6.26.8-pax/arch/x86/kernel/head64.c
--- linux-2.6.26.8/arch/x86/kernel/head64.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/head64.c	2008-10-09 04:13:06.000000000 +0200
@@ -143,6 +143,11 @@ void __init x86_64_start_kernel(char * r
 	/* Make NULL pointers segfault */
 	zap_identity_mappings();
 
+	for (i = 0; i < NR_CPUS; i++)
+		cpu_pda(i) = &boot_cpu_pda[i];
+
+	pda_init(0);
+
 	/* Cleanup the over mapped high alias */
 	cleanup_highmap();
 
@@ -157,10 +162,6 @@ void __init x86_64_start_kernel(char * r
 
 	early_printk("Kernel alive\n");
 
- 	for (i = 0; i < NR_CPUS; i++)
- 		cpu_pda(i) = &boot_cpu_pda[i];
-
-	pda_init(0);
 	copy_bootdata(__va(real_mode_data));
 
 	reserve_early(__pa_symbol(&_text), __pa_symbol(&_end), "TEXT DATA BSS");
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/head_32.S linux-2.6.26.8-pax/arch/x86/kernel/head_32.S
--- linux-2.6.26.8/arch/x86/kernel/head_32.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/head_32.S	2008-10-05 00:37:36.000000000 +0200
@@ -19,6 +19,7 @@
 #include <asm/asm-offsets.h>
 #include <asm/setup.h>
 #include <asm/processor-flags.h>
+#include <asm/msr-index.h>
 
 /* Physical address */
 #define pa(X) ((X) - __PAGE_OFFSET)
@@ -64,17 +65,22 @@ LOW_PAGES = 1<<(32-PAGE_SHIFT_asm)
 LOW_PAGES = LOW_PAGES + 0x1000000
 #endif
 
-#if PTRS_PER_PMD > 1
-PAGE_TABLE_SIZE = (LOW_PAGES / PTRS_PER_PMD) + PTRS_PER_PGD
-#else
-PAGE_TABLE_SIZE = (LOW_PAGES / PTRS_PER_PGD)
-#endif
+PAGE_TABLE_SIZE = (LOW_PAGES / PTRS_PER_PTE)
 BOOTBITMAP_SIZE = LOW_PAGES / 8
 ALLOCATOR_SLOP = 4
 
 INIT_MAP_BEYOND_END = BOOTBITMAP_SIZE + (PAGE_TABLE_SIZE + ALLOCATOR_SLOP)*PAGE_SIZE_asm
 
 /*
+ * Real beginning of normal "text" segment
+ */
+ENTRY(stext)
+ENTRY(_stext)
+
+.section .text.startup,"ax",@progbits
+	ljmp $(__BOOT_CS),$phys_startup_32
+
+/*
  * 32-bit kernel entrypoint; only used by the boot CPU.  On entry,
  * %esi points to the real-mode code as a 32-bit pointer.
  * CS and DS must be 4 GB flat segments, but we don't depend on
@@ -82,6 +88,12 @@ INIT_MAP_BEYOND_END = BOOTBITMAP_SIZE + 
  * can.
  */
 .section .text.head,"ax",@progbits
+
+#ifdef CONFIG_PAX_KERNEXEC
+/* PaX: fill first page in .text with int3 to catch NULL derefs in kernel mode */
+.fill 4096,1,0xcc
+#endif
+
 ENTRY(startup_32)
 	/* test KEEP_SEGMENTS flag to see if the bootloader is asking
 		us to not reload segments */
@@ -99,6 +111,56 @@ ENTRY(startup_32)
 	movl %eax,%gs
 2:
 
+	movl $pa(cpu_gdt_table),%edi
+	movl $__per_cpu_start,%eax
+	movw %ax,__KERNEL_PERCPU + 2(%edi)
+	rorl $16,%eax
+	movb %al,__KERNEL_PERCPU + 4(%edi)
+	movb %ah,__KERNEL_PERCPU + 7(%edi)
+	movl $__per_cpu_end + PERCPU_MODULE_RESERVE - 1,%eax
+	subl $__per_cpu_start,%eax
+	movw %ax,__KERNEL_PERCPU + 0(%edi)
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	/* check for VMware */
+	movl $0x564d5868,%eax
+	xorl %ebx,%ebx
+	movl $0xa,%ecx
+	movl $0x5658,%edx
+	in (%dx),%eax
+	cmpl $0x564d5868,%ebx
+	jz 2f
+
+	movl $NR_CPUS,%ecx
+	movl $pa(cpu_gdt_table),%edi
+1:
+	movl $((((__PAGE_OFFSET-1) & 0xf0000000) >> 12) | 0x00c09700),GDT_ENTRY_KERNEL_DS * 8 + 4(%edi)
+	addl $PAGE_SIZE_asm,%edi
+	loop 1b
+2:
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	movl $pa(boot_gdt),%edi
+	movl $KERNEL_TEXT_OFFSET,%eax
+	movw %ax,__BOOT_CS + 2(%edi)
+	rorl $16,%eax
+	movb %al,__BOOT_CS + 4(%edi)
+	movb %ah,__BOOT_CS + 7(%edi)
+	rorl $16,%eax
+
+	movl $NR_CPUS,%ecx
+	movl $pa(cpu_gdt_table),%edi
+1:
+	movw %ax,__KERNEL_CS + 2(%edi)
+	rorl $16,%eax
+	movb %al,__KERNEL_CS + 4(%edi)
+	movb %ah,__KERNEL_CS + 7(%edi)
+	rorl $16,%eax
+	addl $PAGE_SIZE_asm,%edi
+	loop 1b
+#endif
+
 /*
  * Clear BSS first so that there are no surprises...
  */
@@ -142,9 +204,7 @@ ENTRY(startup_32)
 	cmpl $num_subarch_entries, %eax
 	jae bad_subarch
 
-	movl pa(subarch_entries)(,%eax,4), %eax
-	subl $__PAGE_OFFSET, %eax
-	jmp *%eax
+	jmp *pa(subarch_entries)(,%eax,4)
 
 bad_subarch:
 WEAK(lguest_entry)
@@ -156,9 +216,9 @@ WEAK(xen_entry)
 	__INITDATA
 
 subarch_entries:
-	.long default_entry		/* normal x86/PC */
-	.long lguest_entry		/* lguest hypervisor */
-	.long xen_entry			/* Xen hypervisor */
+	.long pa(default_entry)		/* normal x86/PC */
+	.long pa(lguest_entry)		/* lguest hypervisor */
+	.long pa(xen_entry)		/* Xen hypervisor */
 num_subarch_entries = (. - subarch_entries) / 4
 .previous
 #endif /* CONFIG_PARAVIRT */
@@ -172,7 +232,7 @@ num_subarch_entries = (. - subarch_entri
  *
  * Note that the stack is not yet set up!
  */
-#define PTE_ATTR	0x007		/* PRESENT+RW+USER */
+#define PTE_ATTR	0x067		/* PRESENT+RW+USER+DIRTY+ACCESSED */
 #define PDE_ATTR	0x067		/* PRESENT+RW+USER+DIRTY+ACCESSED */
 #define PGD_ATTR	0x001		/* PRESENT (no other attributes) */
 
@@ -221,8 +281,7 @@ default_entry:
 	movl %edi,pa(init_pg_tables_end)
 
 	/* Do early initialization of the fixmap area */
-	movl $pa(swapper_pg_fixmap)+PDE_ATTR,%eax
-	movl %eax,pa(swapper_pg_pmd+0x1000*KPMDS-8)
+	movl $pa(swapper_pg_fixmap)+PDE_ATTR,pa(swapper_pg_pmd+0x1000*KPMDS-8)
 #else	/* Not PAE */
 
 page_pde_offset = (__PAGE_OFFSET >> 20);
@@ -251,8 +310,7 @@ page_pde_offset = (__PAGE_OFFSET >> 20);
 	movl %edi,pa(init_pg_tables_end)
 
 	/* Do early initialization of the fixmap area */
-	movl $pa(swapper_pg_fixmap)+PDE_ATTR,%eax
-	movl %eax,pa(swapper_pg_dir+0xffc)
+	movl $pa(swapper_pg_fixmap)+PDE_ATTR,pa(swapper_pg_dir+0xffc)
 #endif
 	jmp 3f
 /*
@@ -316,13 +374,16 @@ ENTRY(startup_32_smp)
 	jnc 6f
 
 	/* Setup EFER (Extended Feature Enable Register) */
-	movl $0xc0000080, %ecx
+	movl $MSR_EFER, %ecx
 	rdmsr
 
 	btsl $11, %eax
 	/* Make changes effective */
 	wrmsr
 
+	btsl $63-32,pa(__supported_pte_mask+4)
+	movl $1,pa(nx_enabled)
+
 6:
 
 /*
@@ -348,9 +409,7 @@ ENTRY(startup_32_smp)
 
 #ifdef CONFIG_SMP
 	cmpb $0, ready
-	jz  1f				/* Initial CPU cleans BSS */
-	jmp checkCPUtype
-1:
+	jnz checkCPUtype		/* Initial CPU cleans BSS */
 #endif /* CONFIG_SMP */
 
 /*
@@ -427,12 +486,12 @@ is386:	movl $2,%ecx		# set MP
 	ljmp $(__KERNEL_CS),$1f
 1:	movl $(__KERNEL_DS),%eax	# reload all the segment registers
 	movl %eax,%ss			# after changing gdt.
-	movl %eax,%fs			# gets reset once there's real percpu
-
-	movl $(__USER_DS),%eax		# DS/ES contains default USER segment
 	movl %eax,%ds
 	movl %eax,%es
 
+	movl $(__KERNEL_PERCPU), %eax
+	movl %eax,%fs			# set this cpu's percpu
+
 	xorl %eax,%eax			# Clear GS and LDT
 	movl %eax,%gs
 	lldt %ax
@@ -443,11 +502,7 @@ is386:	movl $2,%ecx		# set MP
 	movb ready, %cl
 	movb $1, ready
 	cmpb $0,%cl		# the first CPU calls start_kernel
-	je   1f
-	movl $(__KERNEL_PERCPU), %eax
-	movl %eax,%fs		# set this cpu's percpu
-	jmp initialize_secondary # all other CPUs call initialize_secondary
-1:
+	jne initialize_secondary # all other CPUs call initialize_secondary
 #endif /* CONFIG_SMP */
 	jmp i386_start_kernel
 
@@ -533,15 +588,15 @@ early_page_fault:
 	jmp early_fault
 
 early_fault:
-	cld
 #ifdef CONFIG_PRINTK
+	cmpl $2,%ss:early_recursion_flag
+	je hlt_loop
+	incl %ss:early_recursion_flag
+	cld
 	pusha
 	movl $(__KERNEL_DS),%eax
 	movl %eax,%ds
 	movl %eax,%es
-	cmpl $2,early_recursion_flag
-	je hlt_loop
-	incl early_recursion_flag
 	movl %cr2,%eax
 	pushl %eax
 	pushl %edx		/* trapno */
@@ -551,8 +606,8 @@ early_fault:
 #else
 	call printk
 #endif
-#endif
 	call dump_stack
+#endif
 hlt_loop:
 	hlt
 	jmp hlt_loop
@@ -560,8 +615,11 @@ hlt_loop:
 /* This is the default interrupt "handler" :-) */
 	ALIGN
 ignore_int:
-	cld
 #ifdef CONFIG_PRINTK
+	cmpl $2,%ss:early_recursion_flag
+	je hlt_loop
+	incl %ss:early_recursion_flag
+	cld
 	pushl %eax
 	pushl %ecx
 	pushl %edx
@@ -570,9 +628,6 @@ ignore_int:
 	movl $(__KERNEL_DS),%eax
 	movl %eax,%ds
 	movl %eax,%es
-	cmpl $2,early_recursion_flag
-	je hlt_loop
-	incl early_recursion_flag
 	pushl 16(%esp)
 	pushl 24(%esp)
 	pushl 32(%esp)
@@ -592,36 +647,41 @@ ignore_int:
 #endif
 	iret
 
-.section .text
-/*
- * Real beginning of normal "text" segment
- */
-ENTRY(stext)
-ENTRY(_stext)
-
 /*
  * BSS section
  */
-.section ".bss.page_aligned","wa"
-	.align PAGE_SIZE_asm
 #ifdef CONFIG_X86_PAE
+.section .swapper_pg_pmd,"a",@progbits
 swapper_pg_pmd:
 	.fill 1024*KPMDS,4,0
 #else
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
 	.fill 1024,4,0
 #endif
 swapper_pg_fixmap:
 	.fill 1024,4,0
+
+.section .empty_zero_page,"a",@progbits
 ENTRY(empty_zero_page)
 	.fill 4096,1,0
+
+/*
+ * The IDT has to be page-aligned to simplify the Pentium
+ * F0 0F bug workaround.. We have a special link segment
+ * for this.
+ */
+.section .idt,"a",@progbits
+ENTRY(idt_table)
+	.fill 256,8,0
+
 /*
  * This starts the data section.
  */
+.data
+
 #ifdef CONFIG_X86_PAE
-.section ".data.page_aligned","wa"
-	/* Page-aligned for the benefit of paravirt? */
-	.align PAGE_SIZE_asm
+.section .swapper_pg_dir,"a",@progbits
 ENTRY(swapper_pg_dir)
 	.long	pa(swapper_pg_pmd+PGD_ATTR),0		/* low identity map */
 # if KPMDS == 3
@@ -644,11 +704,12 @@ ENTRY(swapper_pg_dir)
 
 .data
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-8
 	.long __BOOT_DS
 
 ready:	.byte 0
 
+.section .rodata,"a",@progbits
 early_recursion_flag:
 	.long 0
 
@@ -684,7 +745,7 @@ fault_msg:
 	.word 0				# 32 bit align gdt_desc.address
 boot_gdt_descr:
 	.word __BOOT_DS+7
-	.long boot_gdt - __PAGE_OFFSET
+	.long pa(boot_gdt)
 
 	.word 0				# 32-bit align idt_desc.address
 idt_descr:
@@ -695,7 +756,7 @@ idt_descr:
 	.word 0				# 32 bit align gdt_desc.address
 ENTRY(early_gdt_descr)
 	.word GDT_ENTRIES*8-1
-	.long per_cpu__gdt_page		/* Overwritten for secondary CPUs */
+	.long cpu_gdt_table		/* Overwritten for secondary CPUs */
 
 /*
  * The boot_gdt must mirror the equivalent in setup.S and is
@@ -704,5 +765,59 @@ ENTRY(early_gdt_descr)
 	.align L1_CACHE_BYTES
 ENTRY(boot_gdt)
 	.fill GDT_ENTRY_BOOT_CS,8,0
-	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */
-	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */
+	.quad 0x00cf9b000000ffff	/* kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* kernel 4GB data at 0x00000000 */
+
+	.align PAGE_SIZE_asm
+ENTRY(cpu_gdt_table)
+	.rept NR_CPUS
+	.quad 0x0000000000000000	/* NULL descriptor */
+	.quad 0x0000000000000000	/* 0x0b reserved */
+	.quad 0x0000000000000000	/* 0x13 reserved */
+	.quad 0x0000000000000000	/* 0x1b reserved */
+	.quad 0x0000000000000000	/* 0x20 unused */
+	.quad 0x0000000000000000	/* 0x28 unused */
+	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */
+	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */
+	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */
+	.quad 0x0000000000000000	/* 0x4b reserved */
+	.quad 0x0000000000000000	/* 0x53 reserved */
+	.quad 0x0000000000000000	/* 0x5b reserved */
+
+	.quad 0x00cf9b000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */
+	.quad 0x00cf93000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */
+	.quad 0x00cffb000000ffff	/* 0x73 user 4GB code at 0x00000000 */
+	.quad 0x00cff3000000ffff	/* 0x7b user 4GB data at 0x00000000 */
+
+	.quad 0x0000000000000000	/* 0x80 TSS descriptor */
+	.quad 0x0000000000000000	/* 0x88 LDT descriptor */
+
+	/*
+	 * Segments used for calling PnP BIOS have byte granularity.
+	 * The code segments and data segments have fixed 64k limits,
+	 * the transfer segment sizes are set at run time.
+	 */
+	.quad 0x00409b000000ffff	/* 0x90 32-bit code */
+	.quad 0x00009b000000ffff	/* 0x98 16-bit code */
+	.quad 0x000093000000ffff	/* 0xa0 16-bit data */
+	.quad 0x0000930000000000	/* 0xa8 16-bit data */
+	.quad 0x0000930000000000	/* 0xb0 16-bit data */
+
+	/*
+	 * The APM segments have byte granularity and their bases
+	 * are set at run time.  All have 64k limits.
+	 */
+	.quad 0x00409b000000ffff	/* 0xb8 APM CS    code */
+	.quad 0x00009b000000ffff	/* 0xc0 APM CS 16 code (16 bit) */
+	.quad 0x004093000000ffff	/* 0xc8 APM DS    data */
+
+	.quad 0x00c0930000000000	/* 0xd0 - ESPFIX SS */
+	.quad 0x0040930000000000	/* 0xd8 - PERCPU */
+	.quad 0x0000000000000000	/* 0xe0 - PCIBIOS_CS */
+	.quad 0x0000000000000000	/* 0xe8 - PCIBIOS_DS */
+	.quad 0x0000000000000000	/* 0xf0 - unused */
+	.quad 0x0000000000000000	/* 0xf8 - GDT entry 31: double-fault TSS */
+
+	/* Be sure this is zeroed to avoid false validations in Xen */
+	.fill PAGE_SIZE_asm - GDT_SIZE,1,0
+	.endr
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/head_64.S linux-2.6.26.8-pax/arch/x86/kernel/head_64.S
--- linux-2.6.26.8/arch/x86/kernel/head_64.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/head_64.S	2008-10-11 18:20:35.000000000 +0200
@@ -77,6 +77,8 @@ startup_64:
 	 */
 	addq	%rbp, init_level4_pgt + 0(%rip)
 	addq	%rbp, init_level4_pgt + (258*8)(%rip)
+	addq	%rbp, init_level4_pgt + (388*8)(%rip)
+	addq	%rbp, init_level4_pgt + (452*8)(%rip)
 	addq	%rbp, init_level4_pgt + (511*8)(%rip)
 
 	addq	%rbp, level3_ident_pgt + 0(%rip)
@@ -181,6 +183,10 @@ ENTRY(secondary_startup_64)
 	btl	$20,%edi		/* No Execute supported? */
 	jnc     1f
 	btsl	$_EFER_NX, %eax
+	leaq	init_level4_pgt(%rip), %rdi
+	btsq	$_PAGE_BIT_NX, 8*258(%rdi)
+	btsq	$_PAGE_BIT_NX, 8*388(%rdi)
+	btsq	$_PAGE_BIT_NX, 8*452(%rdi)
 1:	wrmsr				/* Make changes effective */
 
 	/* Setup cr0 */
@@ -255,15 +261,15 @@ ENTRY(secondary_startup_64)
 	.align	8
 	ENTRY(initial_code)
 	.quad	x86_64_start_kernel
-	__FINITDATA
 
 	ENTRY(init_rsp)
 	.quad  init_thread_union+THREAD_SIZE-8
+	__FINITDATA
 
 bad_address:
 	jmp bad_address
 
-	.section ".init.text","ax"
+	__INIT
 #ifdef CONFIG_EARLY_PRINTK
 	.globl early_idt_handlers
 early_idt_handlers:
@@ -308,18 +314,23 @@ ENTRY(early_idt_handler)
 #endif /* EARLY_PRINTK */
 1:	hlt
 	jmp 1b
+	.previous
 
 #ifdef CONFIG_EARLY_PRINTK
+	__INITDATA
 early_recursion_flag:
 	.long 0
+	.previous
 
+	.section .rodata,"a",@progbits
 early_idt_msg:
 	.asciz "PANIC: early exception %02lx rip %lx:%lx error %lx cr2 %lx\n"
 early_idt_ripmsg:
 	.asciz "RIP %s\n"
-#endif /* CONFIG_EARLY_PRINTK */
 	.previous
+#endif /* CONFIG_EARLY_PRINTK */
 
+	.section .rodata,"a",@progbits
 .balign PAGE_SIZE
 
 #define NEXT_PAGE(name) \
@@ -344,7 +355,11 @@ NEXT_PAGE(init_level4_pgt)
 	.quad	level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
 	.fill	257,8,0
 	.quad	level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
-	.fill	252,8,0
+	.fill	129,8,0
+	.quad	level3_vmalloc_pgt - __START_KERNEL_map + _KERNPG_TABLE
+	.fill	63,8,0
+	.quad	level3_vmemmap_pgt - __START_KERNEL_map + _KERNPG_TABLE
+	.fill	58,8,0
 	/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */
 	.quad	level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE
 
@@ -352,6 +367,12 @@ NEXT_PAGE(level3_ident_pgt)
 	.quad	level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
 	.fill	511,8,0
 
+NEXT_PAGE(level3_vmalloc_pgt)
+	.fill	512,8,0
+
+NEXT_PAGE(level3_vmemmap_pgt)
+	.fill	512,8,0
+
 NEXT_PAGE(level3_kernel_pgt)
 	.fill	510,8,0
 	/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */
@@ -393,36 +414,18 @@ NEXT_PAGE(level2_spare_pgt)
 #undef PMDS
 #undef NEXT_PAGE
 
-	.data
-	.align 16
-	.globl cpu_gdt_descr
-cpu_gdt_descr:
-	.word	gdt_end-cpu_gdt_table-1
-gdt:
-	.quad	cpu_gdt_table
-#ifdef CONFIG_SMP
-	.rept	NR_CPUS-1
-	.word	0
-	.quad	0
-	.endr
-#endif
-
-ENTRY(phys_base)
-	/* This must match the first entry in level2_kernel_pgt */
-	.quad   0x0000000000000000
-
 /* We need valid kernel segments for data and code in long mode too
  * IRET will check the segment types  kkeil 2000/10/28
  * Also sysret mandates a special GDT layout 
  */
-		 		
-	.section .data.page_aligned, "aw"
+
 	.align PAGE_SIZE
 
 /* The TLS descriptors are currently at a different place compared to i386.
    Hopefully nobody expects them at a fixed place (Wine?) */
 	
 ENTRY(cpu_gdt_table)
+	.rept NR_CPUS
 	.quad	0x0000000000000000	/* NULL descriptor */
 	.quad	0x00cf9b000000ffff	/* __KERNEL32_CS */
 	.quad	0x00af9b000000ffff	/* __KERNEL_CS */
@@ -435,15 +438,24 @@ ENTRY(cpu_gdt_table)
 	.quad	0,0			/* LDT */
 	.quad   0,0,0			/* three TLS descriptors */ 
 	.quad	0x0000f40000000000	/* node/CPU stored in limit */
-gdt_end:	
 	/* asm/segment.h:GDT_ENTRIES must match this */	
 	/* This should be a multiple of the cache line size */
-	/* GDTs of other CPUs are now dynamically allocated */
 
 	/* zero the remaining page */
 	.fill PAGE_SIZE / 8 - GDT_ENTRIES,8,0
+	.endr
+
+	.align 16
+	.globl cpu_gdt_descr
+cpu_gdt_descr:
+	.word	GDT_SIZE-1
+gdt:
+	.quad	cpu_gdt_table
+
+ENTRY(phys_base)
+	/* This must match the first entry in level2_kernel_pgt */
+	.quad   0x0000000000000000
 
-	.section .bss, "aw", @nobits
 	.align L1_CACHE_BYTES
 ENTRY(idt_table)
 	.skip 256 * 16
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/i386_ksyms_32.c linux-2.6.26.8-pax/arch/x86/kernel/i386_ksyms_32.c
--- linux-2.6.26.8/arch/x86/kernel/i386_ksyms_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/i386_ksyms_32.c	2008-08-28 03:34:51.000000000 +0200
@@ -3,8 +3,12 @@
 #include <asm/desc.h>
 #include <asm/pgtable.h>
 
+EXPORT_SYMBOL_GPL(cpu_gdt_table);
+
 /* Networking helper routines. */
 EXPORT_SYMBOL(csum_partial_copy_generic);
+EXPORT_SYMBOL(csum_partial_copy_generic_to_user);
+EXPORT_SYMBOL(csum_partial_copy_generic_from_user);
 
 EXPORT_SYMBOL(__get_user_1);
 EXPORT_SYMBOL(__get_user_2);
@@ -19,3 +23,7 @@ EXPORT_SYMBOL(strstr);
 
 EXPORT_SYMBOL(csum_partial);
 EXPORT_SYMBOL(empty_zero_page);
+
+#ifdef CONFIG_PAX_KERNEXEC
+EXPORT_SYMBOL(KERNEL_TEXT_OFFSET);
+#endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/init_task.c linux-2.6.26.8-pax/arch/x86/kernel/init_task.c
--- linux-2.6.26.8/arch/x86/kernel/init_task.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/init_task.c	2008-07-14 03:52:23.000000000 +0200
@@ -42,5 +42,5 @@ EXPORT_SYMBOL(init_task);
  * section. Since TSS's are completely CPU-local, we want them
  * on exact cacheline boundaries, to eliminate cacheline ping-pong.
  */
-DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss) = INIT_TSS;
-
+struct tss_struct init_tss[NR_CPUS] ____cacheline_internodealigned_in_smp = { [0 ... NR_CPUS-1] = INIT_TSS };
+EXPORT_SYMBOL(init_tss);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/ioport.c linux-2.6.26.8-pax/arch/x86/kernel/ioport.c
--- linux-2.6.26.8/arch/x86/kernel/ioport.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/ioport.c	2008-07-14 03:52:23.000000000 +0200
@@ -66,7 +66,7 @@ asmlinkage long sys_ioperm(unsigned long
 	 * because the ->io_bitmap_max value must match the bitmap
 	 * contents:
 	 */
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 
 	set_bitmap(t->io_bitmap_ptr, from, num, !turn_on);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/irq_32.c linux-2.6.26.8-pax/arch/x86/kernel/irq_32.c
--- linux-2.6.26.8/arch/x86/kernel/irq_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/irq_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -115,7 +115,7 @@ unsigned int do_IRQ(struct pt_regs *regs
 		int arg1, arg2, bx;
 
 		/* build the stack frame on the IRQ stack */
-		isp = (u32*) ((char*)irqctx + sizeof(*irqctx));
+		isp = (u32*) ((char*)irqctx + sizeof(*irqctx) - 8);
 		irqctx->tinfo.task = curctx->tinfo.task;
 		irqctx->tinfo.previous_esp = current_stack_pointer;
 
@@ -209,7 +209,7 @@ asmlinkage void do_softirq(void)
 		irqctx->tinfo.previous_esp = current_stack_pointer;
 
 		/* build the stack frame on the softirq stack */
-		isp = (u32*) ((char*)irqctx + sizeof(*irqctx));
+		isp = (u32*) ((char*)irqctx + sizeof(*irqctx) - 8);
 
 		asm volatile(
 			"       xchgl   %%ebx,%%esp     \n"
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/kprobes.c linux-2.6.26.8-pax/arch/x86/kernel/kprobes.c
--- linux-2.6.26.8/arch/x86/kernel/kprobes.c	2008-08-07 13:54:05.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/kprobes.c	2008-08-07 13:54:09.000000000 +0200
@@ -166,9 +166,24 @@ static void __kprobes set_jmp_op(void *f
 		char op;
 		s32 raddr;
 	} __attribute__((packed)) * jop;
-	jop = (struct __arch_jmp_op *)from;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
+	jop = (struct __arch_jmp_op *)(ktla_ktva(from));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	jop->raddr = (s32)((long)(to) - ((long)(from) + 5));
 	jop->op = RELATIVEJUMP_INSTRUCTION;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 /*
@@ -342,16 +357,29 @@ static void __kprobes fix_riprel(struct 
 
 static void __kprobes arch_copy_kprobe(struct kprobe *p)
 {
-	memcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE * sizeof(kprobe_opcode_t));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	memcpy(p->ainsn.insn, ktla_ktva(p->addr), MAX_INSN_SIZE * sizeof(kprobe_opcode_t));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
 
 	fix_riprel(p);
 
-	if (can_boost(p->addr))
+	if (can_boost(ktla_ktva(p->addr)))
 		p->ainsn.boostable = 0;
 	else
 		p->ainsn.boostable = -1;
 
-	p->opcode = *p->addr;
+	p->opcode = *(ktla_ktva(p->addr));
 }
 
 int __kprobes arch_prepare_kprobe(struct kprobe *p)
@@ -428,7 +456,7 @@ static void __kprobes prepare_singlestep
 	if (p->opcode == BREAKPOINT_INSTRUCTION)
 		regs->ip = (unsigned long)p->addr;
 	else
-		regs->ip = (unsigned long)p->ainsn.insn;
+		regs->ip = ktva_ktla((unsigned long)p->ainsn.insn);
 }
 
 /* Called with kretprobe_lock held */
@@ -450,7 +478,7 @@ static void __kprobes setup_singlestep(s
 	if (p->ainsn.boostable == 1 && !p->post_handler) {
 		/* Boost up -- we can execute copied instructions directly */
 		reset_current_kprobe();
-		regs->ip = (unsigned long)p->ainsn.insn;
+		regs->ip = ktva_ktla((unsigned long)p->ainsn.insn);
 		preempt_enable_no_resched();
 		return;
 	}
@@ -772,7 +800,7 @@ static void __kprobes resume_execution(s
 		struct pt_regs *regs, struct kprobe_ctlblk *kcb)
 {
 	unsigned long *tos = stack_addr(regs);
-	unsigned long copy_ip = (unsigned long)p->ainsn.insn;
+	unsigned long copy_ip = ktva_ktla((unsigned long)p->ainsn.insn);
 	unsigned long orig_ip = (unsigned long)p->addr;
 	kprobe_opcode_t *insn = p->ainsn.insn;
 
@@ -955,7 +983,7 @@ int __kprobes kprobe_exceptions_notify(s
 	struct die_args *args = data;
 	int ret = NOTIFY_DONE;
 
-	if (args->regs && user_mode_vm(args->regs))
+	if (args->regs && user_mode(args->regs))
 		return ret;
 
 	switch (val) {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/ldt.c linux-2.6.26.8-pax/arch/x86/kernel/ldt.c
--- linux-2.6.26.8/arch/x86/kernel/ldt.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/ldt.c	2008-07-14 03:52:23.000000000 +0200
@@ -65,7 +65,7 @@ static int alloc_ldt(mm_context_t *pc, i
 		cpumask_t mask;
 
 		preempt_disable();
-		load_LDT(pc);
+		load_LDT_nolock(pc);
 		mask = cpumask_of_cpu(smp_processor_id());
 		if (!cpus_equal(current->mm->cpu_vm_mask, mask))
 			smp_call_function(flush_ldt, NULL, 1, 1);
@@ -110,6 +110,24 @@ int init_new_context(struct task_struct 
 		retval = copy_ldt(&mm->context, &old_mm->context);
 		mutex_unlock(&old_mm->context.lock);
 	}
+
+	if (tsk == current) {
+		mm->context.vdso = ~0UL;
+
+#ifdef CONFIG_X86_32
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		mm->context.user_cs_base = 0UL;
+		mm->context.user_cs_limit = ~0UL;
+
+#if defined(CONFIG_PAX_PAGEEXEC) && defined(CONFIG_SMP)
+		cpus_clear(mm->context.cpu_user_cs_mask);
+#endif
+
+#endif
+#endif
+
+	}
+
 	return retval;
 }
 
@@ -223,6 +241,13 @@ static int write_ldt(void __user *ptr, u
 		}
 	}
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && (ldt_info.contents & MODIFY_LDT_CONTENTS_CODE)) {
+		error = -EINVAL;
+		goto out_unlock;
+	}
+#endif
+
 	fill_ldt(&ldt, &ldt_info);
 	if (oldmode)
 		ldt.avl = 0;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/machine_kexec_32.c linux-2.6.26.8-pax/arch/x86/kernel/machine_kexec_32.c
--- linux-2.6.26.8/arch/x86/kernel/machine_kexec_32.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/machine_kexec_32.c	2008-10-10 00:49:19.000000000 +0200
@@ -30,7 +30,7 @@ static u32 kexec_pmd1[1024] PAGE_ALIGNED
 static u32 kexec_pte0[1024] PAGE_ALIGNED;
 static u32 kexec_pte1[1024] PAGE_ALIGNED;
 
-static void set_idt(void *newidt, __u16 limit)
+static void set_idt(struct desc_struct *newidt, __u16 limit)
 {
 	struct desc_ptr curidt;
 
@@ -42,7 +42,7 @@ static void set_idt(void *newidt, __u16 
 };
 
 
-static void set_gdt(void *newgdt, __u16 limit)
+static void set_gdt(struct desc_struct *newgdt, __u16 limit)
 {
 	struct desc_ptr curgdt;
 
@@ -111,10 +111,10 @@ NORET_TYPE void machine_kexec(struct kim
 	local_irq_disable();
 
 	control_page = page_address(image->control_code_page);
-	memcpy(control_page, relocate_kernel, PAGE_SIZE);
+	memcpy(control_page, (void *)ktla_ktva((unsigned long)relocate_kernel), PAGE_SIZE);
 
 	page_list[PA_CONTROL_PAGE] = __pa(control_page);
-	page_list[VA_CONTROL_PAGE] = (unsigned long)relocate_kernel;
+	page_list[VA_CONTROL_PAGE] = ktla_ktva((unsigned long)relocate_kernel);
 	page_list[PA_PGD] = __pa(kexec_pgd);
 	page_list[VA_PGD] = (unsigned long)kexec_pgd;
 #ifdef CONFIG_X86_PAE
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/module_32.c linux-2.6.26.8-pax/arch/x86/kernel/module_32.c
--- linux-2.6.26.8/arch/x86/kernel/module_32.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/module_32.c	2008-08-18 10:01:47.000000000 +0200
@@ -23,6 +23,9 @@
 #include <linux/kernel.h>
 #include <linux/bug.h>
 
+#include <asm/desc.h>
+#include <asm/pgtable.h>
+
 #if 0
 #define DEBUGP printk
 #else
@@ -33,9 +36,31 @@ void *module_alloc(unsigned long size)
 {
 	if (size == 0)
 		return NULL;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);
+#else
 	return vmalloc_exec(size);
+#endif
+
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+void *module_alloc_exec(unsigned long size)
+{
+	struct vm_struct *area;
+
+	if (size == 0)
+		return NULL;
+
+	area = __get_vm_area(size, VM_ALLOC, (unsigned long)&MODULES_VADDR, (unsigned long)&MODULES_END);
+	if (area)
+		return area->addr;
+
+	return NULL;
+}
+EXPORT_SYMBOL(module_alloc_exec);
+#endif
 
 /* Free memory returned from module_alloc */
 void module_free(struct module *mod, void *module_region)
@@ -45,6 +70,45 @@ void module_free(struct module *mod, voi
            table entries. */
 }
 
+#ifdef CONFIG_PAX_KERNEXEC
+void module_free_exec(struct module *mod, void *module_region)
+{
+	struct vm_struct **p, *tmp;
+
+	if (!module_region)
+		return;
+
+	if ((PAGE_SIZE-1) & (unsigned long)module_region) {
+		printk(KERN_ERR "Trying to module_free_exec() bad address (%p)\n", module_region);
+		WARN_ON(1);
+		return;
+	}
+
+	write_lock(&vmlist_lock);
+	for (p = &vmlist; (tmp = *p) != NULL; p = &tmp->next)
+		 if (tmp->addr == module_region)
+			break;
+
+	if (tmp) {
+		unsigned long cr0;
+
+		pax_open_kernel(cr0);
+		memset(tmp->addr, 0xCC, tmp->size);
+		pax_close_kernel(cr0);
+
+		*p = tmp->next;
+		kfree(tmp);
+	}
+	write_unlock(&vmlist_lock);
+
+	if (!tmp) {
+		printk(KERN_ERR "Trying to module_free_exec() nonexistent vm area (%p)\n",
+				module_region);
+		WARN_ON(1);
+	}
+}
+#endif
+
 /* We don't need anything special. */
 int module_frob_arch_sections(Elf_Ehdr *hdr,
 			      Elf_Shdr *sechdrs,
@@ -63,14 +127,20 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 	unsigned int i;
 	Elf32_Rel *rel = (void *)sechdrs[relsec].sh_addr;
 	Elf32_Sym *sym;
-	uint32_t *location;
+	uint32_t *plocation, location;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
 
 	DEBUGP("Applying relocate section %u to %u\n", relsec,
 	       sechdrs[relsec].sh_info);
 	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
 		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
+		plocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
+		location = (uint32_t)plocation;
+		if (sechdrs[sechdrs[relsec].sh_info].sh_flags & SHF_EXECINSTR)
+			plocation = ktla_ktva((void *)plocation);
 		/* This is the symbol it is referring to.  Note that all
 		   undefined symbols have been resolved.  */
 		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
@@ -78,12 +148,32 @@ int apply_relocate(Elf32_Shdr *sechdrs,
 
 		switch (ELF32_R_TYPE(rel[i].r_info)) {
 		case R_386_32:
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			/* We add the value into the location given */
-			*location += sym->st_value;
+			*plocation += sym->st_value;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			break;
 		case R_386_PC32:
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			/* Add the value, subtract its postition */
-			*location += sym->st_value - (uint32_t)location;
+			*plocation += sym->st_value - location;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			break;
 		default:
 			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/module_64.c linux-2.6.26.8-pax/arch/x86/kernel/module_64.c
--- linux-2.6.26.8/arch/x86/kernel/module_64.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/module_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -39,7 +39,7 @@ void module_free(struct module *mod, voi
            table entries. */
 }
 
-void *module_alloc(unsigned long size)
+static void *__module_alloc(unsigned long size, pgprot_t prot)
 {
 	struct vm_struct *area;
 
@@ -53,8 +53,31 @@ void *module_alloc(unsigned long size)
 	if (!area)
 		return NULL;
 
-	return __vmalloc_area(area, GFP_KERNEL, PAGE_KERNEL_EXEC);
+	return __vmalloc_area(area, GFP_KERNEL | __GFP_ZERO, prot);
+}
+
+#ifdef CONFIG_PAX_KERNEXEC
+void *module_alloc(unsigned long size)
+{
+	return __module_alloc(size, PAGE_KERNEL);
+}
+
+void module_free_exec(struct module *mod, void *module_region)
+{
+	module_free(mod, module_region);
+}
+
+void *module_alloc_exec(unsigned long size)
+{
+	return __module_alloc(size, PAGE_KERNEL_RX);
 }
+#else
+void *module_alloc(unsigned long size)
+{
+	return __module_alloc(size, PAGE_KERNEL_EXEC);
+}
+#endif
+
 #endif
 
 /* We don't need anything special. */
@@ -76,7 +99,11 @@ int apply_relocate_add(Elf64_Shdr *sechd
 	Elf64_Rela *rel = (void *)sechdrs[relsec].sh_addr;
 	Elf64_Sym *sym;
 	void *loc;
-	u64 val; 
+	u64 val;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
 
 	DEBUGP("Applying relocate section %u to %u\n", relsec,
 	       sechdrs[relsec].sh_info);
@@ -100,21 +127,61 @@ int apply_relocate_add(Elf64_Shdr *sechd
 		case R_X86_64_NONE:
 			break;
 		case R_X86_64_64:
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(u64 *)loc = val;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			break;
 		case R_X86_64_32:
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(u32 *)loc = val;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			if (val != *(u32 *)loc)
 				goto overflow;
 			break;
 		case R_X86_64_32S:
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(s32 *)loc = val;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			if ((s64)val != *(s32 *)loc)
 				goto overflow;
 			break;
 		case R_X86_64_PC32: 
 			val -= (u64)loc;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(u32 *)loc = val;
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 #if 0
 			if ((s64)val != *(s32 *)loc)
 				goto overflow; 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/mpparse.c linux-2.6.26.8-pax/arch/x86/kernel/mpparse.c
--- linux-2.6.26.8/arch/x86/kernel/mpparse.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/mpparse.c	2008-10-09 04:13:06.000000000 +0200
@@ -313,14 +313,14 @@ static int __init smp_read_mpc(struct mp
 
 	memcpy(str, mpc->mpc_productid, 12);
 	str[12] = 0;
-	printk("Product ID: %s ", str);
+	printk(KERN_CONT "Product ID: %s ", str);
 
 #ifdef CONFIG_X86_32
 	mps_oem_check(mpc, oem, str);
 #endif
-	printk(KERN_INFO "MPTABLE: Product ID: %s ", str);
+	printk(KERN_CONT "MPTABLE: Product ID: %s ", str);
 
-	printk(KERN_INFO "MPTABLE: APIC at: 0x%X\n", mpc->mpc_lapic);
+	printk(KERN_CONT "MPTABLE: APIC at: 0x%X\n", mpc->mpc_lapic);
 
 	/* save the local APIC address, it might be non-default */
 	if (!acpi_lapic)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/paravirt.c linux-2.6.26.8-pax/arch/x86/kernel/paravirt.c
--- linux-2.6.26.8/arch/x86/kernel/paravirt.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/paravirt.c	2008-07-14 03:52:23.000000000 +0200
@@ -42,7 +42,7 @@ void _paravirt_nop(void)
 {
 }
 
-static void __init default_banner(void)
+static void default_banner(void)
 {
 	printk(KERN_INFO "Booting paravirtualized kernel on %s\n",
 	       pv_info.name);
@@ -159,7 +159,7 @@ unsigned paravirt_patch_insns(void *insn
 	if (insn_len > len || start == NULL)
 		insn_len = len;
 	else
-		memcpy(insnbuf, start, insn_len);
+		memcpy(insnbuf, ktla_ktva(start), insn_len);
 
 	return insn_len;
 }
@@ -261,21 +261,21 @@ enum paravirt_lazy_mode paravirt_get_laz
 	return __get_cpu_var(paravirt_lazy_mode);
 }
 
-struct pv_info pv_info = {
+struct pv_info pv_info __read_only = {
 	.name = "bare hardware",
 	.paravirt_enabled = 0,
 	.kernel_rpl = 0,
 	.shared_kernel_pmd = 1,	/* Only used when CONFIG_X86_PAE is set */
 };
 
-struct pv_init_ops pv_init_ops = {
+struct pv_init_ops pv_init_ops __read_only = {
 	.patch = native_patch,
 	.banner = default_banner,
 	.arch_setup = paravirt_nop,
 	.memory_setup = machine_specific_memory_setup,
 };
 
-struct pv_time_ops pv_time_ops = {
+struct pv_time_ops pv_time_ops __read_only = {
 	.time_init = hpet_time_init,
 	.get_wallclock = native_get_wallclock,
 	.set_wallclock = native_set_wallclock,
@@ -283,7 +283,7 @@ struct pv_time_ops pv_time_ops = {
 	.get_cpu_khz = native_calculate_cpu_khz,
 };
 
-struct pv_irq_ops pv_irq_ops = {
+struct pv_irq_ops pv_irq_ops __read_only = {
 	.init_IRQ = native_init_IRQ,
 	.save_fl = native_save_fl,
 	.restore_fl = native_restore_fl,
@@ -293,7 +293,7 @@ struct pv_irq_ops pv_irq_ops = {
 	.halt = native_halt,
 };
 
-struct pv_cpu_ops pv_cpu_ops = {
+struct pv_cpu_ops pv_cpu_ops __read_only = {
 	.cpuid = native_cpuid,
 	.get_debugreg = native_get_debugreg,
 	.set_debugreg = native_set_debugreg,
@@ -339,7 +339,7 @@ struct pv_cpu_ops pv_cpu_ops = {
 	},
 };
 
-struct pv_apic_ops pv_apic_ops = {
+struct pv_apic_ops pv_apic_ops __read_only = {
 #ifdef CONFIG_X86_LOCAL_APIC
 	.apic_write = native_apic_write,
 	.apic_write_atomic = native_apic_write_atomic,
@@ -350,7 +350,7 @@ struct pv_apic_ops pv_apic_ops = {
 #endif
 };
 
-struct pv_mmu_ops pv_mmu_ops = {
+struct pv_mmu_ops pv_mmu_ops __read_only = {
 #ifndef CONFIG_X86_64
 	.pagetable_setup_start = native_pagetable_setup_start,
 	.pagetable_setup_done = native_pagetable_setup_done,
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/process_32.c linux-2.6.26.8-pax/arch/x86/kernel/process_32.c
--- linux-2.6.26.8/arch/x86/kernel/process_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/process_32.c	2008-10-04 21:54:19.000000000 +0200
@@ -66,8 +66,10 @@ EXPORT_SYMBOL(boot_option_idle_override)
 DEFINE_PER_CPU(struct task_struct *, current_task) = &init_task;
 EXPORT_PER_CPU_SYMBOL(current_task);
 
+#ifdef CONFIG_SMP
 DEFINE_PER_CPU(int, cpu_number);
 EXPORT_PER_CPU_SYMBOL(cpu_number);
+#endif
 
 /*
  * Return saved PC of a blocked thread.
@@ -75,6 +77,7 @@ EXPORT_PER_CPU_SYMBOL(cpu_number);
 unsigned long thread_saved_pc(struct task_struct *tsk)
 {
 	return ((unsigned long *)tsk->thread.sp)[3];
+//XXX	return tsk->thread.eip;
 }
 
 /*
@@ -201,7 +204,7 @@ void __show_registers(struct pt_regs *re
 	unsigned long sp;
 	unsigned short ss, gs;
 
-	if (user_mode_vm(regs)) {
+	if (user_mode(regs)) {
 		sp = regs->sp;
 		ss = regs->ss & 0xffff;
 		savesegment(gs, gs);
@@ -278,8 +281,8 @@ int kernel_thread(int (*fn)(void *), voi
 	regs.bx = (unsigned long) fn;
 	regs.dx = (unsigned long) arg;
 
-	regs.ds = __USER_DS;
-	regs.es = __USER_DS;
+	regs.ds = __KERNEL_DS;
+	regs.es = __KERNEL_DS;
 	regs.fs = __KERNEL_PERCPU;
 	regs.orig_ax = -1;
 	regs.ip = (unsigned long) kernel_thread_helper;
@@ -301,7 +304,7 @@ void exit_thread(void)
 		struct task_struct *tsk = current;
 		struct thread_struct *t = &tsk->thread;
 		int cpu = get_cpu();
-		struct tss_struct *tss = &per_cpu(init_tss, cpu);
+		struct tss_struct *tss = init_tss + cpu;
 
 		kfree(t->io_bitmap_ptr);
 		t->io_bitmap_ptr = NULL;
@@ -322,6 +325,7 @@ void flush_thread(void)
 {
 	struct task_struct *tsk = current;
 
+	loadsegment(gs, 0);
 	tsk->thread.debugreg0 = 0;
 	tsk->thread.debugreg1 = 0;
 	tsk->thread.debugreg2 = 0;
@@ -361,7 +365,7 @@ int copy_thread(int nr, unsigned long cl
 	struct task_struct *tsk;
 	int err;
 
-	childregs = task_pt_regs(p);
+	childregs = task_stack_page(p) + THREAD_SIZE - sizeof(struct pt_regs) - 8;
 	*childregs = *regs;
 	childregs->ax = 0;
 	childregs->sp = sp;
@@ -390,6 +394,7 @@ int copy_thread(int nr, unsigned long cl
 	 * Set a new TLS for the child thread?
 	 */
 	if (clone_flags & CLONE_SETTLS)
+//XXX needs set_fs()?
 		err = do_set_thread_area(p, -1,
 			(struct user_desc __user *)childregs->si, 0);
 
@@ -589,7 +594,7 @@ struct task_struct * __switch_to(struct 
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */
 
@@ -617,6 +622,11 @@ struct task_struct * __switch_to(struct 
 	 */
 	savesegment(gs, prev->gs);
 
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+	if (!segment_eq(task_thread_info(prev_p)->addr_limit, task_thread_info(next_p)->addr_limit))
+		__set_fs(task_thread_info(next_p)->addr_limit, cpu);
+#endif
+
 	/*
 	 * Load the per-thread Thread-Local Storage descriptor.
 	 */
@@ -755,15 +765,27 @@ unsigned long get_wchan(struct task_stru
 	return 0;
 }
 
-unsigned long arch_align_stack(unsigned long sp)
+#ifdef CONFIG_PAX_RANDKSTACK
+asmlinkage void pax_randomize_kstack(void)
 {
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
-}
+	struct thread_struct *thread = &current->thread;
+	unsigned long time;
 
-unsigned long arch_randomize_brk(struct mm_struct *mm)
-{
-	unsigned long range_end = mm->brk + 0x02000000;
-	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
+	if (!randomize_va_space)
+		return;
+
+	rdtscl(time);
+
+	/* P4 seems to return a 0 LSB, ignore it */
+#ifdef CONFIG_MPENTIUM4
+	time &= 0x1EUL;
+	time <<= 2;
+#else
+	time &= 0xFUL;
+	time <<= 3;
+#endif
+
+	thread->sp0 ^= time;
+	load_sp0(init_tss + smp_processor_id(), thread);
 }
+#endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/process_64.c linux-2.6.26.8-pax/arch/x86/kernel/process_64.c
--- linux-2.6.26.8/arch/x86/kernel/process_64.c	2008-10-23 11:01:02.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/process_64.c	2008-10-23 11:01:17.000000000 +0200
@@ -146,6 +146,8 @@ static inline void play_dead(void)
 void cpu_idle(void)
 {
 	current_thread_info()->status |= TS_POLLING;
+	current->stack_canary = pax_get_random_long();
+	write_pda(stack_canary, current->stack_canary);
 	/* endless idle loop with no priority at all */
 	while (1) {
 		tick_nohz_stop_sched_tick();
@@ -255,7 +257,7 @@ void exit_thread(void)
 	struct thread_struct *t = &me->thread;
 
 	if (me->thread.io_bitmap_ptr) {
-		struct tss_struct *tss = &per_cpu(init_tss, get_cpu());
+		struct tss_struct *tss = init_tss + get_cpu();
 
 		kfree(t->io_bitmap_ptr);
 		t->io_bitmap_ptr = NULL;
@@ -566,7 +568,7 @@ __switch_to(struct task_struct *prev_p, 
 	struct thread_struct *prev = &prev_p->thread,
 				 *next = &next_p->thread;
 	int cpu = smp_processor_id();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	/* we're going to use this soon, after a few expensive things */
 	if (next_p->fpu_counter>5)
@@ -641,7 +643,6 @@ __switch_to(struct task_struct *prev_p, 
 	write_pda(kernelstack,
 	(unsigned long)task_stack_page(next_p) + THREAD_SIZE - PDA_STACKOFFSET);
 #ifdef CONFIG_CC_STACKPROTECTOR
-	write_pda(stack_canary, next_p->stack_canary);
 	/*
 	 * Build time only check to make sure the stack_canary is at
 	 * offset 40 in the pda; this is a gcc ABI requirement
@@ -855,16 +856,3 @@ long sys_arch_prctl(int code, unsigned l
 {
 	return do_arch_prctl(current, code, addr);
 }
-
-unsigned long arch_align_stack(unsigned long sp)
-{
-	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
-		sp -= get_random_int() % 8192;
-	return sp & ~0xf;
-}
-
-unsigned long arch_randomize_brk(struct mm_struct *mm)
-{
-	unsigned long range_end = mm->brk + 0x02000000;
-	return randomize_range(mm->brk, range_end, 0) ? : mm->brk;
-}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/ptrace.c linux-2.6.26.8-pax/arch/x86/kernel/ptrace.c
--- linux-2.6.26.8/arch/x86/kernel/ptrace.c	2008-08-03 19:20:46.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/ptrace.c	2008-08-03 19:21:00.000000000 +0200
@@ -1371,7 +1371,7 @@ void send_sigtrap(struct task_struct *ts
 	info.si_code = TRAP_BRKPT;
 
 	/* User-mode ip? */
-	info.si_addr = user_mode_vm(regs) ? (void __user *) regs->ip : NULL;
+	info.si_addr = user_mode(regs) ? (void __user *) regs->ip : NULL;
 
 	/* Send us the fake SIGTRAP */
 	force_sig_info(SIGTRAP, &info, tsk);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/reboot.c linux-2.6.26.8-pax/arch/x86/kernel/reboot.c
--- linux-2.6.26.8/arch/x86/kernel/reboot.c	2008-08-03 19:20:46.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/reboot.c	2008-08-03 19:21:00.000000000 +0200
@@ -28,7 +28,7 @@ void (*pm_power_off)(void);
 EXPORT_SYMBOL(pm_power_off);
 
 static long no_idt[3];
-static int reboot_mode;
+static unsigned short reboot_mode;
 enum reboot_type reboot_type = BOOT_KBD;
 int reboot_force;
 
@@ -193,7 +193,7 @@ static struct dmi_system_id __initdata r
 			DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 static int __init reboot_init(void)
@@ -209,15 +209,15 @@ core_initcall(reboot_init);
    controller to pulse the CPU reset line, which is more thorough, but
    doesn't work with at least one type of 486 motherboard.  It is easy
    to stop this code working; hence the copious comments. */
-static unsigned long long
-real_mode_gdt_entries [3] =
+static struct desc_struct
+real_mode_gdt_entries [3] __read_only =
 {
-	0x0000000000000000ULL,	/* Null descriptor */
-	0x00009a000000ffffULL,	/* 16-bit real-mode 64k code at 0x00000000 */
-	0x000092000100ffffULL	/* 16-bit real-mode 64k data at 0x00000100 */
+	{{{0x00000000, 0x00000000}}},	/* Null descriptor */
+	{{{0x0000ffff, 0x00009b00}}},	/* 16-bit real-mode 64k code at 0x00000000 */
+	{{{0x0100ffff, 0x00009300}}}	/* 16-bit real-mode 64k data at 0x00000100 */
 };
 
-static struct desc_ptr
+static const struct desc_ptr
 real_mode_gdt = { sizeof (real_mode_gdt_entries) - 1, (long)real_mode_gdt_entries },
 real_mode_idt = { 0x3ff, 0 };
 
@@ -239,7 +239,7 @@ real_mode_idt = { 0x3ff, 0 };
 
    More could be done here to set up the registers as if a CPU reset had
    occurred; hopefully real BIOSs don't assume much. */
-static unsigned char real_mode_switch [] =
+static const unsigned char real_mode_switch [] =
 {
 	0x66, 0x0f, 0x20, 0xc0,			/*    movl  %cr0,%eax        */
 	0x66, 0x83, 0xe0, 0x11,			/*    andl  $0x00000011,%eax */
@@ -253,7 +253,7 @@ static unsigned char real_mode_switch []
 	0x24, 0x10,				/* f: andb  $0x10,al         */
 	0x66, 0x0f, 0x22, 0xc0			/*    movl  %eax,%cr0        */
 };
-static unsigned char jump_to_bios [] =
+static const unsigned char jump_to_bios [] =
 {
 	0xea, 0x00, 0x00, 0xff, 0xff		/*    ljmp  $0xffff,$0x0000  */
 };
@@ -263,7 +263,7 @@ static unsigned char jump_to_bios [] =
  * specified by the code and length parameters.
  * We assume that length will aways be less that 100!
  */
-void machine_real_restart(unsigned char *code, int length)
+void machine_real_restart(const unsigned char *code, unsigned int length)
 {
 	local_irq_disable();
 
@@ -283,8 +283,8 @@ void machine_real_restart(unsigned char 
 	/* Remap the kernel at virtual address zero, as well as offset zero
 	   from the kernel segment.  This assumes the kernel segment starts at
 	   virtual address PAGE_OFFSET. */
-	memcpy(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
-		sizeof(swapper_pg_dir [0]) * KERNEL_PGD_PTRS);
+	clone_pgd_range(swapper_pg_dir, swapper_pg_dir + KERNEL_PGD_BOUNDARY,
+			min_t(unsigned long, KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));
 
 	/*
 	 * Use `swapper_pg_dir' as our page directory.
@@ -296,16 +296,15 @@ void machine_real_restart(unsigned char 
 	   boot)".  This seems like a fairly standard thing that gets set by
 	   REBOOT.COM programs, and the previous reset routine did this
 	   too. */
-	*((unsigned short *)0x472) = reboot_mode;
+	*(unsigned short *)(__va(0x472)) = reboot_mode;
 
 	/* For the switch to real mode, copy some code to low memory.  It has
 	   to be in the first 64k because it is running in 16-bit mode, and it
 	   has to have the same physical and virtual address, because it turns
 	   off paging.  Copy it near the end of the first page, out of the way
 	   of BIOS variables. */
-	memcpy((void *)(0x1000 - sizeof(real_mode_switch) - 100),
-		real_mode_switch, sizeof (real_mode_switch));
-	memcpy((void *)(0x1000 - 100), code, length);
+	memcpy(__va(0x1000 - sizeof (real_mode_switch) - 100), real_mode_switch, sizeof (real_mode_switch));
+	memcpy(__va(0x1000 - 100), code, length);
 
 	/* Set up the IDT for real mode. */
 	load_idt(&real_mode_idt);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/setup64.c linux-2.6.26.8-pax/arch/x86/kernel/setup64.c
--- linux-2.6.26.8/arch/x86/kernel/setup64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/setup64.c	2008-10-04 22:06:39.000000000 +0200
@@ -38,15 +38,13 @@ struct x8664_pda *_cpu_pda[NR_CPUS] __re
 EXPORT_SYMBOL(_cpu_pda);
 struct x8664_pda boot_cpu_pda[NR_CPUS] __cacheline_aligned;
 
-struct desc_ptr idt_descr = { 256 * 16 - 1, (unsigned long) idt_table };
+struct desc_ptr idt_descr __read_only = { 256 * 16 - 1, (unsigned long) idt_table };
 
 char boot_cpu_stack[IRQSTACKSIZE] __attribute__((section(".bss.page_aligned")));
 
 unsigned long __supported_pte_mask __read_mostly = ~0UL;
 EXPORT_SYMBOL_GPL(__supported_pte_mask);
 
-static int do_not_nx __cpuinitdata = 0;
-
 /* noexec=on|off
 Control non executable mappings for 64bit processes.
 
@@ -59,16 +57,14 @@ static int __init nonx_setup(char *str)
 		return -EINVAL;
 	if (!strncmp(str, "on", 2)) {
                 __supported_pte_mask |= _PAGE_NX; 
- 		do_not_nx = 0; 
 	} else if (!strncmp(str, "off", 3)) {
-		do_not_nx = 1;
 		__supported_pte_mask &= ~_PAGE_NX;
         }
 	return 0;
 } 
 early_param("noexec", nonx_setup);
 
-int force_personality32 = 0; 
+int force_personality32;
 
 /* noexec32=on|off
 Control non executable heap for 32bit processes.
@@ -151,7 +147,7 @@ void __cpuinit check_efer(void)
 	unsigned long efer;
 
 	rdmsrl(MSR_EFER, efer); 
-        if (!(efer & EFER_NX) || do_not_nx) { 
+        if (!(efer & EFER_NX)) {
                 __supported_pte_mask &= ~_PAGE_NX; 
         }       
 }
@@ -174,12 +170,13 @@ DEFINE_PER_CPU(struct orig_ist, orig_ist
 void __cpuinit cpu_init (void)
 {
 	int cpu = stack_smp_processor_id();
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
 	struct orig_ist *orig_ist = &per_cpu(orig_ist, cpu);
 	unsigned long v; 
 	char *estacks = NULL; 
 	struct task_struct *me;
 	int i;
+	struct desc_ptr cpu_gdt_descr = { .size = GDT_SIZE - 1, .address = (unsigned long)get_cpu_gdt_table(cpu)};
 
 	/* CPU 0 is initialised in head64.c */
 	if (cpu != 0) {
@@ -197,14 +194,9 @@ void __cpuinit cpu_init (void)
 	clear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);
 
 	/*
-	 * Initialize the per-CPU GDT with the boot GDT,
-	 * and set up the GDT descriptor:
+	 * Initialize the per-CPU GDT with the boot GDT:
 	 */
-	if (cpu)
-		memcpy(get_cpu_gdt_table(cpu), cpu_gdt_table, GDT_SIZE);
-
-	cpu_gdt_descr[cpu].size = GDT_SIZE;
-	load_gdt((const struct desc_ptr *)&cpu_gdt_descr[cpu]);
+	load_gdt(&cpu_gdt_descr);
 	load_idt((const struct desc_ptr *)&idt_descr);
 
 	memset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/setup_32.c linux-2.6.26.8-pax/arch/x86/kernel/setup_32.c
--- linux-2.6.26.8/arch/x86/kernel/setup_32.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/setup_32.c	2008-10-09 23:42:05.000000000 +0200
@@ -67,6 +67,7 @@
 #include <asm/bios_ebda.h>
 #include <asm/cacheflush.h>
 #include <asm/processor.h>
+#include <asm/boot.h>
 
 /* This value is set up by the early boot code to point to the value
    immediately after the boot time page tables.  It contains a *physical*
@@ -341,10 +342,10 @@ early_param("reservetop", parse_reservet
  */
 unsigned long __init find_max_low_pfn(void)
 {
-	unsigned long max_low_pfn;
+	unsigned long __max_low_pfn;
 
-	max_low_pfn = max_pfn;
-	if (max_low_pfn > MAXMEM_PFN) {
+	__max_low_pfn = max_pfn;
+	if (__max_low_pfn > MAXMEM_PFN) {
 		if (highmem_pages == -1)
 			highmem_pages = max_pfn - MAXMEM_PFN;
 		if (highmem_pages + MAXMEM_PFN < max_pfn)
@@ -353,7 +354,7 @@ unsigned long __init find_max_low_pfn(vo
 			printk("only %luMB highmem pages available, ignoring highmem size of %uMB.\n", pages_to_mb(max_pfn - MAXMEM_PFN), pages_to_mb(highmem_pages));
 			highmem_pages = 0;
 		}
-		max_low_pfn = MAXMEM_PFN;
+		__max_low_pfn = MAXMEM_PFN;
 #ifndef CONFIG_HIGHMEM
 		/* Maximum memory usable is what is directly addressable */
 		printk(KERN_WARNING "Warning only %ldMB will be used.\n",
@@ -381,18 +382,18 @@ unsigned long __init find_max_low_pfn(vo
 			highmem_pages = 0;
 		}
 		if (highmem_pages) {
-			if (max_low_pfn-highmem_pages < 64*1024*1024/PAGE_SIZE){
+			if (__max_low_pfn-highmem_pages < 64*1024*1024/PAGE_SIZE){
 				printk(KERN_ERR "highmem size %uMB results in smaller than 64MB lowmem, ignoring it.\n", pages_to_mb(highmem_pages));
 				highmem_pages = 0;
 			}
-			max_low_pfn -= highmem_pages;
+			__max_low_pfn -= highmem_pages;
 		}
 #else
 		if (highmem_pages)
 			printk(KERN_ERR "ignoring highmem size on non-highmem kernel!\n");
 #endif
 	}
-	return max_low_pfn;
+	return __max_low_pfn;
 }
 
 #define BIOS_LOWMEM_KILOBYTES 0x413
@@ -447,7 +448,7 @@ static void __init reserve_ebda_region(v
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES
 static void __init setup_bootmem_allocator(void);
-static unsigned long __init setup_memory(void)
+static void __init setup_memory(void)
 {
 	/*
 	 * partially used pages are not usable - thus
@@ -477,8 +478,6 @@ static unsigned long __init setup_memory
 			pages_to_mb(max_low_pfn));
 
 	setup_bootmem_allocator();
-
-	return max_low_pfn;
 }
 
 static void __init zone_sizes_init(void)
@@ -498,7 +497,7 @@ static void __init zone_sizes_init(void)
 	free_area_init_nodes(max_zone_pfns);
 }
 #else
-extern unsigned long __init setup_memory(void);
+extern void __init setup_memory(void);
 extern void zone_sizes_init(void);
 #endif /* !CONFIG_NEED_MULTIPLE_NODES */
 
@@ -662,8 +661,8 @@ void __init setup_bootmem_allocator(void
 	 * the (very unlikely) case of us accidentally initializing the
 	 * bootmem allocator with an invalid RAM area.
 	 */
-	reserve_bootmem(__pa_symbol(_text), (PFN_PHYS(min_low_pfn) +
-			 bootmap_size + PAGE_SIZE-1) - __pa_symbol(_text),
+	reserve_bootmem(LOAD_PHYSICAL_ADDR, (PFN_PHYS(min_low_pfn) +
+			 bootmap_size + PAGE_SIZE-1) - LOAD_PHYSICAL_ADDR,
 			 BOOTMEM_DEFAULT);
 
 	/*
@@ -758,8 +757,6 @@ DEFINE_PER_CPU(int, x86_cpu_to_node_map)
  */
 void __init setup_arch(char **cmdline_p)
 {
-	unsigned long max_low_pfn;
-
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
 	pre_setup_arch_hook();
 	early_cpu_init();
@@ -799,14 +796,14 @@ void __init setup_arch(char **cmdline_p)
 
 	if (!boot_params.hdr.root_flags)
 		root_mountflags &= ~MS_RDONLY;
-	init_mm.start_code = (unsigned long) _text;
-	init_mm.end_code = (unsigned long) _etext;
+	init_mm.start_code = ktla_ktva((unsigned long) _text);
+	init_mm.end_code = ktla_ktva((unsigned long) _etext);
 	init_mm.end_data = (unsigned long) _edata;
 	init_mm.brk = init_pg_tables_end + PAGE_OFFSET;
 
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
+	code_resource.start = virt_to_phys(ktla_ktva(_text));
+	code_resource.end = virt_to_phys(ktla_ktva(_etext))-1;
+	data_resource.start = virt_to_phys(_data);
 	data_resource.end = virt_to_phys(_edata)-1;
 	bss_resource.start = virt_to_phys(&__bss_start);
 	bss_resource.end = virt_to_phys(&__bss_stop)-1;
@@ -830,7 +827,7 @@ void __init setup_arch(char **cmdline_p)
 	if (mtrr_trim_uncached_memory(max_pfn))
 		propagate_e820_map();
 
-	max_low_pfn = setup_memory();
+	setup_memory();
 
 #ifdef CONFIG_KVM_CLOCK
 	kvmclock_init();
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/signal_32.c linux-2.6.26.8-pax/arch/x86/kernel/signal_32.c
--- linux-2.6.26.8/arch/x86/kernel/signal_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/signal_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -378,9 +378,9 @@ setup_frame(int sig, struct k_sigaction 
 	}
 
 	if (current->mm->context.vdso)
-		restorer = VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);
+		restorer = (void __user *)VDSO32_SYMBOL(current->mm->context.vdso, sigreturn);
 	else
-		restorer = &frame->retcode;
+		restorer = (void __user *)&frame->retcode;
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 
@@ -460,7 +460,7 @@ static int setup_rt_frame(int sig, struc
 		goto give_sigsegv;
 
 	/* Set up to return from userspace.  */
-	restorer = VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);
+	restorer = (void __user *)VDSO32_SYMBOL(current->mm->context.vdso, rt_sigreturn);
 	if (ka->sa.sa_flags & SA_RESTORER)
 		restorer = ka->sa.sa_restorer;
 	err |= __put_user(restorer, &frame->pretcode);
@@ -590,7 +590,7 @@ static void do_signal(struct pt_regs *re
 	 * X86_32: vm86 regs switched out by assembly code before reaching
 	 * here, so testing against kernel CS suffices.
 	 */
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		return;
 
 	if (current_thread_info()->status & TS_RESTORE_SIGMASK)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/signal_64.c linux-2.6.26.8-pax/arch/x86/kernel/signal_64.c
--- linux-2.6.26.8/arch/x86/kernel/signal_64.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/signal_64.c	2008-10-09 04:13:06.000000000 +0200
@@ -312,8 +312,8 @@ static int setup_rt_frame(int sig, struc
 	err |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0], me);
 	err |= __put_user(fp, &frame->uc.uc_mcontext.fpstate);
 	if (sizeof(*set) == 16) { 
-		__put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);
-		__put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]); 
+		err |= __put_user(set->sig[0], &frame->uc.uc_sigmask.sig[0]);
+		err |= __put_user(set->sig[1], &frame->uc.uc_sigmask.sig[1]);
 	} else
 		err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/smpboot.c linux-2.6.26.8-pax/arch/x86/kernel/smpboot.c
--- linux-2.6.26.8/arch/x86/kernel/smpboot.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/smpboot.c	2008-09-28 13:08:28.000000000 +0200
@@ -847,15 +847,13 @@ static int __cpuinit do_boot_cpu(int api
 		.cpu = cpu,
 		.done = COMPLETION_INITIALIZER_ONSTACK(c_idle.done),
 	};
+
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_KERNEXEC)
+	unsigned long cr0;
+#endif
+
 	INIT_WORK(&c_idle.work, do_fork_idle);
 #ifdef CONFIG_X86_64
-	/* allocate memory for gdts of secondary cpus. Hotplug is considered */
-	if (!cpu_gdt_descr[cpu].address &&
-		!(cpu_gdt_descr[cpu].address = get_zeroed_page(GFP_KERNEL))) {
-		printk(KERN_ERR "Failed to allocate GDT for CPU %d\n", cpu);
-		return -1;
-	}
-
 	/* Allocate node local memory for AP pdas */
 	if (cpu_pda(cpu) == &boot_cpu_pda[cpu]) {
 		struct x8664_pda *newpda, *pda;
@@ -905,7 +903,17 @@ do_rest:
 #ifdef CONFIG_X86_32
 	per_cpu(current_task, cpu) = c_idle.idle;
 	init_gdt(cpu);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	early_gdt_descr.address = (unsigned long)get_cpu_gdt_table(cpu);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	c_idle.idle->thread.ip = (unsigned long) start_secondary;
 	/* Stack for startup_32 can be just as for start_secondary onwards */
 	stack_start.sp = (void *) c_idle.idle->thread.sp;
@@ -913,7 +921,7 @@ do_rest:
 #else
 	cpu_pda(cpu)->pcurrent = c_idle.idle;
 	init_rsp = c_idle.idle->thread.sp;
-	load_sp0(&per_cpu(init_tss, cpu), &c_idle.idle->thread);
+	load_sp0(init_tss + cpu, &c_idle.idle->thread);
 	initial_code = (unsigned long)start_secondary;
 	clear_tsk_thread_flag(c_idle.idle, TIF_FORK);
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/smpcommon.c linux-2.6.26.8-pax/arch/x86/kernel/smpcommon.c
--- linux-2.6.26.8/arch/x86/kernel/smpcommon.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/smpcommon.c	2008-10-05 01:13:34.000000000 +0200
@@ -3,9 +3,10 @@
  */
 #include <linux/module.h>
 #include <asm/smp.h>
+#include <asm/sections.h>
 
 #ifdef CONFIG_X86_32
-DEFINE_PER_CPU(unsigned long, this_cpu_off);
+DEFINE_PER_CPU(unsigned long, this_cpu_off) = (unsigned long)__per_cpu_start;
 EXPORT_PER_CPU_SYMBOL(this_cpu_off);
 
 /* Initialize the CPU's GDT.  This is either the boot CPU doing itself
@@ -13,15 +14,19 @@ EXPORT_PER_CPU_SYMBOL(this_cpu_off);
    secondary which will soon come up. */
 __cpuinit void init_gdt(int cpu)
 {
-	struct desc_struct *gdt = get_cpu_gdt_table(cpu);
+	struct desc_struct d, *gdt = get_cpu_gdt_table(cpu);
+	unsigned long base, limit;
+  
+	base = per_cpu_offset(cpu);
+	limit = PERCPU_ENOUGH_ROOM - 1;
+	if (limit < 64*1024)
+		pack_descriptor(&d, base, limit, 0x80 | DESCTYPE_S | 0x3, 0x4);
+	else
+		pack_descriptor(&d, base, limit >> PAGE_SHIFT, 0x80 | DESCTYPE_S | 0x3, 0xC);
 
-	pack_descriptor(&gdt[GDT_ENTRY_PERCPU],
-			__per_cpu_offset[cpu], 0xFFFFF,
-			0x2 | DESCTYPE_S, 0x8);
+	write_gdt_entry(gdt, GDT_ENTRY_PERCPU, &d, DESCTYPE_S);
 
-	gdt[GDT_ENTRY_PERCPU].s = 1;
-
-	per_cpu(this_cpu_off, cpu) = __per_cpu_offset[cpu];
+	per_cpu(this_cpu_off, cpu) = base;
 	per_cpu(cpu_number, cpu) = cpu;
 }
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/step.c linux-2.6.26.8-pax/arch/x86/kernel/step.c
--- linux-2.6.26.8/arch/x86/kernel/step.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/step.c	2008-09-21 22:30:06.000000000 +0200
@@ -23,22 +23,20 @@ unsigned long convert_ip_to_linear(struc
 	 * and APM bios ones we just ignore here.
 	 */
 	if ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {
-		u32 *desc;
+		struct desc_struct *desc;
 		unsigned long base;
 
-		seg &= ~7UL;
+		seg >>= 3;
 
 		mutex_lock(&child->mm->context.lock);
-		if (unlikely((seg >> 3) >= child->mm->context.size))
-			addr = -1L; /* bogus selector, access would fault */
+		if (unlikely(seg >= child->mm->context.size))
+			addr = -EINVAL;
 		else {
-			desc = child->mm->context.ldt + seg;
-			base = ((desc[0] >> 16) |
-				((desc[1] & 0xff) << 16) |
-				(desc[1] & 0xff000000));
+			desc = &child->mm->context.ldt[seg];
+			base = (desc->a >> 16) | ((desc->b & 0xff) << 16) | (desc->b & 0xff000000);
 
 			/* 16-bit code segment? */
-			if (!((desc[1] >> 22) & 1))
+			if (!((desc->b >> 22) & 1))
 				addr &= 0xffff;
 			addr += base;
 		}
@@ -54,6 +52,9 @@ static int is_setting_trap_flag(struct t
 	unsigned char opcode[15];
 	unsigned long addr = convert_ip_to_linear(child, regs);
 
+	if (addr == -EINVAL)
+		return 0;
+
 	copied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);
 	for (i = 0; i < copied; i++) {
 		switch (opcode[i]) {
@@ -75,7 +76,7 @@ static int is_setting_trap_flag(struct t
 
 #ifdef CONFIG_X86_64
 		case 0x40 ... 0x4f:
-			if (regs->cs != __USER_CS)
+			if ((regs->cs & 0xffff) != __USER_CS)
 				/* 32-bit mode: register increment */
 				return 0;
 			/* 64-bit mode: REX prefix */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/sys_i386_32.c linux-2.6.26.8-pax/arch/x86/kernel/sys_i386_32.c
--- linux-2.6.26.8/arch/x86/kernel/sys_i386_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/sys_i386_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -22,6 +22,21 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+int i386_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)
+{
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (current->mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size || addr > pax_task_size - len)
+		return -EINVAL;
+
+	return 0;
+}
+
 asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
 			  unsigned long prot, unsigned long flags,
 			  unsigned long fd, unsigned long pgoff)
@@ -81,6 +96,205 @@ out:
 	return err;
 }
 
+unsigned long
+arch_get_unmapped_area(struct file *filp, unsigned long addr,
+		unsigned long len, unsigned long pgoff, unsigned long flags)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	unsigned long start_addr, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size)
+		return -ENOMEM;
+
+	if (flags & MAP_FIXED)
+		return addr;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (pax_task_size - len >= addr &&
+		    (!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+	if (len > mm->cached_hole_size) {
+		start_addr = addr = mm->free_area_cache;
+	} else {
+		start_addr = addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
+	}
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!nx_enabled && (mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE) && start_addr >= mm->mmap_base) {
+		start_addr = 0x00110000UL;
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			start_addr += mm->delta_mmap & 0x03FFF000UL;
+#endif
+
+		if (mm->start_brk <= start_addr && start_addr < mm->mmap_base)
+			start_addr = addr = mm->mmap_base;
+		else
+			addr = start_addr;
+	}
+#endif
+
+full_search:
+	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
+		/* At this point:  (!vma || addr < vma->vm_end). */
+		if (pax_task_size - len < addr) {
+			/*
+			 * Start a new search - just in case we missed
+			 * some holes.
+			 */
+			if (start_addr != mm->mmap_base) {
+				start_addr = addr = mm->mmap_base;
+				mm->cached_hole_size = 0;
+				goto full_search;
+			}
+			return -ENOMEM;
+		}
+		if (!vma || addr + len <= vma->vm_start) {
+			/*
+			 * Remember the place where we stopped the search:
+			 */
+			mm->free_area_cache = addr + len;
+			return addr;
+		}
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+		addr = vma->vm_end;
+		if (mm->start_brk <= addr && addr < mm->mmap_base) {
+			start_addr = addr = mm->mmap_base;
+			mm->cached_hole_size = 0;
+			goto full_search;
+		}
+	}
+}
+
+unsigned long
+arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
+			  const unsigned long len, const unsigned long pgoff,
+			  const unsigned long flags)
+{
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	unsigned long base = mm->mmap_base, addr = addr0, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	/* requested length too big for entire address space */
+	if (len > pax_task_size)
+		return -ENOMEM;
+
+	if (flags & MAP_FIXED)
+		return addr;
+
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!nx_enabled && (mm->pax_flags & MF_PAX_PAGEEXEC) && (flags & MAP_EXECUTABLE))
+		goto bottomup;
+#endif
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
+	/* requesting a specific address */
+	if (addr) {
+		addr = PAGE_ALIGN(addr);
+		vma = find_vma(mm, addr);
+		if (pax_task_size - len >= addr &&
+				(!vma || addr + len <= vma->vm_start))
+			return addr;
+	}
+
+	/* check if free_area_cache is useful for us */
+	if (len <= mm->cached_hole_size) {
+		mm->cached_hole_size = 0;
+		mm->free_area_cache = mm->mmap_base;
+	}
+
+	/* either no address requested or can't fit in requested address hole */
+	addr = mm->free_area_cache;
+
+	/* make sure it can fit in the remaining address space */
+	if (addr > len) {
+		vma = find_vma(mm, addr-len);
+		if (!vma || addr <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr-len);
+	}
+
+	if (mm->mmap_base < len)
+		goto bottomup;
+
+	addr = mm->mmap_base-len;
+
+	do {
+		/*
+		 * Lookup failure means no vma is above this address,
+		 * else if new region fits below vma->vm_start,
+		 * return with success:
+		 */
+		vma = find_vma(mm, addr);
+		if (!vma || addr+len <= vma->vm_start)
+			/* remember the address as a hint for next time */
+			return (mm->free_area_cache = addr);
+
+		/* remember the largest hole we saw so far */
+		if (addr + mm->cached_hole_size < vma->vm_start)
+			mm->cached_hole_size = vma->vm_start - addr;
+
+		/* try just below the current vma->vm_start */
+		addr = vma->vm_start-len;
+	} while (len < vma->vm_start);
+
+bottomup:
+	/*
+	 * A failed mmap() very likely causes application failure,
+	 * so fall back to the bottom-up function here. This scenario
+	 * can happen with large stack limits and large mmap()
+	 * allocations.
+	 */
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		mm->mmap_base = SEGMEXEC_TASK_UNMAPPED_BASE;
+	else
+#endif
+
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
+	mm->cached_hole_size = ~0UL;
+	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
+	/*
+	 * Restore the topdown base:
+	 */
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
+	mm->cached_hole_size = ~0UL;
+
+	return addr;
+}
 
 struct sel_arg_struct {
 	unsigned long n;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/sys_x86_64.c linux-2.6.26.8-pax/arch/x86/kernel/sys_x86_64.c
--- linux-2.6.26.8/arch/x86/kernel/sys_x86_64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/sys_x86_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -45,8 +45,8 @@ out:
 	return error;
 }
 
-static void find_start_end(unsigned long flags, unsigned long *begin,
-			   unsigned long *end)
+static void find_start_end(struct mm_struct *mm, unsigned long flags,
+			   unsigned long *begin, unsigned long *end)
 {
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT)) {
 		unsigned long new_begin;
@@ -65,7 +65,7 @@ static void find_start_end(unsigned long
 				*begin = new_begin;
 		}
 	} else {
-		*begin = TASK_UNMAPPED_BASE;
+		*begin = mm->mmap_base;
 		*end = TASK_SIZE; 
 	}
 } 
@@ -82,11 +82,15 @@ arch_get_unmapped_area(struct file *filp
 	if (flags & MAP_FIXED)
 		return addr;
 
-	find_start_end(flags, &begin, &end); 
+	find_start_end(mm, flags, &begin, &end);
 
 	if (len > end)
 		return -ENOMEM;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP) || !filp)
+#endif
+
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
@@ -141,7 +145,7 @@ arch_get_unmapped_area_topdown(struct fi
 {
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
-	unsigned long addr = addr0;
+	unsigned long base = mm->mmap_base, addr = addr0;
 
 	/* requested length too big for entire address space */
 	if (len > TASK_SIZE)
@@ -154,6 +158,10 @@ arch_get_unmapped_area_topdown(struct fi
 	if (!test_thread_flag(TIF_IA32) && (flags & MAP_32BIT))
 		goto bottomup;
 
+#ifdef CONFIG_PAX_RANDMMAP
+	if (!(mm->pax_flags & MF_PAX_RANDMMAP))
+#endif
+
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
@@ -211,13 +219,21 @@ bottomup:
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
 	addr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);
 	/*
 	 * Restore the topdown base:
 	 */
-	mm->free_area_cache = mm->mmap_base;
+	mm->mmap_base = base;
+	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
 	return addr;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/syscall_table_32.S linux-2.6.26.8-pax/arch/x86/kernel/syscall_table_32.S
--- linux-2.6.26.8/arch/x86/kernel/syscall_table_32.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/syscall_table_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -1,3 +1,4 @@
+.section .rodata,"a",@progbits
 ENTRY(sys_call_table)
 	.long sys_restart_syscall	/* 0 - old "setup()" system call, used for restarting */
 	.long sys_exit
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/time_32.c linux-2.6.26.8-pax/arch/x86/kernel/time_32.c
--- linux-2.6.26.8/arch/x86/kernel/time_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/time_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -52,20 +52,30 @@ unsigned long profile_pc(struct pt_regs 
 	if (!v8086_mode(regs) && SEGMENT_IS_KERNEL_CODE(regs->cs) &&
 	    in_lock_functions(pc)) {
 #ifdef CONFIG_FRAME_POINTER
-		return *(unsigned long *)(regs->bp + 4);
+		return ktla_ktva(*(unsigned long *)(regs->bp + 4));
 #else
 		unsigned long *sp = (unsigned long *)&regs->sp;
 
 		/* Return address is either directly at stack pointer
 		   or above a saved flags. Eflags has bits 22-31 zero,
 		   kernel addresses don't. */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		return ktla_ktva(sp[0]);
+#else
 		if (sp[0] >> 22)
 			return sp[0];
 		if (sp[1] >> 22)
 			return sp[1];
 #endif
+
+#endif
 	}
 #endif
+
+	if (!v8086_mode(regs) && SEGMENT_IS_KERNEL_CODE(regs->cs))
+		pc = ktla_ktva(pc);
+
 	return pc;
 }
 EXPORT_SYMBOL(profile_pc);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/tlb_32.c linux-2.6.26.8-pax/arch/x86/kernel/tlb_32.c
--- linux-2.6.26.8/arch/x86/kernel/tlb_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/tlb_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -5,7 +5,7 @@
 #include <asm/tlbflush.h>
 
 DEFINE_PER_CPU(struct tlb_state, cpu_tlbstate)
-			____cacheline_aligned = { &init_mm, 0, };
+			____cacheline_aligned = { &init_mm, 0, {0} };
 
 /* must come after the send_IPI functions above for inlining */
 #include <mach_ipi.h>
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/tls.c linux-2.6.26.8-pax/arch/x86/kernel/tls.c
--- linux-2.6.26.8/arch/x86/kernel/tls.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/tls.c	2008-07-14 03:52:23.000000000 +0200
@@ -84,6 +84,11 @@ int do_set_thread_area(struct task_struc
 	if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
 		return -EINVAL;
 
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((p->mm->pax_flags & MF_PAX_SEGMEXEC) && (info.contents & MODIFY_LDT_CONTENTS_CODE))
+		return -EINVAL;
+#endif
+
 	set_tls_desc(p, idx, &info, 1);
 
 	return 0;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/traps_32.c linux-2.6.26.8-pax/arch/x86/kernel/traps_32.c
--- linux-2.6.26.8/arch/x86/kernel/traps_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/traps_32.c	2008-09-21 22:00:23.000000000 +0200
@@ -70,14 +70,6 @@ asmlinkage int system_call(void);
 /* Do we ignore FPU interrupts ? */
 char ignore_fpu_irq;
 
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.. We have a special link segment
- * for this.
- */
-gate_desc idt_table[256]
-	__attribute__((__section__(".data.idt"))) = { { { { 0, 0 } } }, };
-
 asmlinkage void divide_error(void);
 asmlinkage void debug(void);
 asmlinkage void nmi(void);
@@ -339,22 +331,23 @@ void show_registers(struct pt_regs *regs
 	 * When in-kernel, we also print out the stack and code at the
 	 * time of the fault..
 	 */
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		unsigned int code_prologue = code_bytes * 43 / 64;
 		unsigned int code_len = code_bytes;
 		unsigned char c;
 		u8 *ip;
+		unsigned long cs_base = get_desc_base(&get_cpu_gdt_table(smp_processor_id())[(0xffff & regs->cs) >> 3]);
 
 		printk("\n" KERN_EMERG "Stack: ");
 		show_stack_log_lvl(NULL, regs, &regs->sp, 0, KERN_EMERG);
 
 		printk(KERN_EMERG "Code: ");
 
-		ip = (u8 *)regs->ip - code_prologue;
+		ip = (u8 *)regs->ip - code_prologue + cs_base;
 		if (ip < (u8 *)PAGE_OFFSET ||
 			probe_kernel_address(ip, c)) {
 			/* try starting at EIP */
-			ip = (u8 *)regs->ip;
+			ip = (u8 *)regs->ip + cs_base;
 			code_len = code_len - code_prologue + 1;
 		}
 		for (i = 0; i < code_len; i++, ip++) {
@@ -363,7 +356,7 @@ void show_registers(struct pt_regs *regs
 				printk(" Bad EIP value.");
 				break;
 			}
-			if (ip == (u8 *)regs->ip)
+			if (ip == (u8 *)regs->ip + cs_base)
 				printk("<%02x> ", c);
 			else
 				printk("%02x ", c);
@@ -376,6 +369,7 @@ int is_valid_bugaddr(unsigned long ip)
 {
 	unsigned short ud2;
 
+	ip = ktla_ktva(ip);
 	if (ip < PAGE_OFFSET)
 		return 0;
 	if (probe_kernel_address((unsigned short *)ip, ud2))
@@ -488,7 +482,7 @@ void die(const char *str, struct pt_regs
 static inline void
 die_if_kernel(const char *str, struct pt_regs *regs, long err)
 {
-	if (!user_mode_vm(regs))
+	if (!user_mode(regs))
 		die(str, regs, err);
 }
 
@@ -498,7 +492,7 @@ do_trap(int trapnr, int signr, char *str
 {
 	struct task_struct *tsk = current;
 
-	if (regs->flags & X86_VM_MASK) {
+	if (v8086_mode(regs)) {
 		if (vm86)
 			goto vm86_trap;
 		goto trap_signal;
@@ -532,6 +526,12 @@ kernel_trap:
 		tsk->thread.trap_no = trapnr;
 		die(str, regs, error_code);
 	}
+
+#ifdef CONFIG_PAX_REFCOUNT
+	if (trapnr == 4)
+		pax_report_refcount_overflow(regs);
+#endif
+
 	return;
 
 vm86_trap:
@@ -612,7 +612,7 @@ void __kprobes do_general_protection(str
 	int cpu;
 
 	cpu = get_cpu();
-	tss = &per_cpu(init_tss, cpu);
+	tss = init_tss + cpu;
 	thread = &current->thread;
 
 	/*
@@ -644,12 +644,28 @@ void __kprobes do_general_protection(str
 	}
 	put_cpu();
 
-	if (regs->flags & X86_VM_MASK)
+	if (v8086_mode(regs))
 		goto gp_in_vm86;
 
-	if (!user_mode(regs))
+	if (!user_mode_novm(regs))
 		goto gp_in_kernel;
 
+#ifdef CONFIG_PAX_PAGEEXEC
+	if (!nx_enabled && current->mm && (current->mm->pax_flags & MF_PAX_PAGEEXEC)) {
+		struct mm_struct *mm = current->mm;
+		unsigned long limit;
+
+		down_write(&mm->mmap_sem);
+		limit = mm->context.user_cs_limit;
+		if (limit < TASK_SIZE) {
+			track_exec_limit(mm, limit, TASK_SIZE, VM_EXEC);
+			up_write(&mm->mmap_sem);
+			return;
+		}
+		up_write(&mm->mmap_sem);
+	}
+#endif
+
 	current->thread.error_code = error_code;
 	current->thread.trap_no = 13;
 
@@ -678,6 +694,13 @@ gp_in_kernel:
 		if (notify_die(DIE_GPF, "general protection fault", regs,
 				error_code, 13, SIGSEGV) == NOTIFY_STOP)
 			return;
+
+#ifdef CONFIG_PAX_KERNEXEC
+		if ((regs->cs & 0xFFFF) == __KERNEL_CS)
+			die("PAX: suspicious general protection fault", regs, error_code);
+		else
+#endif
+
 		die("general protection fault", regs, error_code);
 	}
 }
@@ -779,7 +802,7 @@ void notrace __kprobes die_nmi(struct pt
 	 * If we are in kernel we are probably nested up pretty bad
 	 * and might aswell get out now while we still can:
 	 */
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		current->thread.trap_no = 2;
 		crash_kexec(regs);
 	}
@@ -925,7 +948,7 @@ void __kprobes do_debug(struct pt_regs *
 			goto clear_dr7;
 	}
 
-	if (regs->flags & X86_VM_MASK)
+	if (v8086_mode(regs))
 		goto debug_vm86;
 
 	/* Save debug status register where ptrace can see it */
@@ -941,7 +964,7 @@ void __kprobes do_debug(struct pt_regs *
 		 * check for kernel mode by just checking the CPL
 		 * of CS.
 		 */
-		if (!user_mode(regs))
+		if (!user_mode_novm(regs))
 			goto clear_TF_reenable;
 	}
 
@@ -1097,7 +1120,7 @@ void do_simd_coprocessor_error(struct pt
 	 * Handle strange cache flush from user space exception
 	 * in all other cases.  This is undocumented behaviour.
 	 */
-	if (regs->flags & X86_VM_MASK) {
+	if (v8086_mode(regs)) {
 		handle_vm86_fault((struct kernel_vm86_regs *)regs, error_code);
 		return;
 	}
@@ -1117,19 +1140,14 @@ void do_spurious_interrupt_bug(struct pt
 
 unsigned long patch_espfix_desc(unsigned long uesp, unsigned long kesp)
 {
-	struct desc_struct *gdt = __get_cpu_var(gdt_page).gdt;
 	unsigned long base = (kesp - uesp) & -THREAD_SIZE;
 	unsigned long new_kesp = kesp - base;
 	unsigned long lim_pages = (new_kesp | (THREAD_SIZE - 1)) >> PAGE_SHIFT;
-	__u64 desc = *(__u64 *)&gdt[GDT_ENTRY_ESPFIX_SS];
+	struct desc_struct ss;
 
 	/* Set up base for espfix segment */
-	desc &= 0x00f0ff0000000000ULL;
-	desc |=	((((__u64)base) << 16) & 0x000000ffffff0000ULL) |
-		((((__u64)base) << 32) & 0xff00000000000000ULL) |
-		((((__u64)lim_pages) << 32) & 0x000f000000000000ULL) |
-		(lim_pages & 0xffff);
-	*(__u64 *)&gdt[GDT_ENTRY_ESPFIX_SS] = desc;
+	pack_descriptor(&ss, base, lim_pages, 0x93, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(smp_processor_id()), GDT_ENTRY_ESPFIX_SS, &ss, DESCTYPE_S);
 
 	return new_kesp;
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/traps_64.c linux-2.6.26.8-pax/arch/x86/kernel/traps_64.c
--- linux-2.6.26.8/arch/x86/kernel/traps_64.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/traps_64.c	2008-10-09 04:13:06.000000000 +0200
@@ -669,6 +669,12 @@ static void __kprobes do_trap(int trapnr
 		tsk->thread.trap_no = trapnr;
 		die(str, regs, error_code);
 	}
+
+#ifdef CONFIG_PAX_REFCOUNT
+	if (trapnr == 4)
+		pax_report_refcount_overflow(regs);
+#endif
+
 	return;
 }
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/tsc_32.c linux-2.6.26.8-pax/arch/x86/kernel/tsc_32.c
--- linux-2.6.26.8/arch/x86/kernel/tsc_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/tsc_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -353,7 +353,7 @@ static struct dmi_system_id __initdata b
 		     DMI_MATCH(DMI_BOARD_NAME, "2635FA0"),
 		     },
 	 },
-	 {}
+	{ NULL, NULL, {{0, NULL}}, NULL}
 };
 
 /*
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/vm86_32.c linux-2.6.26.8-pax/arch/x86/kernel/vm86_32.c
--- linux-2.6.26.8/arch/x86/kernel/vm86_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/vm86_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -147,7 +147,7 @@ struct pt_regs *save_v86_state(struct ke
 		do_exit(SIGSEGV);
 	}
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	current->thread.sp0 = current->thread.saved_sp0;
 	current->thread.sysenter_cs = __KERNEL_CS;
 	load_sp0(tss, &current->thread);
@@ -324,7 +324,7 @@ static void do_sys_vm86(struct kernel_vm
 	tsk->thread.saved_fs = info->regs32->fs;
 	savesegment(gs, tsk->thread.saved_gs);
 
-	tss = &per_cpu(init_tss, get_cpu());
+	tss = init_tss + get_cpu();
 	tsk->thread.sp0 = (unsigned long) &info->VM86_TSS_ESP0;
 	if (cpu_has_sep)
 		tsk->thread.sysenter_cs = 0;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/vmi_32.c linux-2.6.26.8-pax/arch/x86/kernel/vmi_32.c
--- linux-2.6.26.8/arch/x86/kernel/vmi_32.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/vmi_32.c	2008-10-09 04:13:06.000000000 +0200
@@ -101,18 +101,43 @@ static unsigned patch_internal(int call,
 {
 	u64 reloc;
 	struct vmi_relocation_info *const rel = (struct vmi_relocation_info *)&reloc;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	reloc = call_vrom_long_func(vmi_rom, get_reloc,	call);
 	switch(rel->type) {
 		case VMI_RELOCATION_CALL_REL:
 			BUG_ON(len < 5);
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(char *)insnbuf = MNEM_CALL;
 			patch_offset(insnbuf, ip, (unsigned long)rel->eip);
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			return 5;
 
 		case VMI_RELOCATION_JUMP_REL:
 			BUG_ON(len < 5);
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_open_kernel(cr0);
+#endif
+
 			*(char *)insnbuf = MNEM_JMP;
 			patch_offset(insnbuf, ip, (unsigned long)rel->eip);
+
+#ifdef CONFIG_PAX_KERNEXEC
+			pax_close_kernel(cr0);
+#endif
+
 			return 5;
 
 		case VMI_RELOCATION_NOP:
@@ -515,14 +540,14 @@ static void vmi_set_pud(pud_t *pudp, pud
 
 static void vmi_pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
-	const pte_t pte = { .pte = 0 };
+	const pte_t pte = __pte(0ULL);
 	vmi_check_page_type(__pa(ptep) >> PAGE_SHIFT, VMI_PAGE_PTE);
 	vmi_ops.set_pte(pte, ptep, vmi_flags_addr(mm, addr, VMI_PAGE_PT, 0));
 }
 
 static void vmi_pmd_clear(pmd_t *pmd)
 {
-	const pte_t pte = { .pte = 0 };
+	const pte_t pte = __pte(0ULL);
 	vmi_check_page_type(__pa(pmd) >> PAGE_SHIFT, VMI_PAGE_PMD);
 	vmi_ops.set_pte(pte, (pte_t *)pmd, VMI_PAGE_PD);
 }
@@ -551,8 +576,8 @@ vmi_startup_ipi_hook(int phys_apicid, un
 	ap.ss = __KERNEL_DS;
 	ap.esp = (unsigned long) start_esp;
 
-	ap.ds = __USER_DS;
-	ap.es = __USER_DS;
+	ap.ds = __KERNEL_DS;
+	ap.es = __KERNEL_DS;
 	ap.fs = __KERNEL_PERCPU;
 	ap.gs = 0;
 
@@ -747,12 +772,20 @@ static inline int __init activate_vmi(vo
 	u64 reloc;
 	const struct vmi_relocation_info *rel = (struct vmi_relocation_info *)&reloc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	if (call_vrom_func(vmi_rom, vmi_init) != 0) {
 		printk(KERN_ERR "VMI ROM failed to initialize!");
 		return 0;
 	}
 	savesegment(cs, kernel_cs);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	pv_info.paravirt_enabled = 1;
 	pv_info.kernel_rpl = kernel_cs & SEGMENT_RPL_MASK;
 	pv_info.name = "vmi";
@@ -943,6 +976,10 @@ static inline int __init activate_vmi(vo
 
 	para_fill(pv_irq_ops.safe_halt, Halt);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/*
 	 * Alternative instruction rewriting doesn't happen soon enough
 	 * to convert VMI_IRET to a call instead of a jump; so we have
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/vmlinux_32.lds.S linux-2.6.26.8-pax/arch/x86/kernel/vmlinux_32.lds.S
--- linux-2.6.26.8/arch/x86/kernel/vmlinux_32.lds.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/vmlinux_32.lds.S	2008-07-14 03:52:23.000000000 +0200
@@ -15,6 +15,20 @@
 #include <asm/page.h>
 #include <asm/cache.h>
 #include <asm/boot.h>
+#include <asm/segment.h>
+
+#ifdef CONFIG_X86_PAE
+#define PMD_SHIFT 21
+#else
+#define PMD_SHIFT 22
+#endif
+#define PMD_SIZE (1 << PMD_SHIFT)
+
+#ifdef CONFIG_PAX_KERNEXEC
+#define __KERNEL_TEXT_OFFSET	(__PAGE_OFFSET + (((____LOAD_PHYSICAL_ADDR + 2*(PMD_SIZE - 1)) - 1) & ~(PMD_SIZE - 1)))
+#else
+#define __KERNEL_TEXT_OFFSET	0
+#endif
 
 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
 OUTPUT_ARCH(i386)
@@ -22,90 +36,23 @@ ENTRY(phys_startup_32)
 jiffies = jiffies_64;
 
 PHDRS {
-	text PT_LOAD FLAGS(5);	/* R_E */
-	data PT_LOAD FLAGS(7);	/* RWE */
-	note PT_NOTE FLAGS(0);	/* ___ */
+	initdata PT_LOAD FLAGS(6);	/* RW_ */
+	percpu   PT_LOAD FLAGS(6);	/* RW_ */
+	inittext PT_LOAD FLAGS(5);	/* R_E */
+	text     PT_LOAD FLAGS(5);	/* R_E */
+	rodata   PT_LOAD FLAGS(4);	/* R__ */
+	data     PT_LOAD FLAGS(6);	/* RW_ */
+	note     PT_NOTE FLAGS(0);	/* ___ */
 }
 SECTIONS
 {
-  . = LOAD_OFFSET + LOAD_PHYSICAL_ADDR;
-  phys_startup_32 = startup_32 - LOAD_OFFSET;
-
-  .text.head : AT(ADDR(.text.head) - LOAD_OFFSET) {
-  	_text = .;			/* Text and read-only data */
-	*(.text.head)
-  } :text = 0x9090
-
-  /* read-only */
-  .text : AT(ADDR(.text) - LOAD_OFFSET) {
-	. = ALIGN(PAGE_SIZE); /* not really needed, already page aligned */
-	*(.text.page_aligned)
-	TEXT_TEXT
-	SCHED_TEXT
-	LOCK_TEXT
-	KPROBES_TEXT
-	*(.fixup)
-	*(.gnu.warning)
-  	_etext = .;			/* End of text section */
-  } :text = 0x9090
-
-  . = ALIGN(16);		/* Exception table */
-  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
-  	__start___ex_table = .;
-	 *(__ex_table)
-  	__stop___ex_table = .;
-  }
-
-  NOTES :text :note
-
-  BUG_TABLE :text
-
-  . = ALIGN(4);
-  .tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {
-  	__tracedata_start = .;
-	*(.tracedata)
-  	__tracedata_end = .;
-  }
+  . = LOAD_OFFSET + ____LOAD_PHYSICAL_ADDR;
 
-  RODATA
-
-  /* writeable */
-  . = ALIGN(PAGE_SIZE);
-  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
-	DATA_DATA
-	CONSTRUCTORS
-	} :data
-
-  . = ALIGN(PAGE_SIZE);
-  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
-  	__nosave_begin = .;
-	*(.data.nosave)
-  	. = ALIGN(PAGE_SIZE);
-  	__nosave_end = .;
-  }
-
-  . = ALIGN(PAGE_SIZE);
-  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
-	*(.data.page_aligned)
-	*(.data.idt)
-  }
-
-  . = ALIGN(32);
-  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
-	*(.data.cacheline_aligned)
-  }
-
-  /* rarely changed data like cpu maps */
-  . = ALIGN(32);
-  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) {
-	*(.data.read_mostly)
-	_edata = .;		/* End of data section */
-  }
-
-  . = ALIGN(THREAD_SIZE);	/* init_task */
-  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
-	*(.data.init_task)
-  }
+  .text.startup : AT(ADDR(.text.startup) - LOAD_OFFSET) {
+	__LOAD_PHYSICAL_ADDR = . - LOAD_OFFSET;
+	phys_startup_32 = startup_32 - LOAD_OFFSET + __KERNEL_TEXT_OFFSET;
+	*(.text.startup)
+  } :initdata
 
   /* might get freed after init */
   . = ALIGN(PAGE_SIZE);
@@ -123,14 +70,8 @@ SECTIONS
   . = ALIGN(PAGE_SIZE);
 
   /* will be freed after init */
-  . = ALIGN(PAGE_SIZE);		/* Init code and data */
-  .init.text : AT(ADDR(.init.text) - LOAD_OFFSET) {
-  	__init_begin = .;
-	_sinittext = .;
-	INIT_TEXT
-	_einittext = .;
-  }
   .init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {
+	__init_begin = .;
 	INIT_DATA
   }
   . = ALIGN(16);
@@ -170,11 +111,6 @@ SECTIONS
 	*(.parainstructions)
   	__parainstructions_end = .;
   }
-  /* .exit.text is discard at runtime, not link time, to deal with references
-     from .altinstructions and .eh_frame */
-  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET) {
-	EXIT_TEXT
-  }
   .exit.data : AT(ADDR(.exit.data) - LOAD_OFFSET) {
 	EXIT_DATA
   }
@@ -187,17 +123,144 @@ SECTIONS
   }
 #endif
   . = ALIGN(PAGE_SIZE);
-  .data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) {
-	__per_cpu_start = .;
+  per_cpu_start = .;
+  .data.percpu (0) : AT(ADDR(.data.percpu) - LOAD_OFFSET + per_cpu_start) {
+	__per_cpu_start = . + per_cpu_start;
+	LONG(0)
 	*(.data.percpu)
 	*(.data.percpu.shared_aligned)
-	__per_cpu_end = .;
-  }
+	__per_cpu_end = . + per_cpu_start;
+  } :percpu
+  . += per_cpu_start;
   . = ALIGN(PAGE_SIZE);
   /* freed after init ends here */
 
+  . = ALIGN(PAGE_SIZE);		/* Init code and data */
+  .init.text (. - __KERNEL_TEXT_OFFSET) : AT(ADDR(.init.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	_sinittext = .;
+	INIT_TEXT
+	_einittext = .;
+  } :inittext
+
+  /* .exit.text is discard at runtime, not link time, to deal with references
+     from .altinstructions and .eh_frame */
+  .exit.text : AT(ADDR(.exit.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	EXIT_TEXT
+  }
+
+  .filler : AT(ADDR(.filler) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	BYTE(0)
+	. = ALIGN(2*PMD_SIZE) - 1;
+  }
+
+  /* freed after init ends here */
+
+  .text.head : AT(ADDR(.text.head) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	__init_end = . + __KERNEL_TEXT_OFFSET;
+	KERNEL_TEXT_OFFSET = . + __KERNEL_TEXT_OFFSET;
+	_text = .;			/* Text and read-only data */
+	*(.text.head)
+  } :text = 0x9090
+
+  /* read-only */
+  .text : AT(ADDR(.text) - LOAD_OFFSET + __KERNEL_TEXT_OFFSET) {
+	. = ALIGN(PAGE_SIZE); /* not really needed, already page aligned */
+	*(.text.page_aligned)
+	TEXT_TEXT
+	SCHED_TEXT
+	LOCK_TEXT
+	KPROBES_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+  	_etext = .;			/* End of text section */
+  } :text = 0x9090
+
+  . += __KERNEL_TEXT_OFFSET;
+  . = ALIGN(4096);		/* Exception table */
+  __ex_table : AT(ADDR(__ex_table) - LOAD_OFFSET) {
+  	__start___ex_table = .;
+	 *(__ex_table)
+  	__stop___ex_table = .;
+  } :rodata
+
+  NOTES :rodata :note
+
+  BUG_TABLE :rodata
+
+  . = ALIGN(4);
+  .tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {
+  	__tracedata_start = .;
+	*(.tracedata)
+  	__tracedata_end = .;
+  }
+
+  RO_DATA(PAGE_SIZE)
+
+  . = ALIGN(PAGE_SIZE);
+  .rodata.page_aligned : AT(ADDR(.rodata.page_aligned) - LOAD_OFFSET) {
+	*(.idt)
+	. = ALIGN(PAGE_SIZE);
+	*(.empty_zero_page)
+	*(.swapper_pg_pmd)
+	*(.swapper_pg_dir)
+	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+
+#ifdef CONFIG_MODULES
+  . = ALIGN(PAGE_SIZE);
+  .module.text : AT(ADDR(.module.text) - LOAD_OFFSET) {
+	MODULES_VADDR = .;
+	BYTE(0)
+	. += (6 * 1024 * 1024);
+	. = ALIGN( PMD_SIZE) - 1;
+	MODULES_END = .;
+  }
+#else
+  . = ALIGN(PMD_SIZE) - 1;
+#endif
+
+#endif
+
+  /* writeable */
+  . = ALIGN(PAGE_SIZE);
+  .data : AT(ADDR(.data) - LOAD_OFFSET) {	/* Data */
+	_data = .;
+	DATA_DATA
+	CONSTRUCTORS
+	} :data
+
+  . = ALIGN(PAGE_SIZE);
+  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) {
+  	__nosave_begin = .;
+	*(.data.nosave)
+  	. = ALIGN(PAGE_SIZE);
+  	__nosave_end = .;
+  }
+
+  . = ALIGN(PAGE_SIZE);
+  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
+	*(.data.page_aligned)
+  }
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
+	*(.data.cacheline_aligned)
+  }
+
+  /* rarely changed data like cpu maps */
+  . = ALIGN(32);
+  .data.read_mostly : AT(ADDR(.data.read_mostly) - LOAD_OFFSET) {
+	*(.data.read_mostly)
+	_edata = .;		/* End of data section */
+  }
+
+  . = ALIGN(THREAD_SIZE);	/* init_task */
+  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
+	*(.data.init_task)
+  }
+
   .bss : AT(ADDR(.bss) - LOAD_OFFSET) {
-	__init_end = .;
 	__bss_start = .;		/* BSS */
 	*(.bss.page_aligned)
 	*(.bss)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/vmlinux_64.lds.S linux-2.6.26.8-pax/arch/x86/kernel/vmlinux_64.lds.S
--- linux-2.6.26.8/arch/x86/kernel/vmlinux_64.lds.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/vmlinux_64.lds.S	2008-07-25 04:02:12.000000000 +0200
@@ -16,8 +16,8 @@ jiffies_64 = jiffies;
 _proxy_pda = 1;
 PHDRS {
 	text PT_LOAD FLAGS(5);	/* R_E */
-	data PT_LOAD FLAGS(7);	/* RWE */
-	user PT_LOAD FLAGS(7);	/* RWE */
+	data PT_LOAD FLAGS(6);	/* RW_ */
+	user PT_LOAD FLAGS(7);	/* RWX */
 	data.init PT_LOAD FLAGS(7);	/* RWE */
 	note PT_NOTE FLAGS(4);	/* R__ */
 }
@@ -51,7 +51,7 @@ SECTIONS
 
   BUG_TABLE :text
 
-  RODATA
+  RO_DATA(PAGE_SIZE)
 
   . = ALIGN(4);
   .tracedata : AT(ADDR(.tracedata) - LOAD_OFFSET) {
@@ -60,15 +60,18 @@ SECTIONS
   	__tracedata_end = .;
   }
 
+#ifdef CONFIG_PAX_KERNEXEC
+  . = ALIGN(2*1024*1024);	/* Align data segment to PMD size boundary */
+#else
   . = ALIGN(PAGE_SIZE);		/* Align data segment to page size boundary */
+#endif
 				/* Data */
+  _data = .;
   .data : AT(ADDR(.data) - LOAD_OFFSET) {
 	DATA_DATA
 	CONSTRUCTORS
 	} :data
 
-  _edata = .;			/* End of data section */
-
   . = ALIGN(PAGE_SIZE);
   . = ALIGN(CONFIG_X86_L1_CACHE_BYTES);
   .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - LOAD_OFFSET) {
@@ -79,9 +82,27 @@ SECTIONS
   	*(.data.read_mostly)
   }
 
+  . = ALIGN(THREAD_SIZE);	/* init_task */
+  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
+	*(.data.init_task)
+  }
+
+  . = ALIGN(PAGE_SIZE);
+  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
+	*(.data.page_aligned)
+  }
+
+  . = ALIGN(PAGE_SIZE);
+  __nosave_begin = .;
+  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) { *(.data.nosave) }
+  . = ALIGN(PAGE_SIZE);
+  __nosave_end = .;
+
+  _edata = .;			/* End of data section */
+
 #define VSYSCALL_ADDR (-10*1024*1024)
-#define VSYSCALL_PHYS_ADDR ((LOADADDR(.data.read_mostly) + SIZEOF(.data.read_mostly) + 4095) & ~(4095))
-#define VSYSCALL_VIRT_ADDR ((ADDR(.data.read_mostly) + SIZEOF(.data.read_mostly) + 4095) & ~(4095))
+#define VSYSCALL_PHYS_ADDR ((LOADADDR(.data_nosave) + SIZEOF(.data_nosave) + 4095) & ~(4095))
+#define VSYSCALL_VIRT_ADDR ((ADDR(.data_nosave) + SIZEOF(.data_nosave) + 4095) & ~(4095))
 
 #define VLOAD_OFFSET (VSYSCALL_ADDR - VSYSCALL_PHYS_ADDR)
 #define VLOAD(x) (ADDR(x) - VLOAD_OFFSET)
@@ -129,23 +150,13 @@ SECTIONS
 #undef VVIRT_OFFSET
 #undef VVIRT
 
-  . = ALIGN(THREAD_SIZE);	/* init_task */
-  .data.init_task : AT(ADDR(.data.init_task) - LOAD_OFFSET) {
-	*(.data.init_task)
-  }:data.init
-
-  . = ALIGN(PAGE_SIZE);
-  .data.page_aligned : AT(ADDR(.data.page_aligned) - LOAD_OFFSET) {
-	*(.data.page_aligned)
-  }
-
   /* might get freed after init */
   . = ALIGN(PAGE_SIZE);
   __smp_alt_begin = .;
   __smp_locks = .;
   .smp_locks : AT(ADDR(.smp_locks) - LOAD_OFFSET) {
 	*(.smp_locks)
-  }
+  } :data.init
   __smp_locks_end = .;
   . = ALIGN(PAGE_SIZE);
   __smp_alt_end = .;
@@ -221,12 +232,6 @@ SECTIONS
   . = ALIGN(PAGE_SIZE);
   __init_end = .;
 
-  . = ALIGN(PAGE_SIZE);
-  __nosave_begin = .;
-  .data_nosave : AT(ADDR(.data_nosave) - LOAD_OFFSET) { *(.data.nosave) }
-  . = ALIGN(PAGE_SIZE);
-  __nosave_end = .;
-
   __bss_start = .;		/* BSS */
   .bss : AT(ADDR(.bss) - LOAD_OFFSET) {
 	*(.bss.page_aligned)
@@ -234,6 +239,7 @@ SECTIONS
 	}
   __bss_stop = .;
 
+  . = ALIGN(2*1024*1024);
   _end = . ;
 
   /* Sections to be discarded */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/vsyscall_64.c linux-2.6.26.8-pax/arch/x86/kernel/vsyscall_64.c
--- linux-2.6.26.8/arch/x86/kernel/vsyscall_64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/vsyscall_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -235,13 +235,13 @@ static ctl_table kernel_table2[] = {
 	  .data = &vsyscall_gtod_data.sysctl_enabled, .maxlen = sizeof(int),
 	  .mode = 0644,
 	  .proc_handler = vsyscall_sysctl_change },
-	{}
+	{ 0, NULL, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
 static ctl_table kernel_root_table2[] = {
 	{ .ctl_name = CTL_KERN, .procname = "kernel", .mode = 0555,
 	  .child = kernel_table2 },
-	{}
+	{ 0, NULL, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL }
 };
 #endif
 
@@ -251,6 +251,11 @@ static void __cpuinit vsyscall_set_cpu(i
 {
 	unsigned long *d;
 	unsigned long node = 0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 #ifdef CONFIG_NUMA
 	node = cpu_to_node(cpu);
 #endif
@@ -261,10 +266,20 @@ static void __cpuinit vsyscall_set_cpu(i
 	   in user space in vgetcpu.
 	   12 bits for the CPU and 8 bits for the node. */
 	d = (unsigned long *)(get_cpu_gdt_table(cpu) + GDT_ENTRY_PER_CPU);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	*d = 0x0f40000000000ULL;
 	*d |= cpu;
 	*d |= (node & 0xf) << 12;
 	*d |= (node >> 4) << 48;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
 
 static void __cpuinit cpu_vsyscall_init(void *arg)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kernel/x8664_ksyms_64.c linux-2.6.26.8-pax/arch/x86/kernel/x8664_ksyms_64.c
--- linux-2.6.26.8/arch/x86/kernel/x8664_ksyms_64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kernel/x8664_ksyms_64.c	2008-08-09 22:58:01.000000000 +0200
@@ -53,8 +53,3 @@ EXPORT_SYMBOL(init_level4_pgt);
 EXPORT_SYMBOL(load_gs_index);
 
 EXPORT_SYMBOL(_proxy_pda);
-
-#ifdef CONFIG_PARAVIRT
-/* Virtualized guests may want to use it */
-EXPORT_SYMBOL_GPL(cpu_gdt_descr);
-#endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kvm/i8254.c linux-2.6.26.8-pax/arch/x86/kvm/i8254.c
--- linux-2.6.26.8/arch/x86/kvm/i8254.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kvm/i8254.c	2008-10-09 23:32:08.000000000 +0200
@@ -91,7 +91,7 @@ static void pit_set_gate(struct kvm *kvm
 	c->gate = val;
 }
 
-int pit_get_gate(struct kvm *kvm, int channel)
+static int pit_get_gate(struct kvm *kvm, int channel)
 {
 	WARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));
 
@@ -193,7 +193,7 @@ static void pit_latch_status(struct kvm 
 	}
 }
 
-int __pit_timer_fn(struct kvm_kpit_state *ps)
+static int __pit_timer_fn(struct kvm_kpit_state *ps)
 {
 	struct kvm_vcpu *vcpu0 = ps->pit->kvm->vcpus[0];
 	struct kvm_kpit_timer *pt = &ps->pit_timer;
@@ -575,7 +575,7 @@ void kvm_free_pit(struct kvm *kvm)
 	}
 }
 
-void __inject_pit_timer_intr(struct kvm *kvm)
+static void __inject_pit_timer_intr(struct kvm *kvm)
 {
 	mutex_lock(&kvm->lock);
 	kvm_ioapic_set_irq(kvm->arch.vioapic, 0, 1);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kvm/mmu.c linux-2.6.26.8-pax/arch/x86/kvm/mmu.c
--- linux-2.6.26.8/arch/x86/kvm/mmu.c	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kvm/mmu.c	2008-10-09 23:30:00.000000000 +0200
@@ -1950,7 +1950,7 @@ void kvm_mmu_zap_all(struct kvm *kvm)
 	kvm_flush_remote_tlbs(kvm);
 }
 
-void kvm_mmu_remove_one_alloc_mmu_page(struct kvm *kvm)
+static void kvm_mmu_remove_one_alloc_mmu_page(struct kvm *kvm)
 {
 	struct kvm_mmu_page *page;
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kvm/svm.c linux-2.6.26.8-pax/arch/x86/kvm/svm.c
--- linux-2.6.26.8/arch/x86/kvm/svm.c	2008-10-09 04:12:33.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kvm/svm.c	2008-10-09 04:13:06.000000000 +0200
@@ -1478,7 +1478,19 @@ static void reload_tss(struct kvm_vcpu *
 	int cpu = raw_smp_processor_id();
 
 	struct svm_cpu_data *svm_data = per_cpu(svm_data, cpu);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	svm_data->tss_desc->type = 9; /* available 32/64-bit TSS */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	load_TR_desc();
 }
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kvm/vmx.c linux-2.6.26.8-pax/arch/x86/kvm/vmx.c
--- linux-2.6.26.8/arch/x86/kvm/vmx.c	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kvm/vmx.c	2008-10-09 23:27:32.000000000 +0200
@@ -111,7 +111,7 @@ static struct vmcs_config {
 	u32 vmentry_ctrl;
 } vmcs_config;
 
-struct vmx_capability {
+static struct vmx_capability {
 	u32 ept;
 	u32 vpid;
 } vmx_capability;
@@ -475,9 +475,23 @@ static void reload_tss(void)
 	struct descriptor_table gdt;
 	struct desc_struct *descs;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	get_gdt(&gdt);
 	descs = (void *)gdt.base;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	descs[GDT_ENTRY_TSS].type = 9; /* available TSS */
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	load_TR_desc();
 }
 
@@ -1824,7 +1838,7 @@ static void allocate_vpid(struct vcpu_vm
 	spin_unlock(&vmx_vpid_lock);
 }
 
-void vmx_disable_intercept_for_msr(struct page *msr_bitmap, u32 msr)
+static void vmx_disable_intercept_for_msr(struct page *msr_bitmap, u32 msr)
 {
 	void *va;
 
@@ -2956,7 +2970,7 @@ static void vmx_vcpu_run(struct kvm_vcpu
 	vcpu->arch.interrupt_window_open =
 		(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & 3) == 0;
 
-	asm("mov %0, %%ds; mov %0, %%es" : : "r"(__USER_DS));
+	asm("mov %0, %%ds; mov %0, %%es" : : "r"(__KERNEL_DS));
 	vmx->launched = 1;
 
 	intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/kvm/x86.c linux-2.6.26.8-pax/arch/x86/kvm/x86.c
--- linux-2.6.26.8/arch/x86/kvm/x86.c	2008-08-21 22:47:09.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/kvm/x86.c	2008-10-09 23:29:46.000000000 +0200
@@ -63,34 +63,34 @@ static int kvm_dev_ioctl_get_supported_c
 struct kvm_x86_ops *kvm_x86_ops;
 
 struct kvm_stats_debugfs_item debugfs_entries[] = {
-	{ "pf_fixed", VCPU_STAT(pf_fixed) },
-	{ "pf_guest", VCPU_STAT(pf_guest) },
-	{ "tlb_flush", VCPU_STAT(tlb_flush) },
-	{ "invlpg", VCPU_STAT(invlpg) },
-	{ "exits", VCPU_STAT(exits) },
-	{ "io_exits", VCPU_STAT(io_exits) },
-	{ "mmio_exits", VCPU_STAT(mmio_exits) },
-	{ "signal_exits", VCPU_STAT(signal_exits) },
-	{ "irq_window", VCPU_STAT(irq_window_exits) },
-	{ "halt_exits", VCPU_STAT(halt_exits) },
-	{ "halt_wakeup", VCPU_STAT(halt_wakeup) },
-	{ "hypercalls", VCPU_STAT(hypercalls) },
-	{ "request_irq", VCPU_STAT(request_irq_exits) },
-	{ "irq_exits", VCPU_STAT(irq_exits) },
-	{ "host_state_reload", VCPU_STAT(host_state_reload) },
-	{ "efer_reload", VCPU_STAT(efer_reload) },
-	{ "fpu_reload", VCPU_STAT(fpu_reload) },
-	{ "insn_emulation", VCPU_STAT(insn_emulation) },
-	{ "insn_emulation_fail", VCPU_STAT(insn_emulation_fail) },
-	{ "mmu_shadow_zapped", VM_STAT(mmu_shadow_zapped) },
-	{ "mmu_pte_write", VM_STAT(mmu_pte_write) },
-	{ "mmu_pte_updated", VM_STAT(mmu_pte_updated) },
-	{ "mmu_pde_zapped", VM_STAT(mmu_pde_zapped) },
-	{ "mmu_flooded", VM_STAT(mmu_flooded) },
-	{ "mmu_recycled", VM_STAT(mmu_recycled) },
-	{ "mmu_cache_miss", VM_STAT(mmu_cache_miss) },
-	{ "remote_tlb_flush", VM_STAT(remote_tlb_flush) },
-	{ "largepages", VM_STAT(lpages) },
+	{ "pf_fixed", VCPU_STAT(pf_fixed), NULL },
+	{ "pf_guest", VCPU_STAT(pf_guest), NULL },
+	{ "tlb_flush", VCPU_STAT(tlb_flush), NULL },
+	{ "invlpg", VCPU_STAT(invlpg), NULL },
+	{ "exits", VCPU_STAT(exits), NULL },
+	{ "io_exits", VCPU_STAT(io_exits), NULL },
+	{ "mmio_exits", VCPU_STAT(mmio_exits), NULL },
+	{ "signal_exits", VCPU_STAT(signal_exits), NULL },
+	{ "irq_window", VCPU_STAT(irq_window_exits), NULL },
+	{ "halt_exits", VCPU_STAT(halt_exits), NULL },
+	{ "halt_wakeup", VCPU_STAT(halt_wakeup), NULL },
+	{ "hypercalls", VCPU_STAT(hypercalls), NULL },
+	{ "request_irq", VCPU_STAT(request_irq_exits), NULL },
+	{ "irq_exits", VCPU_STAT(irq_exits), NULL },
+	{ "host_state_reload", VCPU_STAT(host_state_reload), NULL },
+	{ "efer_reload", VCPU_STAT(efer_reload), NULL },
+	{ "fpu_reload", VCPU_STAT(fpu_reload), NULL },
+	{ "insn_emulation", VCPU_STAT(insn_emulation), NULL },
+	{ "insn_emulation_fail", VCPU_STAT(insn_emulation_fail), NULL },
+	{ "mmu_shadow_zapped", VM_STAT(mmu_shadow_zapped), NULL },
+	{ "mmu_pte_write", VM_STAT(mmu_pte_write), NULL },
+	{ "mmu_pte_updated", VM_STAT(mmu_pte_updated), NULL },
+	{ "mmu_pde_zapped", VM_STAT(mmu_pde_zapped), NULL },
+	{ "mmu_flooded", VM_STAT(mmu_flooded), NULL },
+	{ "mmu_recycled", VM_STAT(mmu_recycled), NULL },
+	{ "mmu_cache_miss", VM_STAT(mmu_cache_miss), NULL },
+	{ "remote_tlb_flush", VM_STAT(remote_tlb_flush), NULL },
+	{ "largepages", VM_STAT(lpages), NULL },
 	{ NULL }
 };
 
@@ -1254,7 +1254,7 @@ static int kvm_vcpu_ioctl_set_lapic(stru
 static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
 				    struct kvm_interrupt *irq)
 {
-	if (irq->irq < 0 || irq->irq >= 256)
+	if (irq->irq >= 256)
 		return -EINVAL;
 	if (irqchip_in_kernel(vcpu->kvm))
 		return -ENXIO;
@@ -3411,7 +3411,7 @@ static int load_state_from_tss16(struct 
 	return 0;
 }
 
-int kvm_task_switch_16(struct kvm_vcpu *vcpu, u16 tss_selector,
+static int kvm_task_switch_16(struct kvm_vcpu *vcpu, u16 tss_selector,
 		       u32 old_tss_base,
 		       struct desc_struct *nseg_desc)
 {
@@ -3440,7 +3440,7 @@ out:
 	return ret;
 }
 
-int kvm_task_switch_32(struct kvm_vcpu *vcpu, u16 tss_selector,
+static int kvm_task_switch_32(struct kvm_vcpu *vcpu, u16 tss_selector,
 		       u32 old_tss_base,
 		       struct desc_struct *nseg_desc)
 {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/checksum_32.S linux-2.6.26.8-pax/arch/x86/lib/checksum_32.S
--- linux-2.6.26.8/arch/x86/lib/checksum_32.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/checksum_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -28,7 +28,8 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
 #include <asm/errno.h>
-				
+#include <asm/segment.h>
+
 /*
  * computes a partial checksum, e.g. for TCP/UDP fragments
  */
@@ -304,9 +305,22 @@ unsigned int csum_partial_copy_generic (
 
 #define ARGBASE 16		
 #define FP		12
-		
-ENTRY(csum_partial_copy_generic)
+
+ENTRY(csum_partial_copy_generic_to_user)
 	CFI_STARTPROC
+	pushl $(__USER_DS)
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
+	jmp csum_partial_copy_generic
+
+ENTRY(csum_partial_copy_generic_from_user)
+	pushl $(__USER_DS)
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+
+ENTRY(csum_partial_copy_generic)
 	subl  $4,%esp	
 	CFI_ADJUST_CFA_OFFSET 4
 	pushl %edi
@@ -331,7 +345,7 @@ ENTRY(csum_partial_copy_generic)
 	jmp 4f
 SRC(1:	movw (%esi), %bx	)
 	addl $2, %esi
-DST(	movw %bx, (%edi)	)
+DST(	movw %bx, %es:(%edi)	)
 	addl $2, %edi
 	addw %bx, %ax	
 	adcl $0, %eax
@@ -343,30 +357,30 @@ DST(	movw %bx, (%edi)	)
 SRC(1:	movl (%esi), %ebx	)
 SRC(	movl 4(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 4(%edi)	)
+DST(	movl %edx, %es:4(%edi)	)
 
 SRC(	movl 8(%esi), %ebx	)
 SRC(	movl 12(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 8(%edi)	)
+DST(	movl %ebx, %es:8(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 12(%edi)	)
+DST(	movl %edx, %es:12(%edi)	)
 
 SRC(	movl 16(%esi), %ebx 	)
 SRC(	movl 20(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 16(%edi)	)
+DST(	movl %ebx, %es:16(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 20(%edi)	)
+DST(	movl %edx, %es:20(%edi)	)
 
 SRC(	movl 24(%esi), %ebx	)
 SRC(	movl 28(%esi), %edx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, 24(%edi)	)
+DST(	movl %ebx, %es:24(%edi)	)
 	adcl %edx, %eax
-DST(	movl %edx, 28(%edi)	)
+DST(	movl %edx, %es:28(%edi)	)
 
 	lea 32(%esi), %esi
 	lea 32(%edi), %edi
@@ -380,7 +394,7 @@ DST(	movl %edx, 28(%edi)	)
 	shrl $2, %edx			# This clears CF
 SRC(3:	movl (%esi), %ebx	)
 	adcl %ebx, %eax
-DST(	movl %ebx, (%edi)	)
+DST(	movl %ebx, %es:(%edi)	)
 	lea 4(%esi), %esi
 	lea 4(%edi), %edi
 	dec %edx
@@ -392,12 +406,12 @@ DST(	movl %ebx, (%edi)	)
 	jb 5f
 SRC(	movw (%esi), %cx	)
 	leal 2(%esi), %esi
-DST(	movw %cx, (%edi)	)
+DST(	movw %cx, %es:(%edi)	)
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%ecx
 SRC(5:	movb (%esi), %cl	)
-DST(	movb %cl, (%edi)	)
+DST(	movb %cl, %es:(%edi)	)
 6:	addl %ecx, %eax
 	adcl $0, %eax
 7:
@@ -408,7 +422,7 @@ DST(	movb %cl, (%edi)	)
 
 6001:
 	movl ARGBASE+20(%esp), %ebx	# src_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 
 	# zero the complete destination - computing the rest
 	# is too much work 
@@ -421,11 +435,19 @@ DST(	movb %cl, (%edi)	)
 
 6002:
 	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT,(%ebx)
+	movl $-EFAULT,%ss:(%ebx)
 	jmp 5000b
 
 .previous
 
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
 	popl %ebx
 	CFI_ADJUST_CFA_OFFSET -4
 	CFI_RESTORE ebx
@@ -439,26 +461,41 @@ DST(	movb %cl, (%edi)	)
 	CFI_ADJUST_CFA_OFFSET -4
 	ret	
 	CFI_ENDPROC
-ENDPROC(csum_partial_copy_generic)
+ENDPROC(csum_partial_copy_generic_to_user)
 
 #else
 
 /* Version for PentiumII/PPro */
 
 #define ROUND1(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	addl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	; 
+	DST(movl %ebx, %es:x(%edi))	;
 
 #define ROUND(x) \
+	nop; nop; nop;				\
 	SRC(movl x(%esi), %ebx	)	;	\
 	adcl %ebx, %eax			;	\
-	DST(movl %ebx, x(%edi)	)	;
+	DST(movl %ebx, %es:x(%edi))	;
 
 #define ARGBASE 12
-		
-ENTRY(csum_partial_copy_generic)
+
+ENTRY(csum_partial_copy_generic_to_user)
 	CFI_STARTPROC
+	pushl $(__USER_DS)
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
+	jmp csum_partial_copy_generic
+
+ENTRY(csum_partial_copy_generic_from_user)
+	pushl $(__USER_DS)
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+
+ENTRY(csum_partial_copy_generic)
 	pushl %ebx
 	CFI_ADJUST_CFA_OFFSET 4
 	CFI_REL_OFFSET ebx, 0
@@ -482,7 +519,7 @@ ENTRY(csum_partial_copy_generic)
 	subl %ebx, %edi  
 	lea  -1(%esi),%edx
 	andl $-32,%edx
-	lea 3f(%ebx,%ebx), %ebx
+	lea 3f(%ebx,%ebx,2), %ebx
 	testl %esi, %esi 
 	jmp *%ebx
 1:	addl $64,%esi
@@ -503,19 +540,19 @@ ENTRY(csum_partial_copy_generic)
 	jb 5f
 SRC(	movw (%esi), %dx         )
 	leal 2(%esi), %esi
-DST(	movw %dx, (%edi)         )
+DST(	movw %dx, %es:(%edi)     )
 	leal 2(%edi), %edi
 	je 6f
 	shll $16,%edx
 5:
 SRC(	movb (%esi), %dl         )
-DST(	movb %dl, (%edi)         )
+DST(	movb %dl, %es:(%edi)     )
 6:	addl %edx, %eax
 	adcl $0, %eax
 7:
 .section .fixup, "ax"
 6001:	movl	ARGBASE+20(%esp), %ebx	# src_err_ptr	
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	# zero the complete destination (computing the rest is too much work)
 	movl ARGBASE+8(%esp),%edi	# dst
 	movl ARGBASE+12(%esp),%ecx	# len
@@ -523,10 +560,18 @@ DST(	movb %dl, (%edi)         )
 	rep; stosb
 	jmp 7b
 6002:	movl ARGBASE+24(%esp), %ebx	# dst_err_ptr
-	movl $-EFAULT, (%ebx)
+	movl $-EFAULT, %ss:(%ebx)
 	jmp  7b			
 .previous				
 
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %es
+	CFI_ADJUST_CFA_OFFSET -4
 	popl %esi
 	CFI_ADJUST_CFA_OFFSET -4
 	CFI_RESTORE esi
@@ -538,7 +583,7 @@ DST(	movb %dl, (%edi)         )
 	CFI_RESTORE ebx
 	ret
 	CFI_ENDPROC
-ENDPROC(csum_partial_copy_generic)
+ENDPROC(csum_partial_copy_generic_to_user)
 				
 #undef ROUND
 #undef ROUND1		
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/clear_page_64.S linux-2.6.26.8-pax/arch/x86/lib/clear_page_64.S
--- linux-2.6.26.8/arch/x86/lib/clear_page_64.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/clear_page_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -44,7 +44,7 @@ ENDPROC(clear_page)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb					/* jmp <disp8> */
 	.byte (clear_page_c - clear_page) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/copy_page_64.S linux-2.6.26.8-pax/arch/x86/lib/copy_page_64.S
--- linux-2.6.26.8/arch/x86/lib/copy_page_64.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/copy_page_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -104,7 +104,7 @@ ENDPROC(copy_page)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb					/* jmp <disp8> */
 	.byte (copy_page_c - copy_page) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/copy_user_64.S linux-2.6.26.8-pax/arch/x86/lib/copy_user_64.S
--- linux-2.6.26.8/arch/x86/lib/copy_user_64.S	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/copy_user_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -19,7 +19,7 @@
 	.byte 0xe9	/* 32bit jump */
 	.long \orig-1f	/* by default jump to orig */
 1:
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 2:	.byte 0xe9	             /* near jump with 32bit immediate */
 	.long \alt-1b /* offset */   /* or alternatively to alt */
 	.previous
@@ -76,6 +76,8 @@ ENDPROC(copy_from_user)
 	/* must zero dest */
 bad_from_user:
 	CFI_STARTPROC
+	testl %edx,%edx
+	js bad_to_user
 	movl %edx,%ecx
 	xorl %eax,%eax
 	rep
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/getuser_32.S linux-2.6.26.8-pax/arch/x86/lib/getuser_32.S
--- linux-2.6.26.8/arch/x86/lib/getuser_32.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/getuser_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -11,7 +11,7 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
 #include <asm/thread_info.h>
-
+#include <asm/segment.h>
 
 /*
  * __get_user_X
@@ -31,7 +31,11 @@ ENTRY(__get_user_1)
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movzbl (%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 	CFI_ENDPROC
@@ -44,7 +48,11 @@ ENTRY(__get_user_2)
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movzwl -1(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 	CFI_ENDPROC
@@ -57,7 +65,11 @@ ENTRY(__get_user_4)
 	GET_THREAD_INFO(%edx)
 	cmpl TI_addr_limit(%edx),%eax
 	jae bad_get_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl -3(%eax),%edx
+	pushl %ss
+	pop %ds
 	xorl %eax,%eax
 	ret
 	CFI_ENDPROC
@@ -65,6 +77,8 @@ ENDPROC(__get_user_4)
 
 bad_get_user:
 	CFI_STARTPROC
+	pushl %ss
+	pop %ds
 	xorl %edx,%edx
 	movl $-14,%eax
 	ret
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/memcpy_64.S linux-2.6.26.8-pax/arch/x86/lib/memcpy_64.S
--- linux-2.6.26.8/arch/x86/lib/memcpy_64.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/memcpy_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -114,7 +114,7 @@ ENDPROC(__memcpy)
 	/* Some CPUs run faster using the string copy instructions.
 	   It is also a lot simpler. Use this when possible */
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb				/* jmp <disp8> */
 	.byte (memcpy_c - memcpy) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/memset_64.S linux-2.6.26.8-pax/arch/x86/lib/memset_64.S
--- linux-2.6.26.8/arch/x86/lib/memset_64.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/memset_64.S	2008-07-14 03:52:23.000000000 +0200
@@ -118,7 +118,7 @@ ENDPROC(__memset)
 
 #include <asm/cpufeature.h>
 
-	.section .altinstr_replacement,"ax"
+	.section .altinstr_replacement,"a"
 1:	.byte 0xeb				/* jmp <disp8> */
 	.byte (memset_c - memset) - (2f - 1b)	/* offset */
 2:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/mmx_32.c linux-2.6.26.8-pax/arch/x86/lib/mmx_32.c
--- linux-2.6.26.8/arch/x86/lib/mmx_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/mmx_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -29,6 +29,7 @@ void *_mmx_memcpy(void *to, const void *
 {
 	void *p;
 	int i;
+	unsigned long cr0;
 
 	if (unlikely(in_interrupt()))
 		return __memcpy(to, from, len);
@@ -39,44 +40,72 @@ void *_mmx_memcpy(void *to, const void *
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"		/* This set is 28 bytes */
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"		/* This set is 28 bytes */
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from));
+			: "=&r" (cr0) : "r" (from) : "ax");
 
 	for ( ; i > 5; i--) {
 		__asm__ __volatile__ (
-		"1:  prefetch 320(%0)\n"
-		"2:  movq (%0), %%mm0\n"
-		"  movq 8(%0), %%mm1\n"
-		"  movq 16(%0), %%mm2\n"
-		"  movq 24(%0), %%mm3\n"
-		"  movq %%mm0, (%1)\n"
-		"  movq %%mm1, 8(%1)\n"
-		"  movq %%mm2, 16(%1)\n"
-		"  movq %%mm3, 24(%1)\n"
-		"  movq 32(%0), %%mm0\n"
-		"  movq 40(%0), %%mm1\n"
-		"  movq 48(%0), %%mm2\n"
-		"  movq 56(%0), %%mm3\n"
-		"  movq %%mm0, 32(%1)\n"
-		"  movq %%mm1, 40(%1)\n"
-		"  movq %%mm2, 48(%1)\n"
-		"  movq %%mm3, 56(%1)\n"
+		"1:  prefetch 320(%1)\n"
+		"2:  movq (%1), %%mm0\n"
+		"  movq 8(%1), %%mm1\n"
+		"  movq 16(%1), %%mm2\n"
+		"  movq 24(%1), %%mm3\n"
+		"  movq %%mm0, (%2)\n"
+		"  movq %%mm1, 8(%2)\n"
+		"  movq %%mm2, 16(%2)\n"
+		"  movq %%mm3, 24(%2)\n"
+		"  movq 32(%1), %%mm0\n"
+		"  movq 40(%1), %%mm1\n"
+		"  movq 48(%1), %%mm2\n"
+		"  movq 56(%1), %%mm3\n"
+		"  movq %%mm0, 32(%2)\n"
+		"  movq %%mm1, 40(%2)\n"
+		"  movq %%mm2, 48(%2)\n"
+		"  movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from), "r" (to) : "memory");
+			: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
@@ -158,6 +187,7 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
@@ -166,42 +196,70 @@ static void fast_copy_page(void *to, voi
 	 * but that is for later. -AV
 	 */
 	__asm__ __volatile__(
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-			_ASM_EXTABLE(1b, 3b) : : "r" (from));
+			_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from) : "ax");
 
 	for (i = 0; i < (4096-320)/64; i++) {
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movntq %%mm0, (%1)\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movntq %%mm1, 8(%1)\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movntq %%mm2, 16(%1)\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movntq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm4\n"
-		"   movntq %%mm4, 32(%1)\n"
-		"   movq 40(%0), %%mm5\n"
-		"   movntq %%mm5, 40(%1)\n"
-		"   movq 48(%0), %%mm6\n"
-		"   movntq %%mm6, 48(%1)\n"
-		"   movq 56(%0), %%mm7\n"
-		"   movntq %%mm7, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movntq %%mm0, (%2)\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movntq %%mm1, 8(%2)\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movntq %%mm2, 16(%2)\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movntq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm4\n"
+		"   movntq %%mm4, 32(%2)\n"
+		"   movq 40(%1), %%mm5\n"
+		"   movntq %%mm5, 40(%2)\n"
+		"   movq 48(%1), %%mm6\n"
+		"   movntq %%mm6, 48(%2)\n"
+		"   movq 56(%1), %%mm7\n"
+		"   movntq %%mm7, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-		_ASM_EXTABLE(1b, 3b) : : "r" (from), "r" (to) : "memory");
+		_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
@@ -280,47 +338,76 @@ static void fast_clear_page(void *page)
 static void fast_copy_page(void *to, void *from)
 {
 	int i;
+	unsigned long cr0;
 
 	kernel_fpu_begin();
 
 	__asm__ __volatile__ (
-		"1: prefetch (%0)\n"
-		"   prefetch 64(%0)\n"
-		"   prefetch 128(%0)\n"
-		"   prefetch 192(%0)\n"
-		"   prefetch 256(%0)\n"
+		"1: prefetch (%1)\n"
+		"   prefetch 64(%1)\n"
+		"   prefetch 128(%1)\n"
+		"   prefetch 192(%1)\n"
+		"   prefetch 256(%1)\n"
 		"2:  \n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+		"3:  \n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x1AEB, 1b\n"	/* jmp on 26 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
-			_ASM_EXTABLE(1b, 3b) : : "r" (from));
+			_ASM_EXTABLE(1b, 3b) : "=&r" (cr0) : "r" (from) : "ax");
 
 	for (i = 0; i < 4096/64; i++) {
 		__asm__ __volatile__ (
-		"1: prefetch 320(%0)\n"
-		"2: movq (%0), %%mm0\n"
-		"   movq 8(%0), %%mm1\n"
-		"   movq 16(%0), %%mm2\n"
-		"   movq 24(%0), %%mm3\n"
-		"   movq %%mm0, (%1)\n"
-		"   movq %%mm1, 8(%1)\n"
-		"   movq %%mm2, 16(%1)\n"
-		"   movq %%mm3, 24(%1)\n"
-		"   movq 32(%0), %%mm0\n"
-		"   movq 40(%0), %%mm1\n"
-		"   movq 48(%0), %%mm2\n"
-		"   movq 56(%0), %%mm3\n"
-		"   movq %%mm0, 32(%1)\n"
-		"   movq %%mm1, 40(%1)\n"
-		"   movq %%mm2, 48(%1)\n"
-		"   movq %%mm3, 56(%1)\n"
+		"1: prefetch 320(%1)\n"
+		"2: movq (%1), %%mm0\n"
+		"   movq 8(%1), %%mm1\n"
+		"   movq 16(%1), %%mm2\n"
+		"   movq 24(%1), %%mm3\n"
+		"   movq %%mm0, (%2)\n"
+		"   movq %%mm1, 8(%2)\n"
+		"   movq %%mm2, 16(%2)\n"
+		"   movq %%mm3, 24(%2)\n"
+		"   movq 32(%1), %%mm0\n"
+		"   movq 40(%1), %%mm1\n"
+		"   movq 48(%1), %%mm2\n"
+		"   movq 56(%1), %%mm3\n"
+		"   movq %%mm0, 32(%2)\n"
+		"   movq %%mm1, 40(%2)\n"
+		"   movq %%mm2, 48(%2)\n"
+		"   movq %%mm3, 56(%2)\n"
 		".section .fixup, \"ax\"\n"
-		"3: movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+		"3:\n"
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %%cr0, %0\n"
+		"   movl %0, %%eax\n"
+		"   andl $0xFFFEFFFF, %%eax\n"
+		"   movl %%eax, %%cr0\n"
+#endif
+
+		"   movw $0x05EB, 1b\n"	/* jmp on 5 bytes */
+
+#ifdef CONFIG_PAX_KERNEXEC
+		"   movl %0, %%cr0\n"
+#endif
+
 		"   jmp 2b\n"
 		".previous\n"
 			_ASM_EXTABLE(1b, 3b)
-			: : "r" (from), "r" (to) : "memory");
+			: "=&r" (cr0) : "r" (from), "r" (to) : "memory", "ax");
 
 		from += 64;
 		to += 64;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/putuser_32.S linux-2.6.26.8-pax/arch/x86/lib/putuser_32.S
--- linux-2.6.26.8/arch/x86/lib/putuser_32.S	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/putuser_32.S	2008-07-14 03:52:23.000000000 +0200
@@ -11,7 +11,7 @@
 #include <linux/linkage.h>
 #include <asm/dwarf2.h>
 #include <asm/thread_info.h>
-
+#include <asm/segment.h>
 
 /*
  * __put_user_X
@@ -41,7 +41,11 @@ ENTRY(__put_user_1)
 	ENTER
 	cmpl TI_addr_limit(%ebx),%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 1:	movb %al,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 ENDPROC(__put_user_1)
@@ -52,7 +56,11 @@ ENTRY(__put_user_2)
 	subl $1,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 2:	movw %ax,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 ENDPROC(__put_user_2)
@@ -63,7 +71,11 @@ ENTRY(__put_user_4)
 	subl $3,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 3:	movl %eax,(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 ENDPROC(__put_user_4)
@@ -74,8 +86,12 @@ ENTRY(__put_user_8)
 	subl $7,%ebx
 	cmpl %ebx,%ecx
 	jae bad_put_user
+	pushl $(__USER_DS)
+	popl %ds
 4:	movl %eax,(%ecx)
 5:	movl %edx,4(%ecx)
+	pushl %ss
+	popl %ds
 	xorl %eax,%eax
 	EXIT
 ENDPROC(__put_user_8)
@@ -85,6 +101,10 @@ bad_put_user:
 	CFI_DEF_CFA esp, 2*4
 	CFI_OFFSET eip, -1*4
 	CFI_OFFSET ebx, -2*4
+	pushl %ss
+	CFI_ADJUST_CFA_OFFSET 4
+	popl %ds
+	CFI_ADJUST_CFA_OFFSET -4
 	movl $-14,%eax
 	EXIT
 END(bad_put_user)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/lib/usercopy_32.c linux-2.6.26.8-pax/arch/x86/lib/usercopy_32.c
--- linux-2.6.26.8/arch/x86/lib/usercopy_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/lib/usercopy_32.c	2008-10-10 01:17:55.000000000 +0200
@@ -29,31 +29,38 @@ static inline int __movsl_is_ok(unsigned
  * Copy a null terminated string from userspace.
  */
 
-#define __do_strncpy_from_user(dst, src, count, res)			   \
-do {									   \
-	int __d0, __d1, __d2;						   \
-	might_sleep();							   \
-	__asm__ __volatile__(						   \
-		"	testl %1,%1\n"					   \
-		"	jz 2f\n"					   \
-		"0:	lodsb\n"					   \
-		"	stosb\n"					   \
-		"	testb %%al,%%al\n"				   \
-		"	jz 1f\n"					   \
-		"	decl %1\n"					   \
-		"	jnz 0b\n"					   \
-		"1:	subl %1,%0\n"					   \
-		"2:\n"							   \
-		".section .fixup,\"ax\"\n"				   \
-		"3:	movl %5,%0\n"					   \
-		"	jmp 2b\n"					   \
-		".previous\n"						   \
-		_ASM_EXTABLE(0b,3b)					   \
-		: "=d"(res), "=c"(count), "=&a" (__d0), "=&S" (__d1),	   \
-		  "=&D" (__d2)						   \
-		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), "4"(dst) \
-		: "memory");						   \
-} while (0)
+static long __do_strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	int __d0, __d1, __d2;
+	long res = -EFAULT;
+
+	might_sleep();
+	__asm__ __volatile__(
+		"	movw %w10,%%ds\n"
+		"	testl %1,%1\n"
+		"	jz 2f\n"
+		"0:	lodsb\n"
+		"	stosb\n"
+		"	testb %%al,%%al\n"
+		"	jz 1f\n"
+		"	decl %1\n"
+		"	jnz 0b\n"
+		"1:	subl %1,%0\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"3:	movl %5,%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		_ASM_EXTABLE(0b,3b)
+		: "=d"(res), "=c"(count), "=&a" (__d0), "=&S" (__d1),
+		  "=&D" (__d2)
+		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), "4"(dst),
+		  "r"(__USER_DS)
+		: "memory");
+	return res;
+}
 
 /**
  * __strncpy_from_user: - Copy a NUL terminated string from userspace, with less checking.
@@ -78,9 +85,7 @@ do {									   \
 long
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
-	long res;
-	__do_strncpy_from_user(dst, src, count, res);
-	return res;
+	return __do_strncpy_from_user(dst, src, count);
 }
 EXPORT_SYMBOL(__strncpy_from_user);
 
@@ -107,7 +112,7 @@ strncpy_from_user(char *dst, const char 
 {
 	long res = -EFAULT;
 	if (access_ok(VERIFY_READ, src, 1))
-		__do_strncpy_from_user(dst, src, count, res);
+		res = __do_strncpy_from_user(dst, src, count);
 	return res;
 }
 EXPORT_SYMBOL(strncpy_from_user);
@@ -116,24 +121,30 @@ EXPORT_SYMBOL(strncpy_from_user);
  * Zero Userspace
  */
 
-#define __do_clear_user(addr,size)					\
-do {									\
-	int __d0;							\
-	might_sleep();							\
-	__asm__ __volatile__(						\
-		"0:	rep; stosl\n"					\
-		"	movl %2,%0\n"					\
-		"1:	rep; stosb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"3:	lea 0(%2,%0,4),%0\n"				\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		_ASM_EXTABLE(0b,3b)					\
-		_ASM_EXTABLE(1b,2b)					\
-		: "=&c"(size), "=&D" (__d0)				\
-		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0));	\
-} while (0)
+static unsigned long __do_clear_user(void __user *addr, unsigned long size)
+{
+	int __d0;
+
+	might_sleep();
+	__asm__ __volatile__(
+		"	movw %w6,%%es\n"
+		"0:	rep; stosl\n"
+		"	movl %2,%0\n"
+		"1:	rep; stosb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
+		".section .fixup,\"ax\"\n"
+		"3:	lea 0(%2,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		_ASM_EXTABLE(0b,3b)
+		_ASM_EXTABLE(1b,2b)
+		: "=&c"(size), "=&D" (__d0)
+		: "r"(size & 3), "0"(size / 4), "1"(addr), "a"(0),
+		  "r"(__USER_DS));
+	return size;
+}
 
 /**
  * clear_user: - Zero a block of memory in user space.
@@ -150,7 +161,7 @@ clear_user(void __user *to, unsigned lon
 {
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
-		__do_clear_user(to, n);
+		n = __do_clear_user(to, n);
 	return n;
 }
 EXPORT_SYMBOL(clear_user);
@@ -169,8 +180,7 @@ EXPORT_SYMBOL(clear_user);
 unsigned long
 __clear_user(void __user *to, unsigned long n)
 {
-	__do_clear_user(to, n);
-	return n;
+	return __do_clear_user(to, n);
 }
 EXPORT_SYMBOL(__clear_user);
 
@@ -193,14 +203,17 @@ long strnlen_user(const char __user *s, 
 	might_sleep();
 
 	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
 		"	testl %0, %0\n"
 		"	jz 3f\n"
-		"	andl %0,%%ecx\n"
+		"	movl %0,%%ecx\n"
 		"0:	repne; scasb\n"
 		"	setne %%al\n"
 		"	subl %%ecx,%0\n"
 		"	addl %0,%%eax\n"
 		"1:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
 		".section .fixup,\"ax\"\n"
 		"2:	xorl %%eax,%%eax\n"
 		"	jmp 1b\n"
@@ -212,7 +225,7 @@ long strnlen_user(const char __user *s, 
 		"	.long 0b,2b\n"
 		".previous"
 		:"=r" (n), "=D" (s), "=a" (res), "=c" (tmp)
-		:"0" (n), "1" (s), "2" (0), "3" (mask)
+		:"0" (n), "1" (s), "2" (0), "3" (mask), "r" (__USER_DS)
 		:"cc");
 	return res & mask;
 }
@@ -220,10 +233,11 @@ EXPORT_SYMBOL(strnlen_user);
 
 #ifdef CONFIG_X86_INTEL_USERCOPY
 static unsigned long
-__copy_user_intel(void __user *to, const void *from, unsigned long size)
+__generic_copy_to_user_intel(void __user *to, const void *from, unsigned long size)
 {
 	int d0, d1;
 	__asm__ __volatile__(
+		       "       movw %w6, %%es\n"
 		       "       .align 2,0x90\n"
 		       "1:     movl 32(%4), %%eax\n"
 		       "       cmpl $67, %0\n"
@@ -232,36 +246,36 @@ __copy_user_intel(void __user *to, const
 		       "       .align 2,0x90\n"
 		       "3:     movl 0(%4), %%eax\n"
 		       "4:     movl 4(%4), %%edx\n"
-		       "5:     movl %%eax, 0(%3)\n"
-		       "6:     movl %%edx, 4(%3)\n"
+		       "5:     movl %%eax, %%es:0(%3)\n"
+		       "6:     movl %%edx, %%es:4(%3)\n"
 		       "7:     movl 8(%4), %%eax\n"
 		       "8:     movl 12(%4),%%edx\n"
-		       "9:     movl %%eax, 8(%3)\n"
-		       "10:    movl %%edx, 12(%3)\n"
+		       "9:     movl %%eax, %%es:8(%3)\n"
+		       "10:    movl %%edx, %%es:12(%3)\n"
 		       "11:    movl 16(%4), %%eax\n"
 		       "12:    movl 20(%4), %%edx\n"
-		       "13:    movl %%eax, 16(%3)\n"
-		       "14:    movl %%edx, 20(%3)\n"
+		       "13:    movl %%eax, %%es:16(%3)\n"
+		       "14:    movl %%edx, %%es:20(%3)\n"
 		       "15:    movl 24(%4), %%eax\n"
 		       "16:    movl 28(%4), %%edx\n"
-		       "17:    movl %%eax, 24(%3)\n"
-		       "18:    movl %%edx, 28(%3)\n"
+		       "17:    movl %%eax, %%es:24(%3)\n"
+		       "18:    movl %%edx, %%es:28(%3)\n"
 		       "19:    movl 32(%4), %%eax\n"
 		       "20:    movl 36(%4), %%edx\n"
-		       "21:    movl %%eax, 32(%3)\n"
-		       "22:    movl %%edx, 36(%3)\n"
+		       "21:    movl %%eax, %%es:32(%3)\n"
+		       "22:    movl %%edx, %%es:36(%3)\n"
 		       "23:    movl 40(%4), %%eax\n"
 		       "24:    movl 44(%4), %%edx\n"
-		       "25:    movl %%eax, 40(%3)\n"
-		       "26:    movl %%edx, 44(%3)\n"
+		       "25:    movl %%eax, %%es:40(%3)\n"
+		       "26:    movl %%edx, %%es:44(%3)\n"
 		       "27:    movl 48(%4), %%eax\n"
 		       "28:    movl 52(%4), %%edx\n"
-		       "29:    movl %%eax, 48(%3)\n"
-		       "30:    movl %%edx, 52(%3)\n"
+		       "29:    movl %%eax, %%es:48(%3)\n"
+		       "30:    movl %%edx, %%es:52(%3)\n"
 		       "31:    movl 56(%4), %%eax\n"
 		       "32:    movl 60(%4), %%edx\n"
-		       "33:    movl %%eax, 56(%3)\n"
-		       "34:    movl %%edx, 60(%3)\n"
+		       "33:    movl %%eax, %%es:56(%3)\n"
+		       "34:    movl %%edx, %%es:60(%3)\n"
 		       "       addl $-64, %0\n"
 		       "       addl $64, %4\n"
 		       "       addl $64, %3\n"
@@ -275,6 +289,8 @@ __copy_user_intel(void __user *to, const
 		       "36:    movl %%eax, %0\n"
 		       "37:    rep; movsb\n"
 		       "100:\n"
+		       "       pushl %%ss\n"
+		       "       popl %%es\n"
 		       ".section .fixup,\"ax\"\n"
 		       "101:   lea 0(%%eax,%0,4),%0\n"
 		       "       jmp 100b\n"
@@ -321,7 +337,117 @@ __copy_user_intel(void __user *to, const
 		       "       .long 99b,101b\n"
 		       ".previous"
 		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-		       :  "1"(to), "2"(from), "0"(size)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
+		       : "eax", "edx", "memory");
+	return size;
+}
+
+static unsigned long
+__generic_copy_from_user_intel(void *to, const void __user *from, unsigned long size)
+{
+	int d0, d1;
+	__asm__ __volatile__(
+		       "       movw %w6, %%ds\n"
+		       "       .align 2,0x90\n"
+		       "1:     movl 32(%4), %%eax\n"
+		       "       cmpl $67, %0\n"
+		       "       jbe 3f\n"
+		       "2:     movl 64(%4), %%eax\n"
+		       "       .align 2,0x90\n"
+		       "3:     movl 0(%4), %%eax\n"
+		       "4:     movl 4(%4), %%edx\n"
+		       "5:     movl %%eax, %%es:0(%3)\n"
+		       "6:     movl %%edx, %%es:4(%3)\n"
+		       "7:     movl 8(%4), %%eax\n"
+		       "8:     movl 12(%4),%%edx\n"
+		       "9:     movl %%eax, %%es:8(%3)\n"
+		       "10:    movl %%edx, %%es:12(%3)\n"
+		       "11:    movl 16(%4), %%eax\n"
+		       "12:    movl 20(%4), %%edx\n"
+		       "13:    movl %%eax, %%es:16(%3)\n"
+		       "14:    movl %%edx, %%es:20(%3)\n"
+		       "15:    movl 24(%4), %%eax\n"
+		       "16:    movl 28(%4), %%edx\n"
+		       "17:    movl %%eax, %%es:24(%3)\n"
+		       "18:    movl %%edx, %%es:28(%3)\n"
+		       "19:    movl 32(%4), %%eax\n"
+		       "20:    movl 36(%4), %%edx\n"
+		       "21:    movl %%eax, %%es:32(%3)\n"
+		       "22:    movl %%edx, %%es:36(%3)\n"
+		       "23:    movl 40(%4), %%eax\n"
+		       "24:    movl 44(%4), %%edx\n"
+		       "25:    movl %%eax, %%es:40(%3)\n"
+		       "26:    movl %%edx, %%es:44(%3)\n"
+		       "27:    movl 48(%4), %%eax\n"
+		       "28:    movl 52(%4), %%edx\n"
+		       "29:    movl %%eax, %%es:48(%3)\n"
+		       "30:    movl %%edx, %%es:52(%3)\n"
+		       "31:    movl 56(%4), %%eax\n"
+		       "32:    movl 60(%4), %%edx\n"
+		       "33:    movl %%eax, %%es:56(%3)\n"
+		       "34:    movl %%edx, %%es:60(%3)\n"
+		       "       addl $-64, %0\n"
+		       "       addl $64, %4\n"
+		       "       addl $64, %3\n"
+		       "       cmpl $63, %0\n"
+		       "       ja  1b\n"
+		       "35:    movl  %0, %%eax\n"
+		       "       shrl  $2, %0\n"
+		       "       andl  $3, %%eax\n"
+		       "       cld\n"
+		       "99:    rep; movsl\n"
+		       "36:    movl %%eax, %0\n"
+		       "37:    rep; movsb\n"
+		       "100:\n"
+		       "       pushl %%ss\n"
+		       "       popl %%ds\n"
+		       ".section .fixup,\"ax\"\n"
+		       "101:   lea 0(%%eax,%0,4),%0\n"
+		       "       jmp 100b\n"
+		       ".previous\n"
+		       ".section __ex_table,\"a\"\n"
+		       "       .align 4\n"
+		       "       .long 1b,100b\n"
+		       "       .long 2b,100b\n"
+		       "       .long 3b,100b\n"
+		       "       .long 4b,100b\n"
+		       "       .long 5b,100b\n"
+		       "       .long 6b,100b\n"
+		       "       .long 7b,100b\n"
+		       "       .long 8b,100b\n"
+		       "       .long 9b,100b\n"
+		       "       .long 10b,100b\n"
+		       "       .long 11b,100b\n"
+		       "       .long 12b,100b\n"
+		       "       .long 13b,100b\n"
+		       "       .long 14b,100b\n"
+		       "       .long 15b,100b\n"
+		       "       .long 16b,100b\n"
+		       "       .long 17b,100b\n"
+		       "       .long 18b,100b\n"
+		       "       .long 19b,100b\n"
+		       "       .long 20b,100b\n"
+		       "       .long 21b,100b\n"
+		       "       .long 22b,100b\n"
+		       "       .long 23b,100b\n"
+		       "       .long 24b,100b\n"
+		       "       .long 25b,100b\n"
+		       "       .long 26b,100b\n"
+		       "       .long 27b,100b\n"
+		       "       .long 28b,100b\n"
+		       "       .long 29b,100b\n"
+		       "       .long 30b,100b\n"
+		       "       .long 31b,100b\n"
+		       "       .long 32b,100b\n"
+		       "       .long 33b,100b\n"
+		       "       .long 34b,100b\n"
+		       "       .long 35b,100b\n"
+		       "       .long 36b,100b\n"
+		       "       .long 37b,100b\n"
+		       "       .long 99b,101b\n"
+		       ".previous"
+		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 		       : "eax", "edx", "memory");
 	return size;
 }
@@ -331,6 +457,7 @@ __copy_user_zeroing_intel(void *to, cons
 {
 	int d0, d1;
 	__asm__ __volatile__(
+		       "        movw %w6, %%ds\n"
 		       "        .align 2,0x90\n"
 		       "0:      movl 32(%4), %%eax\n"
 		       "        cmpl $67, %0\n"
@@ -339,36 +466,36 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        .align 2,0x90\n"
 		       "2:      movl 0(%4), %%eax\n"
 		       "21:     movl 4(%4), %%edx\n"
-		       "        movl %%eax, 0(%3)\n"
-		       "        movl %%edx, 4(%3)\n"
+		       "        movl %%eax, %%es:0(%3)\n"
+		       "        movl %%edx, %%es:4(%3)\n"
 		       "3:      movl 8(%4), %%eax\n"
 		       "31:     movl 12(%4),%%edx\n"
-		       "        movl %%eax, 8(%3)\n"
-		       "        movl %%edx, 12(%3)\n"
+		       "        movl %%eax, %%es:8(%3)\n"
+		       "        movl %%edx, %%es:12(%3)\n"
 		       "4:      movl 16(%4), %%eax\n"
 		       "41:     movl 20(%4), %%edx\n"
-		       "        movl %%eax, 16(%3)\n"
-		       "        movl %%edx, 20(%3)\n"
+		       "        movl %%eax, %%es:16(%3)\n"
+		       "        movl %%edx, %%es:20(%3)\n"
 		       "10:     movl 24(%4), %%eax\n"
 		       "51:     movl 28(%4), %%edx\n"
-		       "        movl %%eax, 24(%3)\n"
-		       "        movl %%edx, 28(%3)\n"
+		       "        movl %%eax, %%es:24(%3)\n"
+		       "        movl %%edx, %%es:28(%3)\n"
 		       "11:     movl 32(%4), %%eax\n"
 		       "61:     movl 36(%4), %%edx\n"
-		       "        movl %%eax, 32(%3)\n"
-		       "        movl %%edx, 36(%3)\n"
+		       "        movl %%eax, %%es:32(%3)\n"
+		       "        movl %%edx, %%es:36(%3)\n"
 		       "12:     movl 40(%4), %%eax\n"
 		       "71:     movl 44(%4), %%edx\n"
-		       "        movl %%eax, 40(%3)\n"
-		       "        movl %%edx, 44(%3)\n"
+		       "        movl %%eax, %%es:40(%3)\n"
+		       "        movl %%edx, %%es:44(%3)\n"
 		       "13:     movl 48(%4), %%eax\n"
 		       "81:     movl 52(%4), %%edx\n"
-		       "        movl %%eax, 48(%3)\n"
-		       "        movl %%edx, 52(%3)\n"
+		       "        movl %%eax, %%es:48(%3)\n"
+		       "        movl %%edx, %%es:52(%3)\n"
 		       "14:     movl 56(%4), %%eax\n"
 		       "91:     movl 60(%4), %%edx\n"
-		       "        movl %%eax, 56(%3)\n"
-		       "        movl %%edx, 60(%3)\n"
+		       "        movl %%eax, %%es:56(%3)\n"
+		       "        movl %%edx, %%es:60(%3)\n"
 		       "        addl $-64, %0\n"
 		       "        addl $64, %4\n"
 		       "        addl $64, %3\n"
@@ -382,6 +509,8 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        movl %%eax,%0\n"
 		       "7:      rep; movsb\n"
 		       "8:\n"
+		       "        pushl %%ss\n"
+		       "        popl %%ds\n"
 		       ".section .fixup,\"ax\"\n"
 		       "9:      lea 0(%%eax,%0,4),%0\n"
 		       "16:     pushl %0\n"
@@ -416,7 +545,7 @@ __copy_user_zeroing_intel(void *to, cons
 		       "        .long 7b,16b\n"
 		       ".previous"
 		       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-		       :  "1"(to), "2"(from), "0"(size)
+		       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 		       : "eax", "edx", "memory");
 	return size;
 }
@@ -432,6 +561,7 @@ static unsigned long __copy_user_zeroing
 	int d0, d1;
 
 	__asm__ __volatile__(
+	       "        movw %w6, %%ds\n"
 	       "        .align 2,0x90\n"
 	       "0:      movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
@@ -440,36 +570,36 @@ static unsigned long __copy_user_zeroing
 	       "        .align 2,0x90\n"
 	       "2:      movl 0(%4), %%eax\n"
 	       "21:     movl 4(%4), %%edx\n"
-	       "        movnti %%eax, 0(%3)\n"
-	       "        movnti %%edx, 4(%3)\n"
+	       "        movnti %%eax, %%es:0(%3)\n"
+	       "        movnti %%edx, %%es:4(%3)\n"
 	       "3:      movl 8(%4), %%eax\n"
 	       "31:     movl 12(%4),%%edx\n"
-	       "        movnti %%eax, 8(%3)\n"
-	       "        movnti %%edx, 12(%3)\n"
+	       "        movnti %%eax, %%es:8(%3)\n"
+	       "        movnti %%edx, %%es:12(%3)\n"
 	       "4:      movl 16(%4), %%eax\n"
 	       "41:     movl 20(%4), %%edx\n"
-	       "        movnti %%eax, 16(%3)\n"
-	       "        movnti %%edx, 20(%3)\n"
+	       "        movnti %%eax, %%es:16(%3)\n"
+	       "        movnti %%edx, %%es:20(%3)\n"
 	       "10:     movl 24(%4), %%eax\n"
 	       "51:     movl 28(%4), %%edx\n"
-	       "        movnti %%eax, 24(%3)\n"
-	       "        movnti %%edx, 28(%3)\n"
+	       "        movnti %%eax, %%es:24(%3)\n"
+	       "        movnti %%edx, %%es:28(%3)\n"
 	       "11:     movl 32(%4), %%eax\n"
 	       "61:     movl 36(%4), %%edx\n"
-	       "        movnti %%eax, 32(%3)\n"
-	       "        movnti %%edx, 36(%3)\n"
+	       "        movnti %%eax, %%es:32(%3)\n"
+	       "        movnti %%edx, %%es:36(%3)\n"
 	       "12:     movl 40(%4), %%eax\n"
 	       "71:     movl 44(%4), %%edx\n"
-	       "        movnti %%eax, 40(%3)\n"
-	       "        movnti %%edx, 44(%3)\n"
+	       "        movnti %%eax, %%es:40(%3)\n"
+	       "        movnti %%edx, %%es:44(%3)\n"
 	       "13:     movl 48(%4), %%eax\n"
 	       "81:     movl 52(%4), %%edx\n"
-	       "        movnti %%eax, 48(%3)\n"
-	       "        movnti %%edx, 52(%3)\n"
+	       "        movnti %%eax, %%es:48(%3)\n"
+	       "        movnti %%edx, %%es:52(%3)\n"
 	       "14:     movl 56(%4), %%eax\n"
 	       "91:     movl 60(%4), %%edx\n"
-	       "        movnti %%eax, 56(%3)\n"
-	       "        movnti %%edx, 60(%3)\n"
+	       "        movnti %%eax, %%es:56(%3)\n"
+	       "        movnti %%edx, %%es:60(%3)\n"
 	       "        addl $-64, %0\n"
 	       "        addl $64, %4\n"
 	       "        addl $64, %3\n"
@@ -484,6 +614,8 @@ static unsigned long __copy_user_zeroing
 	       "        movl %%eax,%0\n"
 	       "7:      rep; movsb\n"
 	       "8:\n"
+	       "        pushl %%ss\n"
+	       "        popl %%ds\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
 	       "16:     pushl %0\n"
@@ -518,7 +650,7 @@ static unsigned long __copy_user_zeroing
 	       "        .long 7b,16b\n"
 	       ".previous"
 	       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-	       :  "1"(to), "2"(from), "0"(size)
+	       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 	       : "eax", "edx", "memory");
 	return size;
 }
@@ -529,6 +661,7 @@ static unsigned long __copy_user_intel_n
 	int d0, d1;
 
 	__asm__ __volatile__(
+	       "        movw %w6, %%ds\n"
 	       "        .align 2,0x90\n"
 	       "0:      movl 32(%4), %%eax\n"
 	       "        cmpl $67, %0\n"
@@ -537,36 +670,36 @@ static unsigned long __copy_user_intel_n
 	       "        .align 2,0x90\n"
 	       "2:      movl 0(%4), %%eax\n"
 	       "21:     movl 4(%4), %%edx\n"
-	       "        movnti %%eax, 0(%3)\n"
-	       "        movnti %%edx, 4(%3)\n"
+	       "        movnti %%eax, %%es:0(%3)\n"
+	       "        movnti %%edx, %%es:4(%3)\n"
 	       "3:      movl 8(%4), %%eax\n"
 	       "31:     movl 12(%4),%%edx\n"
-	       "        movnti %%eax, 8(%3)\n"
-	       "        movnti %%edx, 12(%3)\n"
+	       "        movnti %%eax, %%es:8(%3)\n"
+	       "        movnti %%edx, %%es:12(%3)\n"
 	       "4:      movl 16(%4), %%eax\n"
 	       "41:     movl 20(%4), %%edx\n"
-	       "        movnti %%eax, 16(%3)\n"
-	       "        movnti %%edx, 20(%3)\n"
+	       "        movnti %%eax, %%es:16(%3)\n"
+	       "        movnti %%edx, %%es:20(%3)\n"
 	       "10:     movl 24(%4), %%eax\n"
 	       "51:     movl 28(%4), %%edx\n"
-	       "        movnti %%eax, 24(%3)\n"
-	       "        movnti %%edx, 28(%3)\n"
+	       "        movnti %%eax, %%es:24(%3)\n"
+	       "        movnti %%edx, %%es:28(%3)\n"
 	       "11:     movl 32(%4), %%eax\n"
 	       "61:     movl 36(%4), %%edx\n"
-	       "        movnti %%eax, 32(%3)\n"
-	       "        movnti %%edx, 36(%3)\n"
+	       "        movnti %%eax, %%es:32(%3)\n"
+	       "        movnti %%edx, %%es:36(%3)\n"
 	       "12:     movl 40(%4), %%eax\n"
 	       "71:     movl 44(%4), %%edx\n"
-	       "        movnti %%eax, 40(%3)\n"
-	       "        movnti %%edx, 44(%3)\n"
+	       "        movnti %%eax, %%es:40(%3)\n"
+	       "        movnti %%edx, %%es:44(%3)\n"
 	       "13:     movl 48(%4), %%eax\n"
 	       "81:     movl 52(%4), %%edx\n"
-	       "        movnti %%eax, 48(%3)\n"
-	       "        movnti %%edx, 52(%3)\n"
+	       "        movnti %%eax, %%es:48(%3)\n"
+	       "        movnti %%edx, %%es:52(%3)\n"
 	       "14:     movl 56(%4), %%eax\n"
 	       "91:     movl 60(%4), %%edx\n"
-	       "        movnti %%eax, 56(%3)\n"
-	       "        movnti %%edx, 60(%3)\n"
+	       "        movnti %%eax, %%es:56(%3)\n"
+	       "        movnti %%edx, %%es:60(%3)\n"
 	       "        addl $-64, %0\n"
 	       "        addl $64, %4\n"
 	       "        addl $64, %3\n"
@@ -581,6 +714,8 @@ static unsigned long __copy_user_intel_n
 	       "        movl %%eax,%0\n"
 	       "7:      rep; movsb\n"
 	       "8:\n"
+	       "        pushl %%ss\n"
+	       "        popl %%ds\n"
 	       ".section .fixup,\"ax\"\n"
 	       "9:      lea 0(%%eax,%0,4),%0\n"
 	       "16:     jmp 8b\n"
@@ -609,7 +744,7 @@ static unsigned long __copy_user_intel_n
 	       "        .long 7b,16b\n"
 	       ".previous"
 	       : "=&c"(size), "=&D" (d0), "=&S" (d1)
-	       :  "1"(to), "2"(from), "0"(size)
+	       :  "1"(to), "2"(from), "0"(size), "r"(__USER_DS)
 	       : "eax", "edx", "memory");
 	return size;
 }
@@ -622,90 +757,146 @@ static unsigned long __copy_user_intel_n
  */
 unsigned long __copy_user_zeroing_intel(void *to, const void __user *from,
 					unsigned long size);
-unsigned long __copy_user_intel(void __user *to, const void *from,
+unsigned long __generic_copy_to_user_intel(void __user *to, const void *from,
+					unsigned long size);
+unsigned long __generic_copy_from_user_intel(void *to, const void __user *from,
 					unsigned long size);
 unsigned long __copy_user_zeroing_intel_nocache(void *to,
 				const void __user *from, unsigned long size);
 #endif /* CONFIG_X86_INTEL_USERCOPY */
 
 /* Generic arbitrary sized copy.  */
-#define __copy_user(to, from, size)					\
-do {									\
-	int __d0, __d1, __d2;						\
-	__asm__ __volatile__(						\
-		"	cmp  $7,%0\n"					\
-		"	jbe  1f\n"					\
-		"	movl %1,%0\n"					\
-		"	negl %0\n"					\
-		"	andl $7,%0\n"					\
-		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
-		"	movl %3,%0\n"					\
-		"	shrl $2,%0\n"					\
-		"	andl $3,%3\n"					\
-		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
-		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"5:	addl %3,%0\n"					\
-		"	jmp 2b\n"					\
-		"3:	lea 0(%3,%0,4),%0\n"				\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.align 4\n"					\
-		"	.long 4b,5b\n"					\
-		"	.long 0b,3b\n"					\
-		"	.long 1b,2b\n"					\
-		".previous"						\
-		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)	\
-		: "3"(size), "0"(size), "1"(to), "2"(from)		\
-		: "memory");						\
-} while (0)
-
-#define __copy_user_zeroing(to, from, size)				\
-do {									\
-	int __d0, __d1, __d2;						\
-	__asm__ __volatile__(						\
-		"	cmp  $7,%0\n"					\
-		"	jbe  1f\n"					\
-		"	movl %1,%0\n"					\
-		"	negl %0\n"					\
-		"	andl $7,%0\n"					\
-		"	subl %0,%3\n"					\
-		"4:	rep; movsb\n"					\
-		"	movl %3,%0\n"					\
-		"	shrl $2,%0\n"					\
-		"	andl $3,%3\n"					\
-		"	.align 2,0x90\n"				\
-		"0:	rep; movsl\n"					\
-		"	movl %3,%0\n"					\
-		"1:	rep; movsb\n"					\
-		"2:\n"							\
-		".section .fixup,\"ax\"\n"				\
-		"5:	addl %3,%0\n"					\
-		"	jmp 6f\n"					\
-		"3:	lea 0(%3,%0,4),%0\n"				\
-		"6:	pushl %0\n"					\
-		"	pushl %%eax\n"					\
-		"	xorl %%eax,%%eax\n"				\
-		"	rep; stosb\n"					\
-		"	popl %%eax\n"					\
-		"	popl %0\n"					\
-		"	jmp 2b\n"					\
-		".previous\n"						\
-		".section __ex_table,\"a\"\n"				\
-		"	.align 4\n"					\
-		"	.long 4b,5b\n"					\
-		"	.long 0b,3b\n"					\
-		"	.long 1b,6b\n"					\
-		".previous"						\
-		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)	\
-		: "3"(size), "0"(size), "1"(to), "2"(from)		\
-		: "memory");						\
-} while (0)
+static unsigned long
+__generic_copy_to_user(void __user *to, const void *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%es\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%es\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 2b\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,2b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
+
+static unsigned long
+__generic_copy_from_user(void *to, const void __user *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%ds\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 2b\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,2b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
+
+static unsigned long
+__copy_user_zeroing(void *to, const void __user *from, unsigned long size)
+{
+	int __d0, __d1, __d2;
+
+	__asm__ __volatile__(
+		"	movw %w8,%%ds\n"
+		"	cmp  $7,%0\n"
+		"	jbe  1f\n"
+		"	movl %1,%0\n"
+		"	negl %0\n"
+		"	andl $7,%0\n"
+		"	subl %0,%3\n"
+		"4:	rep; movsb\n"
+		"	movl %3,%0\n"
+		"	shrl $2,%0\n"
+		"	andl $3,%3\n"
+		"	.align 2,0x90\n"
+		"0:	rep; movsl\n"
+		"	movl %3,%0\n"
+		"1:	rep; movsb\n"
+		"2:\n"
+		"	pushl %%ss\n"
+		"	popl %%ds\n"
+		".section .fixup,\"ax\"\n"
+		"5:	addl %3,%0\n"
+		"	jmp 6f\n"
+		"3:	lea 0(%3,%0,4),%0\n"
+		"6:	pushl %0\n"
+		"	pushl %%eax\n"
+		"	xorl %%eax,%%eax\n"
+		"	rep; stosb\n"
+		"	popl %%eax\n"
+		"	popl %0\n"
+		"	jmp 2b\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.align 4\n"
+		"	.long 4b,5b\n"
+		"	.long 0b,3b\n"
+		"	.long 1b,6b\n"
+		".previous"
+		: "=&c"(size), "=&D" (__d0), "=&S" (__d1), "=r"(__d2)
+		: "3"(size), "0"(size), "1"(to), "2"(from), "r"(__USER_DS)
+		: "memory");
+	return size;
+}
 
 unsigned long __copy_to_user_ll(void __user *to, const void *from,
 				unsigned long n)
@@ -768,9 +959,9 @@ survive:
 	}
 #endif
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		n = __generic_copy_to_user(to, from, n);
 	else
-		n = __copy_user_intel(to, from, n);
+		n = __generic_copy_to_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_to_user_ll);
@@ -779,7 +970,7 @@ unsigned long __copy_from_user_ll(void *
 					unsigned long n)
 {
 	if (movsl_is_ok(to, from, n))
-		__copy_user_zeroing(to, from, n);
+		n = __copy_user_zeroing(to, from, n);
 	else
 		n = __copy_user_zeroing_intel(to, from, n);
 	return n;
@@ -790,10 +981,9 @@ unsigned long __copy_from_user_ll_nozero
 					 unsigned long n)
 {
 	if (movsl_is_ok(to, from, n))
-		__copy_user(to, from, n);
+		n = __generic_copy_from_user(to, from, n);
 	else
-		n = __copy_user_intel((void __user *)to,
-				      (const void *)from, n);
+		n = __generic_copy_from_user_intel(to, from, n);
 	return n;
 }
 EXPORT_SYMBOL(__copy_from_user_ll_nozero);
@@ -802,12 +992,12 @@ unsigned long __copy_from_user_ll_nocach
 					unsigned long n)
 {
 #ifdef CONFIG_X86_INTEL_USERCOPY
-	if (n > 64 && cpu_has_xmm2)
+	if ( n > 64 && cpu_has_xmm2)
 		n = __copy_user_zeroing_intel_nocache(to, from, n);
 	else
-		__copy_user_zeroing(to, from, n);
+		n = __copy_user_zeroing(to, from, n);
 #else
-	__copy_user_zeroing(to, from, n);
+	n = __copy_user_zeroing(to, from, n);
 #endif
 	return n;
 }
@@ -817,12 +1007,12 @@ unsigned long __copy_from_user_ll_nocach
 					unsigned long n)
 {
 #ifdef CONFIG_X86_INTEL_USERCOPY
-	if (n > 64 && cpu_has_xmm2)
+	if ( n > 64 && cpu_has_xmm2)
 		n = __copy_user_intel_nocache(to, from, n);
 	else
-		__copy_user(to, from, n);
+		n = __generic_copy_from_user(to, from, n);
 #else
-	__copy_user(to, from, n);
+	n = __generic_copy_from_user(to, from, n);
 #endif
 	return n;
 }
@@ -871,8 +1061,35 @@ copy_from_user(void *to, const void __us
 {
 	if (access_ok(VERIFY_READ, from, n))
 		n = __copy_from_user(to, from, n);
-	else
+	else if ((long)n > 0)
 		memset(to, 0, n);
 	return n;
 }
 EXPORT_SYMBOL(copy_from_user);
+
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+void __set_fs(mm_segment_t x, int cpu)
+{
+	unsigned long limit = x.seg;
+	struct desc_struct d;
+
+	current_thread_info()->addr_limit = x;
+	if (likely(limit))
+		limit = (limit - 1UL) >> PAGE_SHIFT;
+	pack_descriptor(&d, 0UL, limit, 0xF3, 0xC);
+	write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_DEFAULT_USER_DS, &d, DESCTYPE_S);
+}
+
+void set_fs(mm_segment_t x)
+{
+	__set_fs(x, get_cpu());
+	put_cpu_no_resched();
+}
+#else
+void set_fs(mm_segment_t x)
+{
+	current_thread_info()->addr_limit = x;
+}
+#endif
+
+EXPORT_SYMBOL(set_fs);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mach-voyager/voyager_basic.c linux-2.6.26.8-pax/arch/x86/mach-voyager/voyager_basic.c
--- linux-2.6.26.8/arch/x86/mach-voyager/voyager_basic.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mach-voyager/voyager_basic.c	2008-07-14 03:52:23.000000000 +0200
@@ -123,7 +123,7 @@ int __init voyager_memory_detect(int reg
 	__u8 cmos[4];
 	ClickMap_t *map;
 	unsigned long map_addr;
-	unsigned long old;
+	pte_t old;
 
 	if (region >= CLICK_ENTRIES) {
 		printk("Voyager: Illegal ClickMap region %d\n", region);
@@ -138,7 +138,7 @@ int __init voyager_memory_detect(int reg
 
 	/* steal page 0 for this */
 	old = pg0[0];
-	pg0[0] = ((map_addr & PAGE_MASK) | _PAGE_RW | _PAGE_PRESENT);
+	pg0[0] = __pte((map_addr & PAGE_MASK) | _PAGE_RW | _PAGE_PRESENT);
 	local_flush_tlb();
 	/* now clear everything out but page 0 */
 	map = (ClickMap_t *) (map_addr & (~PAGE_MASK));
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mach-voyager/voyager_smp.c linux-2.6.26.8-pax/arch/x86/mach-voyager/voyager_smp.c
--- linux-2.6.26.8/arch/x86/mach-voyager/voyager_smp.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mach-voyager/voyager_smp.c	2008-07-14 03:52:23.000000000 +0200
@@ -515,6 +515,10 @@ static void __init do_boot_cpu(__u8 cpu)
 	__u32 *hijack_vector;
 	__u32 start_phys_address = setup_trampoline();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	/* There's a clever trick to this: The linux trampoline is
 	 * compiled to begin at absolute location zero, so make the
 	 * address zero but have the data segment selector compensate
@@ -534,7 +538,17 @@ static void __init do_boot_cpu(__u8 cpu)
 
 	init_gdt(cpu);
 	per_cpu(current_task, cpu) = idle;
-	early_gdt_descr.address = (unsigned long)get_cpu_gdt_table(cpu);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	early_gdt_descr.address = get_cpu_gdt_table(cpu);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	irq_ctx_init(cpu);
 
 	/* Note: Don't modify initial ss override */
@@ -1217,7 +1231,7 @@ void smp_local_timer_interrupt(void)
 			    per_cpu(prof_counter, cpu);
 		}
 
-		update_process_times(user_mode_vm(get_irq_regs()));
+		update_process_times(user_mode(get_irq_regs()));
 	}
 
 	if (((1 << cpu) & voyager_extended_vic_processors) == 0)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/discontig_32.c linux-2.6.26.8-pax/arch/x86/mm/discontig_32.c
--- linux-2.6.26.8/arch/x86/mm/discontig_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/discontig_32.c	2008-10-09 23:43:19.000000000 +0200
@@ -311,7 +311,7 @@ void __init remap_numa_kva(void)
 #endif /* CONFIG_DISCONTIGMEM */
 
 extern void setup_bootmem_allocator(void);
-unsigned long __init setup_memory(void)
+unsigned void __init setup_memory(void)
 {
 	int nid;
 	unsigned long system_start_pfn, system_max_low_pfn;
@@ -384,7 +384,6 @@ unsigned long __init setup_memory(void)
 	memset(NODE_DATA(0), 0, sizeof(struct pglist_data));
 	NODE_DATA(0)->bdata = &node0_bdata;
 	setup_bootmem_allocator();
-	return max_low_pfn;
 }
 
 void __init numa_kva_reserve(void)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/extable.c linux-2.6.26.8-pax/arch/x86/mm/extable.c
--- linux-2.6.26.8/arch/x86/mm/extable.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/extable.c	2008-09-21 21:58:48.000000000 +0200
@@ -1,14 +1,62 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/sort.h>
 #include <asm/uaccess.h>
 
+/*
+ * The exception table needs to be sorted so that the binary
+ * search that we use to find entries in it works properly.
+ * This is used both for the kernel exception table and for
+ * the exception tables of modules that get loaded.
+ */
+static int cmp_ex(const void *a, const void *b)
+{
+	const struct exception_table_entry *x = a, *y = b;
+
+	/* avoid overflow */
+	if (x->insn > y->insn)
+		return 1;
+	if (x->insn < y->insn)
+		return -1;
+	return 0;
+}
+
+static void swap_ex(void *a, void *b, int size)
+{
+	struct exception_table_entry t, *x = a, *y = b;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
+	t = *x;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	*x = *y;
+	*y = t;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+}
+
+void sort_extable(struct exception_table_entry *start,
+		  struct exception_table_entry *finish)
+{
+	sort(start, finish - start, sizeof(struct exception_table_entry),
+	     cmp_ex, swap_ex);
+}
 
 int fixup_exception(struct pt_regs *regs)
 {
 	const struct exception_table_entry *fixup;
 
 #ifdef CONFIG_PNPBIOS
-	if (unlikely(SEGMENT_IS_PNP_CODE(regs->cs))) {
+	if (unlikely(!v8086_mode(regs) && SEGMENT_IS_PNP_CODE(regs->cs))) {
 		extern u32 pnp_bios_fault_eip, pnp_bios_fault_esp;
 		extern u32 pnp_bios_is_utter_crap;
 		pnp_bios_is_utter_crap = 1;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/fault.c linux-2.6.26.8-pax/arch/x86/mm/fault.c
--- linux-2.6.26.8/arch/x86/mm/fault.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/fault.c	2008-09-21 22:32:17.000000000 +0200
@@ -25,6 +25,8 @@
 #include <linux/kprobes.h>
 #include <linux/uaccess.h>
 #include <linux/kdebug.h>
+#include <linux/unistd.h>
+#include <linux/compiler.h>
 
 #include <asm/system.h>
 #include <asm/desc.h>
@@ -34,6 +36,7 @@
 #include <asm/tlbflush.h>
 #include <asm/proto.h>
 #include <asm-generic/sections.h>
+#include <asm/tlbflush.h>
 
 /*
  * Page fault error code bits
@@ -55,11 +58,7 @@ static inline int notify_page_fault(stru
 	int ret = 0;
 
 	/* kprobe_running() needs smp_processor_id() */
-#ifdef CONFIG_X86_32
-	if (!user_mode_vm(regs)) {
-#else
 	if (!user_mode(regs)) {
-#endif
 		preempt_disable();
 		if (kprobe_running() && kprobe_fault_handler(regs, 14))
 			ret = 1;
@@ -257,6 +256,30 @@ bad:
 #endif
 }
 
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault(struct pt_regs *regs);
+#endif
+
+#ifdef CONFIG_PAX_PAGEEXEC
+static inline pmd_t * pax_get_pmd(struct mm_struct *mm, unsigned long address)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+	pgd = pgd_offset(mm, address);
+	if (!pgd_present(*pgd))
+		return NULL;
+	pud = pud_offset(pgd, address);
+	if (!pud_present(*pud))
+		return NULL;
+	pmd = pmd_offset(pud, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	return pmd;
+}
+#endif
+
 #ifdef CONFIG_X86_32
 static inline pmd_t *vmalloc_sync_one(pgd_t *pgd, unsigned long address)
 {
@@ -343,7 +366,7 @@ static int is_errata93(struct pt_regs *r
 static int is_errata100(struct pt_regs *regs, unsigned long address)
 {
 #ifdef CONFIG_X86_64
-	if ((regs->cs == __USER32_CS || (regs->cs & (1<<2))) &&
+	if ((regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT)) &&
 	    (address >> 32))
 		return 1;
 #endif
@@ -380,17 +403,28 @@ static void show_fault_oops(struct pt_re
 #endif
 
 #ifdef CONFIG_X86_PAE
-	if (error_code & PF_INSTR) {
+	if (nx_enabled && (error_code & PF_INSTR)) {
 		unsigned int level;
 		pte_t *pte = lookup_address(address, &level);
 
 		if (pte && pte_present(*pte) && !pte_exec(*pte))
 			printk(KERN_CRIT "kernel tried to execute "
 				"NX-protected page - exploit attempt? "
-				"(uid: %d)\n", current->uid);
+				"(uid: %d, task: %s, pid: %d)\n",
+				current->uid, current->comm, task_pid_nr(current));
 	}
 #endif
 
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_MODULES
+	if (init_mm.start_code <= address && address < (unsigned long)MODULES_END)
+#else
+	if (init_mm.start_code <= address && address < init_mm.end_code)
+#endif
+		printk(KERN_ERR "PAX: %s:%d, uid/euid: %u/%u, attempted to modify kernel code\n",
+				 current->comm, task_pid_nr(current), current->uid, current->euid);
+#endif
+
 	printk(KERN_ALERT "BUG: unable to handle kernel ");
 	if (address < PAGE_SIZE)
 		printk(KERN_CONT "NULL pointer dereference");
@@ -583,13 +617,22 @@ void __kprobes do_page_fault(struct pt_r
 	struct task_struct *tsk;
 	struct mm_struct *mm;
 	struct vm_area_struct *vma;
-	unsigned long address;
 	int write, si_code;
 	int fault;
 #ifdef CONFIG_X86_64
 	unsigned long flags;
 #endif
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+	pte_t *pte;
+	pmd_t *pmd;
+	spinlock_t *ptl;
+	unsigned char pte_mask;
+#endif
+
+	/* get the address */
+	const unsigned long address = read_cr2();
+
 	/*
 	 * We can fault from pretty much anywhere, with unknown IRQ state.
 	 */
@@ -599,9 +642,6 @@ void __kprobes do_page_fault(struct pt_r
 	mm = tsk->mm;
 	prefetchw(&mm->mmap_sem);
 
-	/* get the address */
-	address = read_cr2();
-
 	si_code = SEGV_MAPERR;
 
 	if (notify_page_fault(regs))
@@ -652,7 +692,7 @@ void __kprobes do_page_fault(struct pt_r
 	 * atomic region then we must not take the fault.
 	 */
 	if (in_atomic() || !mm)
-		goto bad_area_nosemaphore;
+		goto bad_area_nopax;
 #else /* CONFIG_X86_64 */
 	if (likely(regs->flags & X86_EFLAGS_IF))
 		local_irq_enable();
@@ -665,13 +705,13 @@ void __kprobes do_page_fault(struct pt_r
 	 * atomic region then we must not take the fault.
 	 */
 	if (unlikely(in_atomic() || !mm))
-		goto bad_area_nosemaphore;
+		goto bad_area_nopax;
 
 	/*
 	 * User-mode registers count as a user access even for any
 	 * potential system fault or CPU buglet.
 	 */
-	if (user_mode_vm(regs))
+	if (user_mode(regs))
 		error_code |= PF_USER;
 again:
 #endif
@@ -693,10 +733,104 @@ again:
 	if (!down_read_trylock(&mm->mmap_sem)) {
 		if ((error_code & PF_USER) == 0 &&
 		    !search_exception_tables(regs->ip))
-			goto bad_area_nosemaphore;
+			goto bad_area_nopax;
 		down_read(&mm->mmap_sem);
 	}
 
+#if defined(CONFIG_X86_32) && defined(CONFIG_PAX_PAGEEXEC)
+	if (nx_enabled || (error_code & (PF_PROT|PF_USER)) != (PF_PROT|PF_USER) || v8086_mode(regs) ||
+	    !(mm->pax_flags & MF_PAX_PAGEEXEC))
+		goto not_pax_fault;
+
+	/* PaX: it's our fault, let's handle it if we can */
+
+	/* PaX: take a look at read faults before acquiring any locks */
+	if (unlikely(!(error_code & PF_WRITE) && (regs->ip == address))) {
+		/* instruction fetch attempt from a protected page in user mode */
+		up_read(&mm->mmap_sem);
+
+#ifdef CONFIG_PAX_EMUTRAMP
+		switch (pax_handle_fetch_fault(regs)) {
+		case 2:
+			return;
+		}
+#endif
+
+		pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+		do_group_exit(SIGKILL);
+	}
+
+	pmd = pax_get_pmd(mm, address);
+	if (unlikely(!pmd))
+		goto not_pax_fault;
+
+	pte = pte_offset_map_lock(mm, pmd, address, &ptl);
+	if (unlikely(!(pte_val(*pte) & _PAGE_PRESENT) || pte_user(*pte))) {
+		pte_unmap_unlock(pte, ptl);
+		goto not_pax_fault;
+	}
+
+	if (unlikely((error_code & PF_WRITE) && !pte_write(*pte))) {
+		/* write attempt to a protected page in user mode */
+		pte_unmap_unlock(pte, ptl);
+		goto not_pax_fault;
+	}
+
+#ifdef CONFIG_SMP
+	if (likely(address > get_limit(regs->cs) && cpu_isset(smp_processor_id(), mm->context.cpu_user_cs_mask)))
+#else
+	if (likely(address > get_limit(regs->cs)))
+#endif
+	{
+		set_pte(pte, pte_mkread(*pte));
+		__flush_tlb_one(address);
+		pte_unmap_unlock(pte, ptl);
+		up_read(&mm->mmap_sem);
+		return;
+	}
+
+	pte_mask = _PAGE_ACCESSED | _PAGE_USER | ((error_code & PF_WRITE) << (_PAGE_BIT_DIRTY-1));
+
+	/*
+	 * PaX: fill DTLB with user rights and retry
+	 */
+	__asm__ __volatile__ (
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"movw %w4,%%es\n"
+#endif
+		"orb %2,(%1)\n"
+#if defined(CONFIG_M586) || defined(CONFIG_M586TSC)
+/*
+ * PaX: let this uncommented 'invlpg' remind us on the behaviour of Intel's
+ * (and AMD's) TLBs. namely, they do not cache PTEs that would raise *any*
+ * page fault when examined during a TLB load attempt. this is true not only
+ * for PTEs holding a non-present entry but also present entries that will
+ * raise a page fault (such as those set up by PaX, or the copy-on-write
+ * mechanism). in effect it means that we do *not* need to flush the TLBs
+ * for our target pages since their PTEs are simply not in the TLBs at all.
+
+ * the best thing in omitting it is that we gain around 15-20% speed in the
+ * fast path of the page fault handler and can get rid of tracing since we
+ * can no longer flush unintended entries.
+ */
+		"invlpg (%0)\n"
+#endif
+		"testb $0,%%es:(%0)\n"
+		"xorb %3,(%1)\n"
+#ifdef CONFIG_PAX_MEMORY_UDEREF
+		"pushl %%ss\n"
+		"popl %%es\n"
+#endif
+		:
+		: "r" (address), "r" (pte), "q" (pte_mask), "i" (_PAGE_USER), "r" (__USER_DS)
+		: "memory", "cc");
+	pte_unmap_unlock(pte, ptl);
+	up_read(&mm->mmap_sem);
+	return;
+
+not_pax_fault:
+#endif
+
 	vma = find_vma(mm, address);
 	if (!vma)
 		goto bad_area;
@@ -714,6 +848,12 @@ again:
 		if (address + 65536 + 32 * sizeof(unsigned long) < regs->sp)
 			goto bad_area;
 	}
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if ((mm->pax_flags & MF_PAX_SEGMEXEC) && vma->vm_end - SEGMEXEC_TASK_SIZE - 1 < address - SEGMEXEC_TASK_SIZE - 1)
+		goto bad_area;
+#endif
+
 	if (expand_stack(vma, address))
 		goto bad_area;
 /*
@@ -723,6 +863,8 @@ again:
 good_area:
 	si_code = SEGV_ACCERR;
 	write = 0;
+	if (nx_enabled && (error_code & PF_INSTR) && !(vma->vm_flags & VM_EXEC))
+		goto bad_area;
 	switch (error_code & (PF_PROT|PF_WRITE)) {
 	default:	/* 3: write, present */
 		/* fall through */
@@ -780,6 +922,54 @@ bad_area:
 	up_read(&mm->mmap_sem);
 
 bad_area_nosemaphore:
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+	if (mm && (error_code & PF_USER)) {
+		unsigned long ip = regs->ip;
+
+		if (v8086_mode(regs))
+			ip = ((regs->cs & 0xffff) << 4) + (regs->ip & 0xffff);
+
+		/*
+		 * It's possible to have interrupts off here.
+		 */
+		local_irq_enable();
+
+#ifdef CONFIG_PAX_PAGEEXEC
+		if ((mm->pax_flags & MF_PAX_PAGEEXEC) &&
+		    (nx_enabled && ((error_code & PF_INSTR) || !(error_code & (PF_PROT | PF_WRITE))) && (regs->ip == address))) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 2:
+				return;
+			}
+#endif
+
+			pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if ((mm->pax_flags & MF_PAX_SEGMEXEC) && !(error_code & (PF_PROT | PF_WRITE)) && (regs->ip + SEGMEXEC_TASK_SIZE == address)) {
+
+#ifdef CONFIG_PAX_EMUTRAMP
+			switch (pax_handle_fetch_fault(regs)) {
+			case 2:
+				return;
+			}
+#endif
+
+			pax_report_fault(regs, (void *)regs->ip, (void *)regs->sp);
+			do_group_exit(SIGKILL);
+		}
+#endif
+
+	}
+#endif
+
+bad_area_nopax:
 	/* User mode accesses just cause a SIGSEGV */
 	if (error_code & PF_USER) {
 		/*
@@ -862,7 +1052,7 @@ no_context:
 #ifdef CONFIG_X86_32
 	die("Oops", regs, error_code);
 	bust_spinlocks(0);
-	do_exit(SIGKILL);
+	do_group_exit(SIGKILL);
 #else
 	if (__die("Oops", regs, error_code))
 		regs = NULL;
@@ -876,17 +1066,17 @@ no_context:
  * us unable to handle the page fault gracefully.
  */
 out_of_memory:
-	up_read(&mm->mmap_sem);
 	if (is_global_init(tsk)) {
 		yield();
 #ifdef CONFIG_X86_32
-		down_read(&mm->mmap_sem);
 		goto survive;
 #else
+		up_read(&mm->mmap_sem);
 		goto again;
 #endif
 	}
 
+	up_read(&mm->mmap_sem);
 	printk("VM: killing process %s\n", tsk->comm);
 	if (error_code & PF_USER)
 		do_group_exit(SIGKILL);
@@ -983,3 +1173,174 @@ void vmalloc_sync_all(void)
 	}
 #endif
 }
+
+#ifdef CONFIG_PAX_EMUTRAMP
+static int pax_handle_fetch_fault_32(struct pt_regs *regs)
+{
+	int err;
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned char mov1, mov2;
+		unsigned short jmp;
+		unsigned int addr1, addr2;
+
+#ifdef CONFIG_X86_64
+		if ((regs->ip + 11) >> 32)
+			break;
+#endif
+
+		err = get_user(mov1, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(mov2, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+		err |= get_user(jmp, (unsigned short __user *)(regs->ip + 10));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xB9 && mov2 == 0xB8 && jmp == 0xE0FF) {
+			regs->cx = addr1;
+			regs->ax = addr2;
+			regs->ip = addr2;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned char mov, jmp;
+		unsigned int addr1, addr2;
+
+#ifdef CONFIG_X86_64
+		if ((regs->ip + 9) >> 32)
+			break;
+#endif
+
+		err = get_user(mov, (unsigned char __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 1));
+		err |= get_user(jmp, (unsigned char __user *)(regs->ip + 5));
+		err |= get_user(addr2, (unsigned int __user *)(regs->ip + 6));
+
+		if (err)
+			break;
+
+		if (mov == 0xB9 && jmp == 0xE9) {
+			regs->cx = addr1;
+			regs->ip = (unsigned int)(regs->ip + addr2 + 10);
+			return 2;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+
+#ifdef CONFIG_X86_64
+static int pax_handle_fetch_fault_64(struct pt_regs *regs)
+{
+	int err;
+
+	do { /* PaX: gcc trampoline emulation #1 */
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned int addr1;
+		unsigned long addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned int __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 6));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 8));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 16));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 18));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB41 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return 2;
+		}
+	} while (0);
+
+	do { /* PaX: gcc trampoline emulation #2 */
+		unsigned short mov1, mov2, jmp1;
+		unsigned char jmp2;
+		unsigned long addr1, addr2;
+
+		err = get_user(mov1, (unsigned short __user *)regs->ip);
+		err |= get_user(addr1, (unsigned long __user *)(regs->ip + 2));
+		err |= get_user(mov2, (unsigned short __user *)(regs->ip + 10));
+		err |= get_user(addr2, (unsigned long __user *)(regs->ip + 12));
+		err |= get_user(jmp1, (unsigned short __user *)(regs->ip + 20));
+		err |= get_user(jmp2, (unsigned char __user *)(regs->ip + 22));
+
+		if (err)
+			break;
+
+		if (mov1 == 0xBB49 && mov2 == 0xBA49 && jmp1 == 0xFF49 && jmp2 == 0xE3) {
+			regs->r11 = addr1;
+			regs->r10 = addr2;
+			regs->ip = addr1;
+			return 2;
+		}
+	} while (0);
+
+	return 1; /* PaX in action */
+}
+#endif
+
+/*
+ * PaX: decide what to do with offenders (regs->ip = fault address)
+ *
+ * returns 1 when task should be killed
+ *         2 when gcc trampoline was detected
+ */
+static int pax_handle_fetch_fault(struct pt_regs *regs)
+{
+	if (v8086_mode(regs))
+		return 1;
+
+	if (!(current->mm->pax_flags & MF_PAX_EMUTRAMP))
+		return 1;
+
+#ifdef CONFIG_X86_32
+	return pax_handle_fetch_fault_32(regs);
+#else
+	if (regs->cs == __USER32_CS || (regs->cs & SEGMENT_LDT))
+		return pax_handle_fetch_fault_32(regs);
+	else
+		return pax_handle_fetch_fault_64(regs);
+#endif
+}
+#endif
+
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+void pax_report_insns(void *pc, void *sp)
+{
+	long i;
+
+	printk(KERN_ERR "PAX: bytes at PC: ");
+	for (i = 0; i < 20; i++) {
+		unsigned char c;
+		if (get_user(c, (unsigned char __user *)pc+i))
+			printk(KERN_CONT "?? ");
+		else
+			printk(KERN_CONT "%02x ", c);
+	}
+	printk("\n");
+
+	printk(KERN_ERR "PAX: bytes at SP-%lu: ", (unsigned long)sizeof(long));
+	for (i = -1; i < 80 / sizeof(long); i++) {
+		unsigned long c;
+		if (get_user(c, (unsigned long __user *)sp+i))
+#ifdef CONFIG_X86_32
+			printk(KERN_CONT "???????? ");
+#else
+			printk(KERN_CONT "???????????????? ");
+#endif
+		else
+			printk(KERN_CONT "%0*lx ", 2 * (int)sizeof(long), c);
+	}
+	printk("\n");
+}
+#endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/highmem_32.c linux-2.6.26.8-pax/arch/x86/mm/highmem_32.c
--- linux-2.6.26.8/arch/x86/mm/highmem_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/highmem_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -74,6 +74,10 @@ void *kmap_atomic_prot(struct page *page
 	enum fixed_addresses idx;
 	unsigned long vaddr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	/* even !CONFIG_PREEMPT needs this, for in_atomic in do_page_fault */
 	pagefault_disable();
 
@@ -85,7 +89,17 @@ void *kmap_atomic_prot(struct page *page
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
 	BUG_ON(!pte_none(*(kmap_pte-idx)));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte(kmap_pte-idx, mk_pte(page, prot));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	arch_flush_lazy_mmu_mode();
 
 	return (void *)vaddr;
@@ -101,15 +115,29 @@ void kunmap_atomic(void *kvaddr, enum km
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	enum fixed_addresses idx = type + KM_TYPE_NR*smp_processor_id();
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	/*
 	 * Force other mappings to Oops if they'll try to access this pte
 	 * without first remap it.  Keeping stale mappings around is a bad idea
 	 * also, in case the page changes cacheability attributes or becomes
 	 * a protected page in a hypervisor.
 	 */
-	if (vaddr == __fix_to_virt(FIX_KMAP_BEGIN+idx))
+	if (vaddr == __fix_to_virt(FIX_KMAP_BEGIN+idx)) {
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_open_kernel(cr0);
+#endif
+
 		kpte_clear_flush(kmap_pte-idx, vaddr);
-	else {
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+
+	} else {
 #ifdef CONFIG_DEBUG_HIGHMEM
 		BUG_ON(vaddr < PAGE_OFFSET);
 		BUG_ON(vaddr >= (unsigned long)high_memory);
@@ -128,11 +156,25 @@ void *kmap_atomic_pfn(unsigned long pfn,
 	enum fixed_addresses idx;
 	unsigned long vaddr;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	pagefault_disable();
 
 	idx = type + KM_TYPE_NR*smp_processor_id();
 	vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte(kmap_pte-idx, pfn_pte(pfn, kmap_prot));
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	arch_flush_lazy_mmu_mode();
 
 	return (void*) vaddr;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/hugetlbpage.c linux-2.6.26.8-pax/arch/x86/mm/hugetlbpage.c
--- linux-2.6.26.8/arch/x86/mm/hugetlbpage.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/hugetlbpage.c	2008-07-14 03:52:23.000000000 +0200
@@ -230,13 +230,18 @@ static unsigned long hugetlb_get_unmappe
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
-	unsigned long start_addr;
+	unsigned long start_addr, pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (len > mm->cached_hole_size) {
-	        start_addr = mm->free_area_cache;
+		start_addr = mm->free_area_cache;
 	} else {
-	        start_addr = TASK_UNMAPPED_BASE;
-	        mm->cached_hole_size = 0;
+		start_addr = mm->mmap_base;
+		mm->cached_hole_size = 0;
 	}
 
 full_search:
@@ -244,13 +249,13 @@ full_search:
 
 	for (vma = find_vma(mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
-		if (TASK_SIZE - len < addr) {
+		if (pax_task_size - len < addr) {
 			/*
 			 * Start a new search - just in case we missed
 			 * some holes.
 			 */
-			if (start_addr != TASK_UNMAPPED_BASE) {
-				start_addr = TASK_UNMAPPED_BASE;
+			if (start_addr != mm->mmap_base) {
+				start_addr = mm->mmap_base;
 				mm->cached_hole_size = 0;
 				goto full_search;
 			}
@@ -272,9 +277,8 @@ static unsigned long hugetlb_get_unmappe
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma, *prev_vma;
-	unsigned long base = mm->mmap_base, addr = addr0;
+	unsigned long base = mm->mmap_base, addr;
 	unsigned long largest_hole = mm->cached_hole_size;
-	int first_time = 1;
 
 	/* don't allow allocations above current base */
 	if (mm->free_area_cache > base)
@@ -284,7 +288,7 @@ static unsigned long hugetlb_get_unmappe
 	        largest_hole = 0;
 		mm->free_area_cache  = base;
 	}
-try_again:
+
 	/* make sure it can fit in the remaining address space */
 	if (mm->free_area_cache < len)
 		goto fail;
@@ -326,22 +330,26 @@ try_again:
 
 fail:
 	/*
-	 * if hint left us with no space for the requested
-	 * mapping then try again:
-	 */
-	if (first_time) {
-		mm->free_area_cache = base;
-		largest_hole = 0;
-		first_time = 0;
-		goto try_again;
-	}
-	/*
 	 * A failed mmap() very likely causes application failure,
 	 * so fall back to the bottom-up function here. This scenario
 	 * can happen with large stack limits and large mmap()
 	 * allocations.
 	 */
-	mm->free_area_cache = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		mm->mmap_base = SEGMEXEC_TASK_UNMAPPED_BASE;
+	else
+#endif
+
+	mm->mmap_base = TASK_UNMAPPED_BASE;
+
+#ifdef CONFIG_PAX_RANDMMAP
+	if (mm->pax_flags & MF_PAX_RANDMMAP)
+		mm->mmap_base += mm->delta_mmap;
+#endif
+
+	mm->free_area_cache = mm->mmap_base;
 	mm->cached_hole_size = ~0UL;
 	addr = hugetlb_get_unmapped_area_bottomup(file, addr0,
 			len, pgoff, flags);
@@ -349,6 +357,7 @@ fail:
 	/*
 	 * Restore the topdown base:
 	 */
+	mm->mmap_base = base;
 	mm->free_area_cache = base;
 	mm->cached_hole_size = ~0UL;
 
@@ -361,10 +370,17 @@ hugetlb_get_unmapped_area(struct file *f
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
+	unsigned long pax_task_size = TASK_SIZE;
 
 	if (len & ~HPAGE_MASK)
 		return -EINVAL;
-	if (len > TASK_SIZE)
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
+
+	if (len > pax_task_size)
 		return -ENOMEM;
 
 	if (flags & MAP_FIXED) {
@@ -376,7 +392,7 @@ hugetlb_get_unmapped_area(struct file *f
 	if (addr) {
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
+		if (pax_task_size - len >= addr &&
 		    (!vma || addr + len <= vma->vm_start))
 			return addr;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/init_32.c linux-2.6.26.8-pax/arch/x86/mm/init_32.c
--- linux-2.6.26.8/arch/x86/mm/init_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/init_32.c	2008-09-03 03:28:09.000000000 +0200
@@ -47,6 +47,7 @@
 #include <asm/paravirt.h>
 #include <asm/setup.h>
 #include <asm/cacheflush.h>
+#include <asm/desc.h>
 
 unsigned int __VMALLOC_RESERVE = 128 << 20;
 
@@ -58,32 +59,6 @@ unsigned long highstart_pfn, highend_pfn
 static noinline int do_test_wp_bit(void);
 
 /*
- * Creates a middle page table and puts a pointer to it in the
- * given global directory entry. This only returns the gd entry
- * in non-PAE compilation mode, since the middle layer is folded.
- */
-static pmd_t * __init one_md_table_init(pgd_t *pgd)
-{
-	pud_t *pud;
-	pmd_t *pmd_table;
-
-#ifdef CONFIG_X86_PAE
-	if (!(pgd_val(*pgd) & _PAGE_PRESENT)) {
-		pmd_table = (pmd_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-
-		paravirt_alloc_pmd(&init_mm, __pa(pmd_table) >> PAGE_SHIFT);
-		set_pgd(pgd, __pgd(__pa(pmd_table) | _PAGE_PRESENT));
-		pud = pud_offset(pgd, 0);
-		BUG_ON(pmd_table != pmd_offset(pud, 0));
-	}
-#endif
-	pud = pud_offset(pgd, 0);
-	pmd_table = pmd_offset(pud, 0);
-
-	return pmd_table;
-}
-
-/*
  * Create a page table and place a pointer to it in a middle page
  * directory entry:
  */
@@ -101,7 +76,11 @@ static pte_t * __init one_page_table_ini
 		}
 
 		paravirt_alloc_pte(&init_mm, __pa(page_table) >> PAGE_SHIFT);
+#if defined(CONFIG_PAX_PAGEEXEC) || defined(CONFIG_PAX_SEGMEXEC)
+		set_pmd(pmd, __pmd(__pa(page_table) | _KERNPG_TABLE));
+#else
 		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+#endif
 		BUG_ON(page_table != pte_offset_kernel(pmd, 0));
 	}
 
@@ -123,6 +102,7 @@ page_table_range_init(unsigned long star
 	int pgd_idx, pmd_idx;
 	unsigned long vaddr;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 
 	vaddr = start;
@@ -131,8 +111,13 @@ page_table_range_init(unsigned long star
 	pgd = pgd_base + pgd_idx;
 
 	for ( ; (pgd_idx < PTRS_PER_PGD) && (vaddr != end); pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
-		pmd = pmd + pmd_index(vaddr);
+		pud = pud_offset(pgd, vaddr);
+		pmd = pmd_offset(pud, vaddr);
+
+#ifdef CONFIG_X86_PAE
+		paravirt_alloc_pmd(&init_mm, __pa(pmd) >> PAGE_SHIFT);
+#endif
+
 		for (; (pmd_idx < PTRS_PER_PMD) && (vaddr != end);
 							pmd++, pmd_idx++) {
 			one_page_table_init(pmd);
@@ -143,11 +128,23 @@ page_table_range_init(unsigned long star
 	}
 }
 
-static inline int is_kernel_text(unsigned long addr)
+static inline int is_kernel_text(unsigned long start, unsigned long end)
 {
-	if (addr >= PAGE_OFFSET && addr <= (unsigned long)__init_end)
-		return 1;
-	return 0;
+	unsigned long etext;
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	etext = ktva_ktla((unsigned long)&MODULES_END);
+#else
+	etext = (unsigned long)&_etext;
+#endif
+
+	if ((start > ktla_ktva(etext) ||
+	     end <= ktla_ktva((unsigned long)_stext)) &&
+	    (start > ktla_ktva((unsigned long)_einittext) ||
+	     end <= ktla_ktva((unsigned long)_sinittext)) &&
+	    (start > (unsigned long)__va(0xfffff) || end <= (unsigned long)__va(0xc0000)))
+		return 0;
+	return 1;
 }
 
 /*
@@ -157,9 +154,10 @@ static inline int is_kernel_text(unsigne
  */
 static void __init kernel_physical_mapping_init(pgd_t *pgd_base)
 {
-	int pgd_idx, pmd_idx, pte_ofs;
+	unsigned int pgd_idx, pmd_idx, pte_ofs;
 	unsigned long pfn;
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 
@@ -167,15 +165,18 @@ static void __init kernel_physical_mappi
 	pgd = pgd_base + pgd_idx;
 	pfn = 0;
 
-	for (; pgd_idx < PTRS_PER_PGD; pgd++, pgd_idx++) {
-		pmd = one_md_table_init(pgd);
-		if (pfn >= max_low_pfn)
-			continue;
+	for (; pgd_idx < PTRS_PER_PGD && pfn < max_low_pfn; pgd++, pgd_idx++) {
+		pud = pud_offset(pgd, 0);
+		pmd = pmd_offset(pud, 0);
+
+#ifdef CONFIG_X86_PAE
+		paravirt_alloc_pmd(&init_mm, __pa(pmd) >> PAGE_SHIFT);
+#endif
 
 		for (pmd_idx = 0;
 		     pmd_idx < PTRS_PER_PMD && pfn < max_low_pfn;
 		     pmd++, pmd_idx++) {
-			unsigned int addr = pfn * PAGE_SIZE + PAGE_OFFSET;
+			unsigned long address = pfn * PAGE_SIZE + PAGE_OFFSET;
 
 			/*
 			 * Map with big pages if possible, otherwise
@@ -187,14 +188,9 @@ static void __init kernel_physical_mappi
 			 * slowdowns.
 			 */
 			if (cpu_has_pse && !(pgd_idx == 0 && pmd_idx == 0)) {
-				unsigned int addr2;
 				pgprot_t prot = PAGE_KERNEL_LARGE;
 
-				addr2 = (pfn + PTRS_PER_PTE-1) * PAGE_SIZE +
-					PAGE_OFFSET + PAGE_SIZE-1;
-
-				if (is_kernel_text(addr) ||
-				    is_kernel_text(addr2))
+				if (is_kernel_text(address, address + PMD_SIZE))
 					prot = PAGE_KERNEL_LARGE_EXEC;
 
 				set_pmd(pmd, pfn_pmd(pfn, prot));
@@ -207,10 +203,10 @@ static void __init kernel_physical_mappi
 
 			for (pte_ofs = 0;
 			     pte_ofs < PTRS_PER_PTE && pfn < max_low_pfn;
-			     pte++, pfn++, pte_ofs++, addr += PAGE_SIZE) {
+			     pte++, pfn++, pte_ofs++, address += PAGE_SIZE) {
 				pgprot_t prot = PAGE_KERNEL;
 
-				if (is_kernel_text(addr))
+				if (is_kernel_text(address, address + PAGE_SIZE))
 					prot = PAGE_KERNEL_EXEC;
 
 				set_pte(pte, pfn_pte(pfn, prot));
@@ -239,7 +235,9 @@ static inline int page_kills_ppro(unsign
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
-	if (pagenr <= 256)
+	if (!pagenr)
+		return 1;
+	if ((ISA_START_ADDRESS >> PAGE_SHIFT) <= pagenr && pagenr < (ISA_END_ADDRESS >> PAGE_SHIFT))
 		return 1;
 	if (!page_is_ram(pagenr))
 		return 1;
@@ -320,10 +318,10 @@ static void __init set_highmem_pages_ini
 # define set_highmem_pages_init(bad_ppro)	do { } while (0)
 #endif /* CONFIG_HIGHMEM */
 
-pteval_t __PAGE_KERNEL = _PAGE_KERNEL;
+pteval_t __PAGE_KERNEL __read_only = _PAGE_KERNEL;
 EXPORT_SYMBOL(__PAGE_KERNEL);
 
-pteval_t __PAGE_KERNEL_EXEC = _PAGE_KERNEL_EXEC;
+pteval_t __PAGE_KERNEL_EXEC __read_only = _PAGE_KERNEL_EXEC;
 
 void __init native_pagetable_setup_start(pgd_t *base)
 {
@@ -345,7 +343,7 @@ void __init native_pagetable_setup_start
 
 		pud = pud_offset(pgd, va);
 		pmd = pmd_offset(pud, va);
-		if (!pmd_present(*pmd))
+		if (!pmd_present(*pmd) || pmd_huge(*pmd))
 			break;
 
 		pte = pte_offset_kernel(pmd, va);
@@ -421,12 +419,12 @@ static void __init pagetable_init(void)
  * ACPI suspend needs this for resume, because things like the intel-agp
  * driver might have split up a kernel 4MB mapping.
  */
-char swsusp_pg_dir[PAGE_SIZE]
+pgd_t swsusp_pg_dir[PTRS_PER_PGD]
 	__attribute__ ((aligned(PAGE_SIZE)));
 
 static inline void save_pg_dir(void)
 {
-	memcpy(swsusp_pg_dir, swapper_pg_dir, PAGE_SIZE);
+	clone_pgd_range(swsusp_pg_dir, swapper_pg_dir, PTRS_PER_PGD);
 }
 #else /* !CONFIG_ACPI_SLEEP */
 static inline void save_pg_dir(void)
@@ -456,13 +454,11 @@ void zap_low_mappings(void)
 
 int nx_enabled;
 
-pteval_t __supported_pte_mask __read_mostly = ~_PAGE_NX;
+pteval_t __supported_pte_mask __read_only = ~_PAGE_NX;
 EXPORT_SYMBOL_GPL(__supported_pte_mask);
 
 #ifdef CONFIG_X86_PAE
 
-static int disable_nx __initdata;
-
 /*
  * noexec = on|off
  *
@@ -471,40 +467,33 @@ static int disable_nx __initdata;
  * on      Enable
  * off     Disable
  */
+#if !defined(CONFIG_PAX_PAGEEXEC)
 static int __init noexec_setup(char *str)
 {
 	if (!str || !strcmp(str, "on")) {
-		if (cpu_has_nx) {
-			__supported_pte_mask |= _PAGE_NX;
-			disable_nx = 0;
-		}
+		if (cpu_has_nx)
+			nx_enabled = 1;
 	} else {
-		if (!strcmp(str, "off")) {
-			disable_nx = 1;
-			__supported_pte_mask &= ~_PAGE_NX;
-		} else {
+		if (!strcmp(str, "off"))
+			nx_enabled = 0;
+		else
 			return -EINVAL;
-		}
 	}
 
 	return 0;
 }
 early_param("noexec", noexec_setup);
+#endif
 
 static void __init set_nx(void)
 {
-	unsigned int v[4], l, h;
-
-	if (cpu_has_pae && (cpuid_eax(0x80000000) > 0x80000001)) {
-		cpuid(0x80000001, &v[0], &v[1], &v[2], &v[3]);
+	if (!nx_enabled && cpu_has_nx) {
+		unsigned l, h;
 
-		if ((v[3] & (1 << 20)) && !disable_nx) {
-			rdmsr(MSR_EFER, l, h);
-			l |= EFER_NX;
-			wrmsr(MSR_EFER, l, h);
-			nx_enabled = 1;
-			__supported_pte_mask |= _PAGE_NX;
-		}
+		__supported_pte_mask &= ~_PAGE_NX;
+		rdmsr(MSR_EFER, l, h);
+		l &= ~EFER_NX;
+		wrmsr(MSR_EFER, l, h);
 	}
 }
 #endif
@@ -596,7 +585,7 @@ void __init mem_init(void)
 	set_highmem_pages_init(bad_ppro);
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
-	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
+	datasize =  (unsigned long) &_edata - (unsigned long) &_data;
 	initsize =  (unsigned long) &__init_end - (unsigned long) &__init_begin;
 
 	kclist_add(&kcore_mem, __va(0), max_low_pfn << PAGE_SHIFT);
@@ -643,10 +632,10 @@ void __init mem_init(void)
 		((unsigned long)&__init_end -
 		 (unsigned long)&__init_begin) >> 10,
 
-		(unsigned long)&_etext, (unsigned long)&_edata,
-		((unsigned long)&_edata - (unsigned long)&_etext) >> 10,
+		(unsigned long)&_data, (unsigned long)&_edata,
+		((unsigned long)&_edata - (unsigned long)&_data) >> 10,
 
-		(unsigned long)&_text, (unsigned long)&_etext,
+		ktla_ktva((unsigned long)&_text), ktla_ktva((unsigned long)&_etext),
 		((unsigned long)&_etext - (unsigned long)&_text) >> 10);
 
 #ifdef CONFIG_HIGHMEM
@@ -773,6 +762,46 @@ void free_init_pages(char *what, unsigne
 
 void free_initmem(void)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	/* PaX: limit KERNEL_CS to actual size */
+	unsigned long addr, limit;
+	struct desc_struct d;
+	int cpu;
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+#ifdef CONFIG_MODULES
+	limit = ktva_ktla((unsigned long)&MODULES_END);
+#else
+	limit = (unsigned long)&_etext;
+#endif
+	limit = (limit - 1UL) >> PAGE_SHIFT;
+
+	for (cpu = 0; cpu < NR_CPUS; cpu++) {
+		pack_descriptor(&d, get_desc_base(&get_cpu_gdt_table(cpu)[GDT_ENTRY_KERNEL_CS]), limit, 0x9B, 0xC);
+		write_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_KERNEL_CS, &d, DESCTYPE_S);
+	}
+
+	/* PaX: make KERNEL_CS read-only */
+	for (addr = ktla_ktva((unsigned long)&_text); addr < (unsigned long)&_data; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+	}
+#ifdef CONFIG_X86_PAE
+	for (addr = (unsigned long)&__init_begin; addr < (unsigned long)&__init_end; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
+	}
+#endif
+	flush_tlb_all();
+#endif
+
 	free_init_pages("unused kernel memory",
 			(unsigned long)(&__init_begin),
 			(unsigned long)(&__init_end));
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/init_64.c linux-2.6.26.8-pax/arch/x86/mm/init_64.c
--- linux-2.6.26.8/arch/x86/mm/init_64.c	2008-08-03 19:20:46.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/init_64.c	2008-09-03 03:28:40.000000000 +0200
@@ -143,6 +143,10 @@ set_pte_phys(unsigned long vaddr, unsign
 	pmd_t *pmd;
 	pte_t *pte, new_pte;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	pr_debug("set_pte_phys %lx to %lx\n", vaddr, phys);
 
 	pgd = pgd_offset_k(vaddr);
@@ -154,7 +158,7 @@ set_pte_phys(unsigned long vaddr, unsign
 	pud = pud_offset(pgd, vaddr);
 	if (pud_none(*pud)) {
 		pmd = (pmd_t *) spp_getpage();
-		set_pud(pud, __pud(__pa(pmd) | _KERNPG_TABLE | _PAGE_USER));
+		set_pud(pud, __pud(__pa(pmd) | _PAGE_TABLE));
 		if (pmd != pmd_offset(pud, 0)) {
 			printk(KERN_ERR "PAGETABLE BUG #01! %p <-> %p\n",
 				pmd, pmd_offset(pud, 0));
@@ -164,7 +168,7 @@ set_pte_phys(unsigned long vaddr, unsign
 	pmd = pmd_offset(pud, vaddr);
 	if (pmd_none(*pmd)) {
 		pte = (pte_t *) spp_getpage();
-		set_pmd(pmd, __pmd(__pa(pte) | _KERNPG_TABLE | _PAGE_USER));
+		set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
 		if (pte != pte_offset_kernel(pmd, 0)) {
 			printk(KERN_ERR "PAGETABLE BUG #02!\n");
 			return;
@@ -176,8 +180,17 @@ set_pte_phys(unsigned long vaddr, unsign
 	if (!pte_none(*pte) && pte_val(new_pte) &&
 	    pte_val(*pte) != (pte_val(new_pte) & __supported_pte_mask))
 		pte_ERROR(*pte);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	set_pte(pte, new_pte);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/*
 	 * It's enough to flush this one mapping.
 	 * (PGE mappings get flushed as well)
@@ -667,7 +680,9 @@ EXPORT_SYMBOL_GPL(memory_add_physaddr_to
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
-	if (pagenr <= 256)
+	if (!pagenr)
+		return 1;
+	if ((ISA_START_ADDRESS >> PAGE_SHIFT) <= pagenr && pagenr < (ISA_END_ADDRESS >> PAGE_SHIFT))
 		return 1;
 	if (!page_is_ram(pagenr))
 		return 1;
@@ -755,6 +770,39 @@ void free_init_pages(char *what, unsigne
 
 void free_initmem(void)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long addr, end;
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+
+	/* PaX: make kernel code/rodata read-only, rest non-executable */
+	for (addr = __START_KERNEL_map; addr < __START_KERNEL_map + KERNEL_IMAGE_SIZE; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		if ((unsigned long)_text <= addr && addr < (unsigned long)_data)
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+		else
+			set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
+	}
+
+	addr = (unsigned long)__va(__pa(__START_KERNEL_map));
+	end = addr + KERNEL_IMAGE_SIZE;
+	for (; addr < end; addr += PMD_SIZE) {
+		pgd = pgd_offset_k(addr);
+		pud = pud_offset(pgd, addr);
+		pmd = pmd_offset(pud, addr);
+		if ((unsigned long)__va(__pa(_text)) <= addr && addr < (unsigned long)__va(__pa(_data)))
+			set_pmd(pmd, __pmd(pmd_val(*pmd) & ~_PAGE_RW));
+		else
+			set_pmd(pmd, __pmd(pmd_val(*pmd) | (_PAGE_NX & __supported_pte_mask)));
+	}
+
+	flush_tlb_all();
+#endif
+
 	free_init_pages("unused kernel memory",
 			(unsigned long)(&__init_begin),
 			(unsigned long)(&__init_end));
@@ -913,7 +961,7 @@ int in_gate_area_no_task(unsigned long a
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
+	if (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso)
 		return "[vdso]";
 	if (vma == &gate_vma)
 		return "[vsyscall]";
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/ioremap.c linux-2.6.26.8-pax/arch/x86/mm/ioremap.c
--- linux-2.6.26.8/arch/x86/mm/ioremap.c	2008-10-23 11:01:02.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/ioremap.c	2008-10-23 11:01:17.000000000 +0200
@@ -62,8 +62,8 @@ int page_is_ram(unsigned long pagenr)
 	 * Second special case: Some BIOSen report the PC BIOS
 	 * area (640->1Mb) as ram even though it is not.
 	 */
-	if (pagenr >= (BIOS_BEGIN >> PAGE_SHIFT) &&
-		    pagenr < (BIOS_END >> PAGE_SHIFT))
+	if (pagenr >= (ISA_START_ADDRESS >> PAGE_SHIFT) &&
+		    pagenr < (ISA_END_ADDRESS >> PAGE_SHIFT))
 		return 0;
 
 	for (i = 0; i < e820.nr_map; i++) {
@@ -213,6 +213,8 @@ static void __iomem *__ioremap_caller(re
 		break;
 	}
 
+	prot = canon_pgprot(prot);
+
 	/*
 	 * Ok, go for it..
 	 */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/mmap.c linux-2.6.26.8-pax/arch/x86/mm/mmap.c
--- linux-2.6.26.8/arch/x86/mm/mmap.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/mmap.c	2008-07-14 03:52:23.000000000 +0200
@@ -36,7 +36,7 @@
  * Leave an at least ~128 MB hole.
  */
 #define MIN_GAP (128*1024*1024)
-#define MAX_GAP (TASK_SIZE/6*5)
+#define MAX_GAP (pax_task_size/6*5)
 
 /*
  * True on X86_32 or when emulating IA32 on X86_64
@@ -81,27 +81,40 @@ static unsigned long mmap_rnd(void)
 	return rnd << PAGE_SHIFT;
 }
 
-static unsigned long mmap_base(void)
+static unsigned long mmap_base(struct mm_struct *mm)
 {
 	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long pax_task_size = TASK_SIZE;
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (mm->pax_flags & MF_PAX_SEGMEXEC)
+		pax_task_size = SEGMEXEC_TASK_SIZE;
+#endif
 
 	if (gap < MIN_GAP)
 		gap = MIN_GAP;
 	else if (gap > MAX_GAP)
 		gap = MAX_GAP;
 
-	return PAGE_ALIGN(TASK_SIZE - gap - mmap_rnd());
+	return PAGE_ALIGN(pax_task_size - gap - mmap_rnd());
 }
 
 /*
  * Bottom-up (legacy) layout on X86_32 did not support randomization, X86_64
  * does, but not when emulating X86_32
  */
-static unsigned long mmap_legacy_base(void)
+static unsigned long mmap_legacy_base(struct mm_struct *mm)
 {
-	if (mmap_is_ia32())
+	if (mmap_is_ia32()) {
+
+#ifdef CONFIG_PAX_SEGMEXEC
+		if (mm->pax_flags & MF_PAX_SEGMEXEC)
+			return SEGMEXEC_TASK_UNMAPPED_BASE;
+		else
+#endif
+
 		return TASK_UNMAPPED_BASE;
-	else
+	} else
 		return TASK_UNMAPPED_BASE + mmap_rnd();
 }
 
@@ -112,11 +125,23 @@ static unsigned long mmap_legacy_base(vo
 void arch_pick_mmap_layout(struct mm_struct *mm)
 {
 	if (mmap_is_legacy()) {
-		mm->mmap_base = mmap_legacy_base();
+		mm->mmap_base = mmap_legacy_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base += mm->delta_mmap;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
 	} else {
-		mm->mmap_base = mmap_base();
+		mm->mmap_base = mmap_base(mm);
+
+#ifdef CONFIG_PAX_RANDMMAP
+		if (mm->pax_flags & MF_PAX_RANDMMAP)
+			mm->mmap_base -= mm->delta_mmap + mm->delta_stack;
+#endif
+
 		mm->get_unmapped_area = arch_get_unmapped_area_topdown;
 		mm->unmap_area = arch_unmap_area_topdown;
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/numa_64.c linux-2.6.26.8-pax/arch/x86/mm/numa_64.c
--- linux-2.6.26.8/arch/x86/mm/numa_64.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/numa_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -21,7 +21,7 @@
 #include <asm/k8.h>
 
 #ifndef Dprintk
-#define Dprintk(x...)
+#define Dprintk(x...) do {} while (0)
 #endif
 
 struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/pageattr.c linux-2.6.26.8-pax/arch/x86/mm/pageattr.c
--- linux-2.6.26.8/arch/x86/mm/pageattr.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/pageattr.c	2008-10-09 04:13:06.000000000 +0200
@@ -20,6 +20,7 @@
 #include <asm/pgalloc.h>
 #include <asm/proto.h>
 #include <asm/pat.h>
+#include <asm/desc.h>
 
 /*
  * The current flushing context - we pass it instead of 5 arguments:
@@ -172,7 +173,7 @@ static inline pgprot_t static_protection
 	 * Does not cover __inittext since that is gone later on. On
 	 * 64bit we do not enforce !NX on the low mapping
 	 */
-	if (within(address, (unsigned long)_text, (unsigned long)_etext))
+	if (within(address, ktla_ktva((unsigned long)_text), ktla_ktva((unsigned long)_etext)))
 		pgprot_val(forbidden) |= _PAGE_NX;
 
 	/*
@@ -233,8 +234,20 @@ pte_t *lookup_address(unsigned long addr
  */
 static void __set_pmd_pte(pte_t *kpte, unsigned long address, pte_t pte)
 {
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+
+	pax_open_kernel(cr0);
+#endif
+
 	/* change init_mm */
 	set_pte_atomic(kpte, pte);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 #ifdef CONFIG_X86_32
 	if (!SHARED_KERNEL_PMD) {
 		struct page *page;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/pat.c linux-2.6.26.8-pax/arch/x86/mm/pat.c
--- linux-2.6.26.8/arch/x86/mm/pat.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/pat.c	2008-07-24 23:20:21.000000000 +0200
@@ -471,7 +471,7 @@ pgprot_t phys_mem_access_prot(struct fil
 	return vma_prot;
 }
 
-#ifdef CONFIG_NONPROMISC_DEVMEM
+#ifndef CONFIG_NONPROMISC_DEVMEM
 /* This check is done in drivers/char/mem.c in case of NONPROMISC_DEVMEM*/
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/mm/pgtable_32.c linux-2.6.26.8-pax/arch/x86/mm/pgtable_32.c
--- linux-2.6.26.8/arch/x86/mm/pgtable_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/mm/pgtable_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -78,6 +78,10 @@ static void set_pte_pfn(unsigned long va
 	pmd_t *pmd;
 	pte_t *pte;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	pgd = swapper_pg_dir + pgd_index(vaddr);
 	if (pgd_none(*pgd)) {
 		BUG();
@@ -94,11 +98,20 @@ static void set_pte_pfn(unsigned long va
 		return;
 	}
 	pte = pte_offset_kernel(pmd, vaddr);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	if (pgprot_val(flags))
 		set_pte_present(&init_mm, vaddr, pte, pfn_pte(pfn, flags));
 	else
 		pte_clear(&init_mm, vaddr, pte);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/*
 	 * It's enough to flush this one mapping.
 	 * (PGE mappings get flushed as well)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/oprofile/backtrace.c linux-2.6.26.8-pax/arch/x86/oprofile/backtrace.c
--- linux-2.6.26.8/arch/x86/oprofile/backtrace.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/oprofile/backtrace.c	2008-07-14 03:52:23.000000000 +0200
@@ -37,7 +37,7 @@ static void backtrace_address(void *data
 	unsigned int *depth = data;
 
 	if ((*depth)--)
-		oprofile_add_trace(addr);
+		oprofile_add_trace(ktla_ktva(addr));
 }
 
 static struct stacktrace_ops backtrace_ops = {
@@ -79,7 +79,7 @@ x86_backtrace(struct pt_regs * const reg
 	struct frame_head *head = (struct frame_head *)frame_pointer(regs);
 	unsigned long stack = kernel_trap_sp(regs);
 
-	if (!user_mode_vm(regs)) {
+	if (!user_mode(regs)) {
 		if (depth)
 			dump_trace(NULL, regs, (unsigned long *)stack, 0,
 				   &backtrace_ops, &depth);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/oprofile/op_model_p4.c linux-2.6.26.8-pax/arch/x86/oprofile/op_model_p4.c
--- linux-2.6.26.8/arch/x86/oprofile/op_model_p4.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/oprofile/op_model_p4.c	2008-07-14 03:52:23.000000000 +0200
@@ -47,7 +47,7 @@ static inline void setup_num_counters(vo
 #endif
 }
 
-static int inline addr_increment(void)
+static inline int addr_increment(void)
 {
 #ifdef CONFIG_SMP
 	return smp_num_siblings == 2 ? 2 : 1;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/pci/common.c linux-2.6.26.8-pax/arch/x86/pci/common.c
--- linux-2.6.26.8/arch/x86/pci/common.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/pci/common.c	2008-07-14 03:54:50.000000000 +0200
@@ -342,7 +342,7 @@ static struct dmi_system_id __devinitdat
 			DMI_MATCH(DMI_PRODUCT_NAME, "ProLiant DL585 G2"),
 		},
 	},
-	{}
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 void __init dmi_check_pciprobe(void)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/pci/early.c linux-2.6.26.8-pax/arch/x86/pci/early.c
--- linux-2.6.26.8/arch/x86/pci/early.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/pci/early.c	2008-07-14 03:52:23.000000000 +0200
@@ -7,7 +7,7 @@
 /* Direct PCI access. This is used for PCI accesses in early boot before
    the PCI subsystem works. */
 
-#define PDprintk(x...)
+#define PDprintk(x...) do {} while (0)
 
 u32 read_pci_config(u8 bus, u8 slot, u8 func, u8 offset)
 {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/pci/fixup.c linux-2.6.26.8-pax/arch/x86/pci/fixup.c
--- linux-2.6.26.8/arch/x86/pci/fixup.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/pci/fixup.c	2008-07-14 03:52:23.000000000 +0200
@@ -364,7 +364,7 @@ static struct dmi_system_id __devinitdat
 			DMI_MATCH(DMI_PRODUCT_NAME, "MS-6702E"),
 		},
 	},
-	{}
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 /*
@@ -435,7 +435,7 @@ static struct dmi_system_id __devinitdat
 			DMI_MATCH(DMI_PRODUCT_VERSION, "PSA40U"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 static void __devinit pci_pre_fixup_toshiba_ohci1394(struct pci_dev *dev)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/pci/irq.c linux-2.6.26.8-pax/arch/x86/pci/irq.c
--- linux-2.6.26.8/arch/x86/pci/irq.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/pci/irq.c	2008-07-14 03:52:23.000000000 +0200
@@ -542,7 +542,7 @@ static __init int intel_router_probe(str
 	static struct pci_device_id __initdata pirq_440gx[] = {
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_0) },
 		{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_2) },
-		{ },
+		{ PCI_DEVICE(0, 0) }
 	};
 
 	/* 440GX has a proprietary PIRQ router -- don't use it */
@@ -1115,7 +1115,7 @@ static struct dmi_system_id __initdata p
 			DMI_MATCH(DMI_PRODUCT_NAME, "TravelMate 360"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 static int __init pcibios_irq_init(void)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/pci/pcbios.c linux-2.6.26.8-pax/arch/x86/pci/pcbios.c
--- linux-2.6.26.8/arch/x86/pci/pcbios.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/pci/pcbios.c	2008-07-14 03:52:23.000000000 +0200
@@ -57,50 +57,120 @@ union bios32 {
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} bios32_indirect = { 0, __KERNEL_CS };
+} bios32_indirect __read_only = { 0, __PCIBIOS_CS };
 
 /*
  * Returns the entry point for the given service, NULL on error
  */
 
-static unsigned long bios32_service(unsigned long service)
+static unsigned long __devinit bios32_service(unsigned long service)
 {
 	unsigned char return_code;	/* %al */
 	unsigned long address;		/* %ebx */
 	unsigned long length;		/* %ecx */
 	unsigned long entry;		/* %edx */
 	unsigned long flags;
+	struct desc_struct d, *gdt;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
 
 	local_irq_save(flags);
-	__asm__("lcall *(%%edi); cld"
+
+	gdt = get_cpu_gdt_table(smp_processor_id());
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	pack_descriptor(&d, 0UL, 0xFFFFFUL, 0x9B, 0xC);
+	write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_CS, &d, DESCTYPE_S);
+	pack_descriptor(&d, 0UL, 0xFFFFFUL, 0x93, 0xC);
+	write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_DS, &d, DESCTYPE_S);
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
+	__asm__("movw %w7, %%ds; lcall *(%%edi); push %%ss; pop %%ds; cld"
 		: "=a" (return_code),
 		  "=b" (address),
 		  "=c" (length),
 		  "=d" (entry)
 		: "0" (service),
 		  "1" (0),
-		  "D" (&bios32_indirect));
+		  "D" (&bios32_indirect),
+		  "r"(__PCIBIOS_DS)
+		: "memory");
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
+	gdt[GDT_ENTRY_PCIBIOS_CS].a = 0;
+	gdt[GDT_ENTRY_PCIBIOS_CS].b = 0;
+	gdt[GDT_ENTRY_PCIBIOS_DS].a = 0;
+	gdt[GDT_ENTRY_PCIBIOS_DS].b = 0;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	local_irq_restore(flags);
 
 	switch (return_code) {
-		case 0:
-			return address + entry;
-		case 0x80:	/* Not present */
-			printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
-			return 0;
-		default: /* Shouldn't happen */
-			printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
-				service, return_code);
+	case 0: {
+		int cpu;
+		unsigned char flags;
+
+		printk(KERN_INFO "bios32_service: base:%08lx length:%08lx entry:%08lx\n", address, length, entry);
+		if (address >= 0xFFFF0 || length > 0x100000 - address || length <= entry) {
+			printk(KERN_WARNING "bios32_service: not valid\n");
 			return 0;
+		}
+		address = address + PAGE_OFFSET;
+		length += 16UL; /* some BIOSs underreport this... */
+		flags = 4;
+		if (length >= 64*1024*1024) {
+			length >>= PAGE_SHIFT;
+			flags |= 8;
+		}
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_open_kernel(cr0);
+#endif
+
+		for (cpu = 0; cpu < NR_CPUS; cpu++) {
+			gdt = get_cpu_gdt_table(cpu);
+			pack_descriptor(&d, address, length, 0x9b, flags);
+			write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_CS, &d, DESCTYPE_S);
+			pack_descriptor(&d, address, length, 0x93, flags);
+			write_gdt_entry(gdt, GDT_ENTRY_PCIBIOS_DS, &d, DESCTYPE_S);
+		}
+
+#ifdef CONFIG_PAX_KERNEXEC
+		pax_close_kernel(cr0);
+#endif
+
+		return entry;
+	}
+	case 0x80:	/* Not present */
+		printk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);
+		return 0;
+	default: /* Shouldn't happen */
+		printk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",
+			service, return_code);
+		return 0;
 	}
 }
 
 static struct {
 	unsigned long address;
 	unsigned short segment;
-} pci_indirect = { 0, __KERNEL_CS };
+} pci_indirect __read_only = { 0, __PCIBIOS_CS };
 
-static int pci_bios_present;
+static int pci_bios_present __read_only;
 
 static int __devinit check_pcibios(void)
 {
@@ -109,11 +179,13 @@ static int __devinit check_pcibios(void)
 	unsigned long flags, pcibios_entry;
 
 	if ((pcibios_entry = bios32_service(PCI_SERVICE))) {
-		pci_indirect.address = pcibios_entry + PAGE_OFFSET;
+		pci_indirect.address = pcibios_entry;
 
 		local_irq_save(flags);
-		__asm__(
-			"lcall *(%%edi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%edi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -122,7 +194,8 @@ static int __devinit check_pcibios(void)
 			  "=b" (ebx),
 			  "=c" (ecx)
 			: "1" (PCIBIOS_PCI_BIOS_PRESENT),
-			  "D" (&pci_indirect)
+			  "D" (&pci_indirect),
+			  "r" (__PCIBIOS_DS)
 			: "memory");
 		local_irq_restore(flags);
 
@@ -166,7 +239,10 @@ static int pci_bios_read(unsigned int se
 
 	switch (len) {
 	case 1:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -175,7 +251,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_BYTE),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		/*
 		 * Zero-extend the result beyond 8 bits, do not trust the
 		 * BIOS having done it:
@@ -183,7 +260,10 @@ static int pci_bios_read(unsigned int se
 		*value &= 0xff;
 		break;
 	case 2:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -192,7 +272,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_WORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		/*
 		 * Zero-extend the result beyond 16 bits, do not trust the
 		 * BIOS having done it:
@@ -200,7 +281,10 @@ static int pci_bios_read(unsigned int se
 		*value &= 0xffff;
 		break;
 	case 4:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -209,7 +293,8 @@ static int pci_bios_read(unsigned int se
 			: "1" (PCIBIOS_READ_CONFIG_DWORD),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -232,7 +317,10 @@ static int pci_bios_write(unsigned int s
 
 	switch (len) {
 	case 1:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -241,10 +329,14 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 2:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -253,10 +345,14 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	case 4:
-		__asm__("lcall *(%%esi); cld\n\t"
+		__asm__("movw %w6, %%ds\n\t"
+			"lcall *%%ss:(%%esi); cld\n\t"
+			"push %%ss\n\t"
+			"pop %%ds\n\t"
 			"jc 1f\n\t"
 			"xor %%ah, %%ah\n"
 			"1:"
@@ -265,7 +361,8 @@ static int pci_bios_write(unsigned int s
 			  "c" (value),
 			  "b" (bx),
 			  "D" ((long)reg),
-			  "S" (&pci_indirect));
+			  "S" (&pci_indirect),
+			  "r" (__PCIBIOS_DS));
 		break;
 	}
 
@@ -369,10 +466,13 @@ struct irq_routing_table * pcibios_get_i
 
 	DBG("PCI: Fetching IRQ routing table... ");
 	__asm__("push %%es\n\t"
+		"movw %w8, %%ds\n\t"
 		"push %%ds\n\t"
 		"pop  %%es\n\t"
-		"lcall *(%%esi); cld\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
 		"pop %%es\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -383,7 +483,8 @@ struct irq_routing_table * pcibios_get_i
 		  "1" (0),
 		  "D" ((long) &opt),
 		  "S" (&pci_indirect),
-		  "m" (opt)
+		  "m" (opt),
+		  "r" (__PCIBIOS_DS)
 		: "memory");
 	DBG("OK  ret=%d, size=%d, map=%x\n", ret, opt.size, map);
 	if (ret & 0xff00)
@@ -407,7 +508,10 @@ int pcibios_set_irq_routing(struct pci_d
 {
 	int ret;
 
-	__asm__("lcall *(%%esi); cld\n\t"
+	__asm__("movw %w5, %%ds\n\t"
+		"lcall *%%ss:(%%esi); cld\n\t"
+		"push %%ss\n\t"
+		"pop %%ds\n"
 		"jc 1f\n\t"
 		"xor %%ah, %%ah\n"
 		"1:"
@@ -415,7 +519,8 @@ int pcibios_set_irq_routing(struct pci_d
 		: "0" (PCIBIOS_SET_PCI_HW_INT),
 		  "b" ((dev->bus->number << 8) | dev->devfn),
 		  "c" ((irq << 8) | (pin + 10)),
-		  "S" (&pci_indirect));
+		  "S" (&pci_indirect),
+		  "r" (__PCIBIOS_DS));
 	return !(ret & 0xff00);
 }
 EXPORT_SYMBOL(pcibios_set_irq_routing);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/power/cpu_32.c linux-2.6.26.8-pax/arch/x86/power/cpu_32.c
--- linux-2.6.26.8/arch/x86/power/cpu_32.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/power/cpu_32.c	2008-07-14 03:52:23.000000000 +0200
@@ -66,7 +66,7 @@ static void do_fpu_end(void)
 static void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
 
 	set_tss_desc(cpu, t);	/*
 				 * This just modifies memory; should not be
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/power/cpu_64.c linux-2.6.26.8-pax/arch/x86/power/cpu_64.c
--- linux-2.6.26.8/arch/x86/power/cpu_64.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/power/cpu_64.c	2008-07-14 03:52:23.000000000 +0200
@@ -136,7 +136,11 @@ void restore_processor_state(void)
 static void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
-	struct tss_struct *t = &per_cpu(init_tss, cpu);
+	struct tss_struct *t = init_tss + cpu;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
 
 	/*
 	 * This just modifies memory; should not be necessary. But... This
@@ -145,8 +149,16 @@ static void fix_processor_context(void)
 	 */
 	set_tss_desc(cpu, t);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	get_cpu_gdt_table(cpu)[GDT_ENTRY_TSS].type = 9;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	syscall_init();                         /* This sets MSR_*STAR and related */
 	load_TR_desc();				/* This does ltr */
 	load_LDT(&current->active_mm->context);	/* This does lldt */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/vdso/vdso32-setup.c linux-2.6.26.8-pax/arch/x86/vdso/vdso32-setup.c
--- linux-2.6.26.8/arch/x86/vdso/vdso32-setup.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/vdso/vdso32-setup.c	2008-07-14 03:52:23.000000000 +0200
@@ -239,7 +239,7 @@ static inline void map_compat_vdso(int m
 void enable_sep_cpu(void)
 {
 	int cpu = get_cpu();
-	struct tss_struct *tss = &per_cpu(init_tss, cpu);
+	struct tss_struct *tss = init_tss + cpu;
 
 	if (!boot_cpu_has(X86_FEATURE_SEP)) {
 		put_cpu();
@@ -262,7 +262,7 @@ static int __init gate_vma_init(void)
 	gate_vma.vm_start = FIXADDR_USER_START;
 	gate_vma.vm_end = FIXADDR_USER_END;
 	gate_vma.vm_flags = VM_READ | VM_MAYREAD | VM_EXEC | VM_MAYEXEC;
-	gate_vma.vm_page_prot = __P101;
+	gate_vma.vm_page_prot = vm_get_page_prot(gate_vma.vm_flags);
 	/*
 	 * Make sure the vDSO gets into every core dump.
 	 * Dumping its contents makes post-mortem fully interpretable later
@@ -341,7 +341,7 @@ int arch_setup_additional_pages(struct l
 	if (compat)
 		addr = VDSO_HIGH_BASE;
 	else {
-		addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
+		addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, MAP_EXECUTABLE);
 		if (IS_ERR_VALUE(addr)) {
 			ret = addr;
 			goto up_fail;
@@ -368,7 +368,7 @@ int arch_setup_additional_pages(struct l
 			goto up_fail;
 	}
 
-	current->mm->context.vdso = (void *)addr;
+	current->mm->context.vdso = addr;
 	current_thread_info()->sysenter_return =
 		VDSO32_SYMBOL(addr, SYSENTER_RETURN);
 
@@ -394,7 +394,7 @@ static ctl_table abi_table2[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec
 	},
-	{}
+	{ 0, NULL, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
 static ctl_table abi_root_table2[] = {
@@ -404,7 +404,7 @@ static ctl_table abi_root_table2[] = {
 		.mode = 0555,
 		.child = abi_table2
 	},
-	{}
+	{ 0, NULL, NULL, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
 static __init int ia32_binfmt_init(void)
@@ -419,8 +419,14 @@ __initcall(ia32_binfmt_init);
 
 const char *arch_vma_name(struct vm_area_struct *vma)
 {
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
+	if (vma->vm_mm && vma->vm_start == vma->vm_mm->context.vdso)
 		return "[vdso]";
+
+#ifdef CONFIG_PAX_SEGMEXEC
+	if (vma->vm_mm && vma->vm_mirror && vma->vm_mirror->vm_start == vma->vm_mm->context.vdso)
+		return "[vdso]";
+#endif
+
 	return NULL;
 }
 
@@ -429,7 +435,7 @@ struct vm_area_struct *get_gate_vma(stru
 	struct mm_struct *mm = tsk->mm;
 
 	/* Check to see if this task was created in compat vdso mode */
-	if (mm && mm->context.vdso == (void *)VDSO_HIGH_BASE)
+	if (mm && mm->context.vdso == VDSO_HIGH_BASE)
 		return &gate_vma;
 	return NULL;
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/vdso/vma.c linux-2.6.26.8-pax/arch/x86/vdso/vma.c
--- linux-2.6.26.8/arch/x86/vdso/vma.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/vdso/vma.c	2008-07-14 03:52:23.000000000 +0200
@@ -122,7 +122,7 @@ int arch_setup_additional_pages(struct l
 	if (ret)
 		goto up_fail;
 
-	current->mm->context.vdso = (void *)addr;
+	current->mm->context.vdso = addr;
 up_fail:
 	up_write(&mm->mmap_sem);
 	return ret;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/xen/enlighten.c linux-2.6.26.8-pax/arch/x86/xen/enlighten.c
--- linux-2.6.26.8/arch/x86/xen/enlighten.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/xen/enlighten.c	2008-07-14 03:52:23.000000000 +0200
@@ -295,7 +295,7 @@ static void xen_set_ldt(const void *addr
 static void xen_load_gdt(const struct desc_ptr *dtr)
 {
 	unsigned long *frames;
-	unsigned long va = dtr->address;
+	unsigned long va = (unsigned long)dtr->address;
 	unsigned int size = dtr->size + 1;
 	unsigned pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
 	int f;
@@ -310,7 +310,7 @@ static void xen_load_gdt(const struct de
 	mcs = xen_mc_entry(sizeof(*frames) * pages);
 	frames = mcs.args;
 
-	for (f = 0; va < dtr->address + size; va += PAGE_SIZE, f++) {
+	for (f = 0; va < (unsigned long)dtr->address + size; va += PAGE_SIZE, f++) {
 		frames[f] = virt_to_mfn(va);
 		make_lowmem_page_readonly((void *)va);
 	}
@@ -403,7 +403,7 @@ static void xen_write_idt_entry(gate_des
 
 	preempt_disable();
 
-	start = __get_cpu_var(idt_desc).address;
+	start = (unsigned long)__get_cpu_var(idt_desc).address;
 	end = start + __get_cpu_var(idt_desc).size + 1;
 
 	xen_mc_flush();
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/arch/x86/xen/smp.c linux-2.6.26.8-pax/arch/x86/xen/smp.c
--- linux-2.6.26.8/arch/x86/xen/smp.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/arch/x86/xen/smp.c	2008-07-14 03:52:23.000000000 +0200
@@ -154,7 +154,7 @@ void __init xen_smp_prepare_boot_cpu(voi
 
 	/* We've switched to the "real" per-cpu gdt, so make sure the
 	   old memory can be recycled */
-	make_lowmem_page_readwrite(&per_cpu__gdt_page);
+	make_lowmem_page_readwrite(get_cpu_gdt_table(smp_processor_id()));
 
 	for_each_possible_cpu(cpu) {
 		cpus_clear(per_cpu(cpu_sibling_map, cpu));
@@ -218,7 +218,7 @@ static __cpuinit int
 cpu_initialize_context(unsigned int cpu, struct task_struct *idle)
 {
 	struct vcpu_guest_context *ctxt;
-	struct gdt_page *gdt = &per_cpu(gdt_page, cpu);
+	struct desc_struct *gdt = get_cpu_gdt_table(cpu);
 
 	if (cpu_test_and_set(cpu, xen_cpu_initialized_map))
 		return 0;
@@ -228,8 +228,8 @@ cpu_initialize_context(unsigned int cpu,
 		return -ENOMEM;
 
 	ctxt->flags = VGCF_IN_KERNEL;
-	ctxt->user_regs.ds = __USER_DS;
-	ctxt->user_regs.es = __USER_DS;
+	ctxt->user_regs.ds = __KERNEL_DS;
+	ctxt->user_regs.es = __KERNEL_DS;
 	ctxt->user_regs.fs = __KERNEL_PERCPU;
 	ctxt->user_regs.gs = 0;
 	ctxt->user_regs.ss = __KERNEL_DS;
@@ -242,11 +242,11 @@ cpu_initialize_context(unsigned int cpu,
 
 	ctxt->ldt_ents = 0;
 
-	BUG_ON((unsigned long)gdt->gdt & ~PAGE_MASK);
-	make_lowmem_page_readonly(gdt->gdt);
+	BUG_ON((unsigned long)gdt & ~PAGE_MASK);
+	make_lowmem_page_readonly(gdt);
 
-	ctxt->gdt_frames[0] = virt_to_mfn(gdt->gdt);
-	ctxt->gdt_ents      = ARRAY_SIZE(gdt->gdt);
+	ctxt->gdt_frames[0] = virt_to_mfn(gdt);
+	ctxt->gdt_ents      = GDT_ENTRIES;
 
 	ctxt->user_regs.cs = __KERNEL_CS;
 	ctxt->user_regs.esp = idle->thread.sp0 - sizeof(struct pt_regs);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/crypto/async_tx/async_tx.c linux-2.6.26.8-pax/crypto/async_tx/async_tx.c
--- linux-2.6.26.8/crypto/async_tx/async_tx.c	2008-10-09 04:12:34.000000000 +0200
+++ linux-2.6.26.8-pax/crypto/async_tx/async_tx.c	2008-10-09 04:13:06.000000000 +0200
@@ -357,8 +357,8 @@ async_tx_init(void)
 err:
 	printk(KERN_ERR "async_tx: initialization failure\n");
 
-	while (--cap >= 0)
-		free_percpu(channel_table[cap]);
+	while (cap)
+		free_percpu(channel_table[--cap]);
 
 	return 1;
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/crypto/lrw.c linux-2.6.26.8-pax/crypto/lrw.c
--- linux-2.6.26.8/crypto/lrw.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/crypto/lrw.c	2008-07-14 03:52:23.000000000 +0200
@@ -54,7 +54,7 @@ static int setkey(struct crypto_tfm *par
 	struct priv *ctx = crypto_tfm_ctx(parent);
 	struct crypto_cipher *child = ctx->child;
 	int err, i;
-	be128 tmp = { 0 };
+	be128 tmp = { 0, 0 };
 	int bsize = crypto_cipher_blocksize(child);
 
 	crypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/blacklist.c linux-2.6.26.8-pax/drivers/acpi/blacklist.c
--- linux-2.6.26.8/drivers/acpi/blacklist.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/blacklist.c	2008-07-14 03:52:23.000000000 +0200
@@ -71,7 +71,7 @@ static struct acpi_blacklist_item acpi_b
 	{"IBM   ", "TP600E  ", 0x00000105, ACPI_SIG_DSDT, less_than_or_equal,
 	 "Incorrect _ADR", 1},
 
-	{""}
+	{"", "", 0, 0, 0, all_versions, 0}
 };
 
 #if	CONFIG_ACPI_BLACKLIST_YEAR
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/osl.c linux-2.6.26.8-pax/drivers/acpi/osl.c
--- linux-2.6.26.8/drivers/acpi/osl.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/osl.c	2008-07-14 03:52:23.000000000 +0200
@@ -494,6 +494,8 @@ acpi_os_read_memory(acpi_physical_addres
 	void __iomem *virt_addr;
 
 	virt_addr = ioremap(phys_addr, width);
+	if (!virt_addr)
+		return AE_NO_MEMORY;
 	if (!value)
 		value = &dummy;
 
@@ -522,6 +524,8 @@ acpi_os_write_memory(acpi_physical_addre
 	void __iomem *virt_addr;
 
 	virt_addr = ioremap(phys_addr, width);
+	if (!virt_addr)
+		return AE_NO_MEMORY;
 
 	switch (width) {
 	case 8:
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/processor_core.c linux-2.6.26.8-pax/drivers/acpi/processor_core.c
--- linux-2.6.26.8/drivers/acpi/processor_core.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/processor_core.c	2008-07-14 03:52:23.000000000 +0200
@@ -631,7 +631,7 @@ static int __cpuinit acpi_processor_star
 		return 0;
 	}
 
-	BUG_ON((pr->id >= nr_cpu_ids) || (pr->id < 0));
+	BUG_ON(pr->id >= nr_cpu_ids);
 
 	/*
 	 * Buggy BIOS check
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/processor_idle.c linux-2.6.26.8-pax/drivers/acpi/processor_idle.c
--- linux-2.6.26.8/drivers/acpi/processor_idle.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/processor_idle.c	2008-07-14 03:52:23.000000000 +0200
@@ -181,7 +181,7 @@ static struct dmi_system_id __cpuinitdat
 	  DMI_MATCH(DMI_BIOS_VENDOR,"Phoenix Technologies LTD"),
 	  DMI_MATCH(DMI_BIOS_VERSION,"SHE845M0.86C.0013.D.0302131307")},
 	 (void *)2},
-	{},
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL},
 };
 
 static inline u32 ticks_elapsed(u32 t1, u32 t2)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/sleep/main.c linux-2.6.26.8-pax/drivers/acpi/sleep/main.c
--- linux-2.6.26.8/drivers/acpi/sleep/main.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/sleep/main.c	2008-07-14 03:52:23.000000000 +0200
@@ -249,7 +249,7 @@ static struct dmi_system_id __initdata a
 	 .ident = "Toshiba Satellite 4030cdt",
 	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),},
 	 },
-	{},
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL},
 };
 #endif /* CONFIG_SUSPEND */
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/acpi/tables/tbfadt.c linux-2.6.26.8-pax/drivers/acpi/tables/tbfadt.c
--- linux-2.6.26.8/drivers/acpi/tables/tbfadt.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/acpi/tables/tbfadt.c	2008-07-14 03:52:23.000000000 +0200
@@ -48,7 +48,7 @@
 ACPI_MODULE_NAME("tbfadt")
 
 /* Local prototypes */
-static void inline
+static inline void
 acpi_tb_init_generic_address(struct acpi_generic_address *generic_address,
 			     u8 bit_width, u64 address);
 
@@ -122,7 +122,7 @@ static struct acpi_fadt_info fadt_info_t
  *
  ******************************************************************************/
 
-static void inline
+static inline void
 acpi_tb_init_generic_address(struct acpi_generic_address *generic_address,
 			     u8 bit_width, u64 address)
 {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ata/ahci.c linux-2.6.26.8-pax/drivers/ata/ahci.c
--- linux-2.6.26.8/drivers/ata/ahci.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ata/ahci.c	2008-07-14 03:52:23.000000000 +0200
@@ -546,7 +546,7 @@ static const struct pci_device_id ahci_p
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
 
-	{ }	/* terminate list */
+	{ 0, 0, 0, 0, 0, 0, 0 }	/* terminate list */
 };
 
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ata/ata_piix.c linux-2.6.26.8-pax/drivers/ata/ata_piix.c
--- linux-2.6.26.8/drivers/ata/ata_piix.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ata/ata_piix.c	2008-07-14 03:52:23.000000000 +0200
@@ -275,7 +275,7 @@ static const struct pci_device_id piix_p
 	/* SATA Controller IDE (ICH10) */
 	{ 0x8086, 0x3a26, PCI_ANY_ID, PCI_ANY_ID, 0, 0, ich8_2port_sata },
 
-	{ }	/* terminate list */
+	{ 0, 0, 0, 0, 0, 0, 0 }	/* terminate list */
 };
 
 static struct pci_driver piix_pci_driver = {
@@ -578,7 +578,7 @@ static const struct ich_laptop ich_lapto
 	{ 0x266F, 0x1025, 0x0066 },	/* ICH6 on ACER Aspire 1694WLMi */
 	{ 0x2653, 0x1043, 0x82D8 },	/* ICH6M on Asus Eee 701 */
 	/* end marker */
-	{ 0, }
+	{ 0, 0, 0 }
 };
 
 /**
@@ -1134,7 +1134,7 @@ static int piix_broken_suspend(void)
 			},
 		},
 
-		{ }	/* terminate list */
+		{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }	/* terminate list */
 	};
 	static const char *oemstrs[] = {
 		"Tecra M3,",
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ata/libata-core.c linux-2.6.26.8-pax/drivers/ata/libata-core.c
--- linux-2.6.26.8/drivers/ata/libata-core.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ata/libata-core.c	2008-07-14 03:52:23.000000000 +0200
@@ -736,7 +736,7 @@ static const struct ata_xfer_ent {
 	{ ATA_SHIFT_PIO, ATA_NR_PIO_MODES, XFER_PIO_0 },
 	{ ATA_SHIFT_MWDMA, ATA_NR_MWDMA_MODES, XFER_MW_DMA_0 },
 	{ ATA_SHIFT_UDMA, ATA_NR_UDMA_MODES, XFER_UDMA_0 },
-	{ -1, },
+	{ -1, 0, 0 }
 };
 
 /**
@@ -2860,7 +2860,7 @@ static const struct ata_timing ata_timin
 	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0,   0,  20 },
 	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0,   0,  15 },
 
-	{ 0xFF }
+	{ 0xFF, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 #define ENOUGH(v, unit)		(((v)-1)/(unit)+1)
@@ -3947,7 +3947,7 @@ static const struct ata_blacklist_entry 
 	{ "TSSTcorp CDDVDW SH-S202N", "SB01",	  ATA_HORKAGE_IVB, },
 
 	/* End Marker */
-	{ }
+	{ NULL, NULL, 0 }
 };
 
 static int strn_pattern_cmp(const char *patt, const char *name, int wildchar)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/agp/frontend.c linux-2.6.26.8-pax/drivers/char/agp/frontend.c
--- linux-2.6.26.8/drivers/char/agp/frontend.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/agp/frontend.c	2008-07-14 03:52:23.000000000 +0200
@@ -820,7 +820,7 @@ static int agpioc_reserve_wrap(struct ag
 	if (copy_from_user(&reserve, arg, sizeof(struct agp_region)))
 		return -EFAULT;
 
-	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))
+	if ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment_priv))
 		return -EFAULT;
 
 	client = agp_find_client_by_pid(reserve.pid);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/agp/intel-agp.c linux-2.6.26.8-pax/drivers/char/agp/intel-agp.c
--- linux-2.6.26.8/drivers/char/agp/intel-agp.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/agp/intel-agp.c	2008-07-14 03:52:23.000000000 +0200
@@ -2319,7 +2319,7 @@ static struct pci_device_id agp_intel_pc
 	ID(PCI_DEVICE_ID_INTEL_IGD_E_HB),
 	ID(PCI_DEVICE_ID_INTEL_Q45_HB),
 	ID(PCI_DEVICE_ID_INTEL_G45_HB),
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, agp_intel_pci_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/drm/drm_pciids.h linux-2.6.26.8-pax/drivers/char/drm/drm_pciids.h
--- linux-2.6.26.8/drivers/char/drm/drm_pciids.h	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/drm/drm_pciids.h	2008-07-14 03:52:23.000000000 +0200
@@ -346,7 +346,7 @@
 	{0x8086, 0x7123, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x7125, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
 	{0x8086, 0x1132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
-	{0, 0, 0}
+	{0, 0, 0, 0, 0, 0, 0 }
 
 #define i830_PCI_IDS \
 	{0x8086, 0x3577, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0}, \
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/hpet.c linux-2.6.26.8-pax/drivers/char/hpet.c
--- linux-2.6.26.8/drivers/char/hpet.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/hpet.c	2008-07-14 03:52:23.000000000 +0200
@@ -953,7 +953,7 @@ static struct acpi_driver hpet_acpi_driv
 		},
 };
 
-static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops };
+static struct miscdevice hpet_misc = { HPET_MINOR, "hpet", &hpet_fops, {NULL, NULL}, NULL, NULL };
 
 static int __init hpet_init(void)
 {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/keyboard.c linux-2.6.26.8-pax/drivers/char/keyboard.c
--- linux-2.6.26.8/drivers/char/keyboard.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/keyboard.c	2008-07-14 03:52:23.000000000 +0200
@@ -1386,7 +1386,7 @@ static const struct input_device_id kbd_
                 .evbit = { BIT_MASK(EV_SND) },
         },
 
-	{ },    /* Terminating entry */
+	{ 0 },    /* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE(input, kbd_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/nvram.c linux-2.6.26.8-pax/drivers/char/nvram.c
--- linux-2.6.26.8/drivers/char/nvram.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/nvram.c	2008-07-14 03:52:23.000000000 +0200
@@ -430,7 +430,10 @@ static const struct file_operations nvra
 static struct miscdevice nvram_dev = {
 	NVRAM_MINOR,
 	"nvram",
-	&nvram_fops
+	&nvram_fops,
+	{NULL, NULL},
+	NULL,
+	NULL
 };
 
 static int __init
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/char/random.c linux-2.6.26.8-pax/drivers/char/random.c
--- linux-2.6.26.8/drivers/char/random.c	2008-09-08 13:54:29.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/char/random.c	2008-09-08 13:54:36.000000000 +0200
@@ -1165,7 +1165,7 @@ EXPORT_SYMBOL(generate_random_uuid);
 #include <linux/sysctl.h>
 
 static int min_read_thresh = 8, min_write_thresh;
-static int max_read_thresh = INPUT_POOL_WORDS * 32;
+static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
 static int max_write_thresh = INPUT_POOL_WORDS * 32;
 static char sysctl_bootid[16];
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/edac/edac_core.h linux-2.6.26.8-pax/drivers/edac/edac_core.h
--- linux-2.6.26.8/drivers/edac/edac_core.h	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/edac/edac_core.h	2008-07-14 03:52:23.000000000 +0200
@@ -86,11 +86,11 @@ extern int edac_debug_level;
 
 #else				/* !CONFIG_EDAC_DEBUG */
 
-#define debugf0( ... )
-#define debugf1( ... )
-#define debugf2( ... )
-#define debugf3( ... )
-#define debugf4( ... )
+#define debugf0( ... ) do {} while (0)
+#define debugf1( ... ) do {} while (0)
+#define debugf2( ... ) do {} while (0)
+#define debugf3( ... ) do {} while (0)
+#define debugf4( ... ) do {} while (0)
 
 #endif				/* !CONFIG_EDAC_DEBUG */
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/firmware/dmi_scan.c linux-2.6.26.8-pax/drivers/firmware/dmi_scan.c
--- linux-2.6.26.8/drivers/firmware/dmi_scan.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/firmware/dmi_scan.c	2008-07-14 03:52:23.000000000 +0200
@@ -379,11 +379,6 @@ void __init dmi_scan_machine(void)
 		}
 	}
 	else {
-		/*
-		 * no iounmap() for that ioremap(); it would be a no-op, but
-		 * it's so early in setup that sucker gets confused into doing
-		 * what it shouldn't if we actually call it.
-		 */
 		p = dmi_ioremap(0xF0000, 0x10000);
 		if (p == NULL)
 			goto out;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/fscpos.c linux-2.6.26.8-pax/drivers/hwmon/fscpos.c
--- linux-2.6.26.8/drivers/hwmon/fscpos.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/fscpos.c	2008-07-14 03:52:23.000000000 +0200
@@ -230,7 +230,6 @@ static ssize_t set_pwm(struct i2c_client
 	unsigned long v = simple_strtoul(buf, NULL, 10);
 
 	/* Range: 0..255 */
-	if (v < 0) v = 0;
 	if (v > 255) v = 255;
 
 	mutex_lock(&data->update_lock);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/k8temp.c linux-2.6.26.8-pax/drivers/hwmon/k8temp.c
--- linux-2.6.26.8/drivers/hwmon/k8temp.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/k8temp.c	2008-07-14 03:52:23.000000000 +0200
@@ -130,7 +130,7 @@ static DEVICE_ATTR(name, S_IRUGO, show_n
 
 static struct pci_device_id k8temp_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_K8_NB_MISC) },
-	{ 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE(pci, k8temp_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/sis5595.c linux-2.6.26.8-pax/drivers/hwmon/sis5595.c
--- linux-2.6.26.8/drivers/hwmon/sis5595.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/sis5595.c	2008-07-14 03:52:23.000000000 +0200
@@ -698,7 +698,7 @@ static struct sis5595_data *sis5595_upda
 
 static struct pci_device_id sis5595_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, sis5595_pci_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/via686a.c linux-2.6.26.8-pax/drivers/hwmon/via686a.c
--- linux-2.6.26.8/drivers/hwmon/via686a.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/via686a.c	2008-07-14 03:52:23.000000000 +0200
@@ -768,7 +768,7 @@ static struct via686a_data *via686a_upda
 
 static struct pci_device_id via686a_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686_4) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, via686a_pci_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/vt8231.c linux-2.6.26.8-pax/drivers/hwmon/vt8231.c
--- linux-2.6.26.8/drivers/hwmon/vt8231.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/vt8231.c	2008-07-14 03:52:23.000000000 +0200
@@ -698,7 +698,7 @@ static struct platform_driver vt8231_dri
 
 static struct pci_device_id vt8231_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231_4) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, vt8231_pci_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/hwmon/w83791d.c linux-2.6.26.8-pax/drivers/hwmon/w83791d.c
--- linux-2.6.26.8/drivers/hwmon/w83791d.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/hwmon/w83791d.c	2008-07-14 03:52:23.000000000 +0200
@@ -290,8 +290,8 @@ static int w83791d_attach_adapter(struct
 static int w83791d_detect(struct i2c_adapter *adapter, int address, int kind);
 static int w83791d_detach_client(struct i2c_client *client);
 
-static int w83791d_read(struct i2c_client *client, u8 register);
-static int w83791d_write(struct i2c_client *client, u8 register, u8 value);
+static int w83791d_read(struct i2c_client *client, u8 reg);
+static int w83791d_write(struct i2c_client *client, u8 reg, u8 value);
 static struct w83791d_data *w83791d_update_device(struct device *dev);
 
 #ifdef DEBUG
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/i2c/busses/i2c-i801.c linux-2.6.26.8-pax/drivers/i2c/busses/i2c-i801.c
--- linux-2.6.26.8/drivers/i2c/busses/i2c-i801.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/i2c/busses/i2c-i801.c	2008-07-14 03:52:23.000000000 +0200
@@ -592,7 +592,7 @@ static struct pci_device_id i801_ids[] =
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_TOLAPAI_1) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH10_4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ICH10_5) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, i801_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/i2c/busses/i2c-i810.c linux-2.6.26.8-pax/drivers/i2c/busses/i2c-i810.c
--- linux-2.6.26.8/drivers/i2c/busses/i2c-i810.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/i2c/busses/i2c-i810.c	2008-07-14 03:52:23.000000000 +0200
@@ -198,7 +198,7 @@ static struct pci_device_id i810_ids[] _
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82810E_IG) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82845G_IG) },
-	{ 0, },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE (pci, i810_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/i2c/busses/i2c-piix4.c linux-2.6.26.8-pax/drivers/i2c/busses/i2c-piix4.c
--- linux-2.6.26.8/drivers/i2c/busses/i2c-piix4.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/i2c/busses/i2c-piix4.c	2008-07-14 03:52:23.000000000 +0200
@@ -133,7 +133,7 @@ static struct dmi_system_id __devinitdat
 		.ident = "IBM",
 		.matches = { DMI_MATCH(DMI_SYS_VENDOR, "IBM"), },
 	},
-	{ },
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL },
 };
 
 static int __devinit piix4_setup(struct pci_dev *PIIX4_dev,
@@ -431,7 +431,7 @@ static struct pci_device_id piix4_ids[] 
 		     PCI_DEVICE_ID_SERVERWORKS_CSB6) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SERVERWORKS,
 		     PCI_DEVICE_ID_SERVERWORKS_HT1000SB) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, piix4_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/i2c/busses/i2c-sis630.c linux-2.6.26.8-pax/drivers/i2c/busses/i2c-sis630.c
--- linux-2.6.26.8/drivers/i2c/busses/i2c-sis630.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/i2c/busses/i2c-sis630.c	2008-07-14 03:52:23.000000000 +0200
@@ -465,7 +465,7 @@ static struct i2c_adapter sis630_adapter
 static struct pci_device_id sis630_ids[] __devinitdata = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_LPC) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, sis630_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/i2c/busses/i2c-sis96x.c linux-2.6.26.8-pax/drivers/i2c/busses/i2c-sis96x.c
--- linux-2.6.26.8/drivers/i2c/busses/i2c-sis96x.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/i2c/busses/i2c-sis96x.c	2008-07-14 03:52:23.000000000 +0200
@@ -255,7 +255,7 @@ static struct i2c_adapter sis96x_adapter
 
 static struct pci_device_id sis96x_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_SMBUS) },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (pci, sis96x_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/dv1394.c linux-2.6.26.8-pax/drivers/ieee1394/dv1394.c
--- linux-2.6.26.8/drivers/ieee1394/dv1394.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/dv1394.c	2008-07-14 03:52:23.000000000 +0200
@@ -739,7 +739,7 @@ static void frame_prepare(struct video_c
 	based upon DIF section and sequence
 */
 
-static void inline
+static inline void
 frame_put_packet (struct frame *f, struct packet *p)
 {
 	int section_type = p->data[0] >> 5;           /* section type is in bits 5 - 7 */
@@ -918,7 +918,7 @@ static int do_dv1394_init(struct video_c
 		/* default SYT offset is 3 cycles */
 		init->syt_offset = 3;
 
-	if ( (init->channel > 63) || (init->channel < 0) )
+	if (init->channel > 63)
 		init->channel = 63;
 
 	chan_mask = (u64)1 << init->channel;
@@ -2174,7 +2174,7 @@ static struct ieee1394_device_id dv1394_
 		.specifier_id	= AVC_UNIT_SPEC_ID_ENTRY & 0xffffff,
 		.version	= AVC_SW_VERSION_ENTRY & 0xffffff
 	},
-	{ }
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, dv1394_id_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/eth1394.c linux-2.6.26.8-pax/drivers/ieee1394/eth1394.c
--- linux-2.6.26.8/drivers/ieee1394/eth1394.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/eth1394.c	2008-07-14 03:52:23.000000000 +0200
@@ -451,7 +451,7 @@ static struct ieee1394_device_id eth1394
 		.specifier_id =	ETHER1394_GASP_SPECIFIER_ID,
 		.version = ETHER1394_GASP_VERSION,
 	},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, eth1394_id_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/hosts.c linux-2.6.26.8-pax/drivers/ieee1394/hosts.c
--- linux-2.6.26.8/drivers/ieee1394/hosts.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/hosts.c	2008-07-14 03:52:23.000000000 +0200
@@ -78,6 +78,7 @@ static int dummy_isoctl(struct hpsb_iso 
 }
 
 static struct hpsb_host_driver dummy_driver = {
+	.name =		   "dummy",
 	.transmit_packet = dummy_transmit_packet,
 	.devctl =	   dummy_devctl,
 	.isoctl =	   dummy_isoctl
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/ohci1394.c linux-2.6.26.8-pax/drivers/ieee1394/ohci1394.c
--- linux-2.6.26.8/drivers/ieee1394/ohci1394.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/ohci1394.c	2008-07-14 03:52:23.000000000 +0200
@@ -147,9 +147,9 @@ printk(level "%s: " fmt "\n" , OHCI1394_
 printk(level "%s: fw-host%d: " fmt "\n" , OHCI1394_DRIVER_NAME, ohci->host->id , ## args)
 
 /* Module Parameters */
-static int phys_dma = 1;
+static int phys_dma;
 module_param(phys_dma, int, 0444);
-MODULE_PARM_DESC(phys_dma, "Enable physical DMA (default = 1).");
+MODULE_PARM_DESC(phys_dma, "Enable physical DMA (default = 0).");
 
 static void dma_trm_tasklet(unsigned long data);
 static void dma_trm_reset(struct dma_trm_ctx *d);
@@ -3437,7 +3437,7 @@ static struct pci_device_id ohci1394_pci
 		.subvendor =	PCI_ANY_ID,
 		.subdevice =	PCI_ANY_ID,
 	},
-	{ 0, },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 MODULE_DEVICE_TABLE(pci, ohci1394_pci_tbl);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/raw1394.c linux-2.6.26.8-pax/drivers/ieee1394/raw1394.c
--- linux-2.6.26.8/drivers/ieee1394/raw1394.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/raw1394.c	2008-07-14 03:52:23.000000000 +0200
@@ -2958,7 +2958,7 @@ static struct ieee1394_device_id raw1394
 	 .match_flags = IEEE1394_MATCH_SPECIFIER_ID | IEEE1394_MATCH_VERSION,
 	 .specifier_id = CAMERA_UNIT_SPEC_ID_ENTRY & 0xffffff,
 	 .version = (CAMERA_SW_VERSION_ENTRY + 2) & 0xffffff},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, raw1394_id_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/sbp2.c linux-2.6.26.8-pax/drivers/ieee1394/sbp2.c
--- linux-2.6.26.8/drivers/ieee1394/sbp2.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/sbp2.c	2008-07-14 03:52:23.000000000 +0200
@@ -283,7 +283,7 @@ static struct ieee1394_device_id sbp2_id
 	 .match_flags	= IEEE1394_MATCH_SPECIFIER_ID | IEEE1394_MATCH_VERSION,
 	 .specifier_id	= SBP2_UNIT_SPEC_ID_ENTRY & 0xffffff,
 	 .version	= SBP2_SW_VERSION_ENTRY & 0xffffff},
-	{}
+	{ 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(ieee1394, sbp2_id_table);
 
@@ -2101,7 +2101,7 @@ MODULE_DESCRIPTION("IEEE-1394 SBP-2 prot
 MODULE_SUPPORTED_DEVICE(SBP2_DEVICE_NAME);
 MODULE_LICENSE("GPL");
 
-static int sbp2_module_init(void)
+static int __init sbp2_module_init(void)
 {
 	int ret;
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/ieee1394/video1394.c linux-2.6.26.8-pax/drivers/ieee1394/video1394.c
--- linux-2.6.26.8/drivers/ieee1394/video1394.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/ieee1394/video1394.c	2008-07-14 03:52:23.000000000 +0200
@@ -893,7 +893,7 @@ static long video1394_ioctl(struct file 
 		if (unlikely(d == NULL))
 			return -EFAULT;
 
-		if (unlikely((v.buffer<0) || (v.buffer>=d->num_desc - 1))) {
+		if (unlikely(v.buffer>=d->num_desc - 1)) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -959,7 +959,7 @@ static long video1394_ioctl(struct file 
 		if (unlikely(d == NULL))
 			return -EFAULT;
 
-		if (unlikely((v.buffer<0) || (v.buffer>d->num_desc - 1))) {
+		if (unlikely(v.buffer>d->num_desc - 1)) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1030,7 +1030,7 @@ static long video1394_ioctl(struct file 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 		if (d == NULL) return -EFAULT;
 
-		if ((v.buffer<0) || (v.buffer>=d->num_desc - 1)) {
+		if (v.buffer>=d->num_desc - 1) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1137,7 +1137,7 @@ static long video1394_ioctl(struct file 
 		d = find_ctx(&ctx->context_list, OHCI_ISO_TRANSMIT, v.channel);
 		if (d == NULL) return -EFAULT;
 
-		if ((v.buffer<0) || (v.buffer>=d->num_desc-1)) {
+		if (v.buffer>=d->num_desc-1) {
 			PRINT(KERN_ERR, ohci->host->id,
 			      "Buffer %d out of range",v.buffer);
 			return -EINVAL;
@@ -1310,7 +1310,7 @@ static struct ieee1394_device_id video13
                 .specifier_id   = CAMERA_UNIT_SPEC_ID_ENTRY & 0xffffff,
                 .version        = (CAMERA_SW_VERSION_ENTRY + 2) & 0xffffff
         },
-	{ }
+	{ 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(ieee1394, video1394_id_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/keyboard/atkbd.c linux-2.6.26.8-pax/drivers/input/keyboard/atkbd.c
--- linux-2.6.26.8/drivers/input/keyboard/atkbd.c	2008-07-14 03:51:39.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/keyboard/atkbd.c	2008-07-14 03:52:23.000000000 +0200
@@ -1115,7 +1115,7 @@ static struct serio_device_id atkbd_seri
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, atkbd_serio_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/mouse/lifebook.c linux-2.6.26.8-pax/drivers/input/mouse/lifebook.c
--- linux-2.6.26.8/drivers/input/mouse/lifebook.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/mouse/lifebook.c	2008-07-14 03:52:23.000000000 +0200
@@ -110,7 +110,7 @@ static const struct dmi_system_id lifebo
 			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook B142"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL}
 };
 
 static psmouse_ret_t lifebook_process_byte(struct psmouse *psmouse)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/mouse/psmouse-base.c linux-2.6.26.8-pax/drivers/input/mouse/psmouse-base.c
--- linux-2.6.26.8/drivers/input/mouse/psmouse-base.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/mouse/psmouse-base.c	2008-07-14 03:52:23.000000000 +0200
@@ -1328,7 +1328,7 @@ static struct serio_device_id psmouse_se
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, psmouse_serio_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/mouse/synaptics.c linux-2.6.26.8-pax/drivers/input/mouse/synaptics.c
--- linux-2.6.26.8/drivers/input/mouse/synaptics.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/mouse/synaptics.c	2008-07-14 03:52:23.000000000 +0200
@@ -417,7 +417,7 @@ static void synaptics_process_packet(str
 				break;
 			case 2:
 				if (SYN_MODEL_PEN(priv->model_id))
-					;   /* Nothing, treat a pen as a single finger */
+					break;   /* Nothing, treat a pen as a single finger */
 				break;
 			case 4 ... 15:
 				if (SYN_CAP_PALMDETECT(priv->capabilities))
@@ -624,7 +624,7 @@ static const struct dmi_system_id toshib
 			DMI_MATCH(DMI_PRODUCT_NAME, "PORTEGE M300"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/mousedev.c linux-2.6.26.8-pax/drivers/input/mousedev.c
--- linux-2.6.26.8/drivers/input/mousedev.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/mousedev.c	2008-07-14 03:52:23.000000000 +0200
@@ -1056,7 +1056,7 @@ static struct input_handler mousedev_han
 
 #ifdef CONFIG_INPUT_MOUSEDEV_PSAUX
 static struct miscdevice psaux_mouse = {
-	PSMOUSE_MINOR, "psaux", &mousedev_fops
+	PSMOUSE_MINOR, "psaux", &mousedev_fops, {NULL, NULL}, NULL, NULL
 };
 static int psaux_registered;
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/serio/i8042-x86ia64io.h linux-2.6.26.8-pax/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.26.8/drivers/input/serio/i8042-x86ia64io.h	2008-08-07 13:54:05.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/serio/i8042-x86ia64io.h	2008-08-07 13:54:26.000000000 +0200
@@ -118,7 +118,7 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_VERSION, "VS2005R2"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 /*
@@ -298,7 +298,7 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_NAME, "Aspire 1360"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 
 #ifdef CONFIG_PNP
@@ -317,7 +317,7 @@ static struct dmi_system_id __initdata i
 			DMI_MATCH(DMI_PRODUCT_NAME, "N34AS6"),
 		},
 	},
-	{ }
+	{ NULL, NULL, {DMI_MATCH(DMI_NONE, NULL)}, NULL }
 };
 #endif
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/input/serio/serio_raw.c linux-2.6.26.8-pax/drivers/input/serio/serio_raw.c
--- linux-2.6.26.8/drivers/input/serio/serio_raw.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/input/serio/serio_raw.c	2008-07-14 03:52:23.000000000 +0200
@@ -369,7 +369,7 @@ static struct serio_device_id serio_raw_
 		.id	= SERIO_ANY,
 		.extra	= SERIO_ANY,
 	},
-	{ 0 }
+	{ 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(serio, serio_raw_serio_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/md/bitmap.c linux-2.6.26.8-pax/drivers/md/bitmap.c
--- linux-2.6.26.8/drivers/md/bitmap.c	2008-07-14 03:51:40.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/md/bitmap.c	2008-07-14 03:52:23.000000000 +0200
@@ -57,7 +57,7 @@
 #  if DEBUG > 0
 #    define PRINTK(x...) printk(KERN_DEBUG x)
 #  else
-#    define PRINTK(x...)
+#    define PRINTK(x...) do {} while (0)
 #  endif
 #endif
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/mtd/devices/doc2000.c linux-2.6.26.8-pax/drivers/mtd/devices/doc2000.c
--- linux-2.6.26.8/drivers/mtd/devices/doc2000.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/mtd/devices/doc2000.c	2008-07-14 03:52:23.000000000 +0200
@@ -779,7 +779,7 @@ static int doc_write(struct mtd_info *mt
 
 		/* The ECC will not be calculated correctly if less than 512 is written */
 /* DBB-
-		if (len != 0x200 && eccbuf)
+		if (len != 0x200)
 			printk(KERN_WARNING
 			       "ECC needs a full sector write (adr: %lx size %lx)\n",
 			       (long) to, (long) len);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/mtd/devices/slram.c linux-2.6.26.8-pax/drivers/mtd/devices/slram.c
--- linux-2.6.26.8/drivers/mtd/devices/slram.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/mtd/devices/slram.c	2008-07-14 03:52:23.000000000 +0200
@@ -275,7 +275,7 @@ static int parse_cmdline(char *devname, 
 	}
 	T("slram: devname=%s, devstart=0x%lx, devlength=0x%lx\n",
 			devname, devstart, devlength);
-	if ((devstart < 0) || (devlength < 0) || (devlength % SLRAM_BLK_SZ != 0)) {
+	if (devlength % SLRAM_BLK_SZ != 0) {
 		E("slram: Illegal start / length parameter.\n");
 		return(-EINVAL);
 	}
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/mtd/ubi/build.c linux-2.6.26.8-pax/drivers/mtd/ubi/build.c
--- linux-2.6.26.8/drivers/mtd/ubi/build.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/mtd/ubi/build.c	2008-07-14 03:52:23.000000000 +0200
@@ -1057,7 +1057,7 @@ static int __init bytes_str_to_int(const
 	unsigned long result;
 
 	result = simple_strtoul(str, &endp, 0);
-	if (str == endp || result < 0) {
+	if (str == endp) {
 		printk(KERN_ERR "UBI error: incorrect bytes count: \"%s\"\n",
 		       str);
 		return -EINVAL;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/net/eepro100.c linux-2.6.26.8-pax/drivers/net/eepro100.c
--- linux-2.6.26.8/drivers/net/eepro100.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/net/eepro100.c	2008-07-14 03:52:23.000000000 +0200
@@ -47,7 +47,7 @@ static int rxdmacount /* = 0 */;
 # define rx_align(skb)		skb_reserve((skb), 2)
 # define RxFD_ALIGNMENT		__attribute__ ((aligned (2), packed))
 #else
-# define rx_align(skb)
+# define rx_align(skb) do {} while (0)
 # define RxFD_ALIGNMENT
 #endif
 
@@ -2334,33 +2334,33 @@ static void __devexit eepro100_remove_on
 }
 
 static struct pci_device_id eepro100_pci_tbl[] = {
-	{ PCI_VENDOR_ID_INTEL, 0x1229, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1209, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1029, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1030, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1031, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1032, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1033, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1034, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1035, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1036, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1037, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1038, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1039, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103A, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103B, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103C, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103D, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x103E, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1050, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1059, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x1227, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x2449, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x2459, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x245D, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x5200, PCI_ANY_ID, PCI_ANY_ID, },
-	{ PCI_VENDOR_ID_INTEL, 0x5201, PCI_ANY_ID, PCI_ANY_ID, },
-	{ 0,}
+	{ PCI_VENDOR_ID_INTEL, 0x1229, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1209, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1029, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1030, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1031, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1032, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1033, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1034, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1035, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1036, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1037, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1038, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1039, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x103E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1050, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1059, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x1227, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x2449, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x2459, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x245D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x5200, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VENDOR_ID_INTEL, 0x5201, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, eepro100_pci_tbl);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/net/irda/vlsi_ir.c linux-2.6.26.8-pax/drivers/net/irda/vlsi_ir.c
--- linux-2.6.26.8/drivers/net/irda/vlsi_ir.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/net/irda/vlsi_ir.c	2008-07-14 03:52:23.000000000 +0200
@@ -906,13 +906,12 @@ static int vlsi_hard_start_xmit(struct s
 			/* no race - tx-ring already empty */
 			vlsi_set_baud(idev, iobase);
 			netif_wake_queue(ndev);
-		}
-		else
-			;
+		} else {
 			/* keep the speed change pending like it would
 			 * for any len>0 packet. tx completion interrupt
 			 * will apply it when the tx ring becomes empty.
 			 */
+		}
 		spin_unlock_irqrestore(&idev->lock, flags);
 		dev_kfree_skb_any(skb);
 		return 0;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/net/pcnet32.c linux-2.6.26.8-pax/drivers/net/pcnet32.c
--- linux-2.6.26.8/drivers/net/pcnet32.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/net/pcnet32.c	2008-07-14 03:52:23.000000000 +0200
@@ -78,7 +78,7 @@ static int cards_found;
 /*
  * VLB I/O addresses
  */
-static unsigned int pcnet32_portlist[] __initdata =
+static unsigned int pcnet32_portlist[] __devinitdata =
     { 0x300, 0x320, 0x340, 0x360, 0 };
 
 static int pcnet32_debug = 0;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/net/tg3.h linux-2.6.26.8-pax/drivers/net/tg3.h
--- linux-2.6.26.8/drivers/net/tg3.h	2008-09-08 13:54:29.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/net/tg3.h	2008-09-08 13:54:36.000000000 +0200
@@ -102,6 +102,7 @@
 #define  CHIPREV_ID_5750_A0		 0x4000
 #define  CHIPREV_ID_5750_A1		 0x4001
 #define  CHIPREV_ID_5750_A3		 0x4003
+#define  CHIPREV_ID_5750_C1		 0x4201
 #define  CHIPREV_ID_5750_C2		 0x4202
 #define  CHIPREV_ID_5752_A0_HW		 0x5000
 #define  CHIPREV_ID_5752_A0		 0x6000
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pci/hotplug/cpqphp_nvram.c linux-2.6.26.8-pax/drivers/pci/hotplug/cpqphp_nvram.c
--- linux-2.6.26.8/drivers/pci/hotplug/cpqphp_nvram.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pci/hotplug/cpqphp_nvram.c	2008-07-14 03:52:23.000000000 +0200
@@ -425,9 +425,13 @@ static u32 store_HRT (void __iomem *rom_
 
 void compaq_nvram_init (void __iomem *rom_start)
 {
+
+#ifndef CONFIG_PAX_KERNEXEC
 	if (rom_start) {
 		compaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);
 	}
+#endif
+
 	dbg("int15 entry  = %p\n", compaq_int15_entry_point);
 
 	/* initialize our int15 lock */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pci/pcie/aer/aerdrv.c linux-2.6.26.8-pax/drivers/pci/pcie/aer/aerdrv.c
--- linux-2.6.26.8/drivers/pci/pcie/aer/aerdrv.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pci/pcie/aer/aerdrv.c	2008-07-14 03:52:23.000000000 +0200
@@ -58,7 +58,7 @@ static struct pcie_port_service_id aer_i
 	.port_type 	= PCIE_RC_PORT,
 	.service_type 	= PCIE_PORT_SERVICE_AER,
 	},
-	{ /* end: all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static struct pci_error_handlers aer_error_handlers = {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pci/pcie/aer/aerdrv_core.c linux-2.6.26.8-pax/drivers/pci/pcie/aer/aerdrv_core.c
--- linux-2.6.26.8/drivers/pci/pcie/aer/aerdrv_core.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pci/pcie/aer/aerdrv_core.c	2008-07-14 03:52:23.000000000 +0200
@@ -663,7 +663,7 @@ static void aer_isr_one_error(struct pci
 		struct aer_err_source *e_src)
 {
 	struct device *s_device;
-	struct aer_err_info e_info = {0, 0, 0,};
+	struct aer_err_info e_info = {0, 0, 0, {0, 0, 0, 0}};
 	int i;
 	u16 id;
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pci/pcie/portdrv_pci.c linux-2.6.26.8-pax/drivers/pci/pcie/portdrv_pci.c
--- linux-2.6.26.8/drivers/pci/pcie/portdrv_pci.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pci/pcie/portdrv_pci.c	2008-07-14 03:52:23.000000000 +0200
@@ -265,7 +265,7 @@ static void pcie_portdrv_err_resume(stru
 static const struct pci_device_id port_pci_ids[] = { {
 	/* handle any PCI-Express port */
 	PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0),
-	}, { /* end: all zeroes */ }
+	}, { 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, port_pci_ids);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pcmcia/ti113x.h linux-2.6.26.8-pax/drivers/pcmcia/ti113x.h
--- linux-2.6.26.8/drivers/pcmcia/ti113x.h	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pcmcia/ti113x.h	2008-07-14 03:52:23.000000000 +0200
@@ -897,7 +897,7 @@ static struct pci_device_id ene_tune_tbl
 	DEVID(PCI_VENDOR_ID_MOTOROLA, 0x3410, 0xECC0, PCI_ANY_ID,
 		ENE_TEST_C9_TLTENABLE | ENE_TEST_C9_PFENABLE, ENE_TEST_C9_TLTENABLE),
 
-	{}
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static void ene_tune_bridge(struct pcmcia_socket *sock, struct pci_bus *bus)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pcmcia/yenta_socket.c linux-2.6.26.8-pax/drivers/pcmcia/yenta_socket.c
--- linux-2.6.26.8/drivers/pcmcia/yenta_socket.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pcmcia/yenta_socket.c	2008-07-14 03:52:23.000000000 +0200
@@ -1358,7 +1358,7 @@ static struct pci_device_id yenta_table 
 
 	/* match any cardbus bridge */
 	CB_ID(PCI_ANY_ID, PCI_ANY_ID, DEFAULT),
-	{ /* all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, yenta_table);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pnp/pnpbios/bioscalls.c linux-2.6.26.8-pax/drivers/pnp/pnpbios/bioscalls.c
--- linux-2.6.26.8/drivers/pnp/pnpbios/bioscalls.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pnp/pnpbios/bioscalls.c	2008-07-14 03:52:23.000000000 +0200
@@ -60,7 +60,7 @@ set_base(gdt[(selname) >> 3], (u32)(addr
 set_limit(gdt[(selname) >> 3], size); \
 } while(0)
 
-static struct desc_struct bad_bios_desc;
+static struct desc_struct bad_bios_desc __read_only;
 
 /*
  * At some point we want to use this stack frame pointer to unwind
@@ -87,6 +87,10 @@ static inline u16 call_pnp_bios(u16 func
 	struct desc_struct save_desc_40;
 	int cpu;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	/*
 	 * PnP BIOSes are generally not terribly re-entrant.
 	 * Also, don't rely on them to save everything correctly.
@@ -96,8 +100,17 @@ static inline u16 call_pnp_bios(u16 func
 
 	cpu = get_cpu();
 	save_desc_40 = get_cpu_gdt_table(cpu)[0x40 / 8];
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	get_cpu_gdt_table(cpu)[0x40 / 8] = bad_bios_desc;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	/* On some boxes IRQ's during PnP BIOS calls are deadly.  */
 	spin_lock_irqsave(&pnp_bios_lock, flags);
 
@@ -134,7 +147,16 @@ static inline u16 call_pnp_bios(u16 func
 			     :"memory");
 	spin_unlock_irqrestore(&pnp_bios_lock, flags);
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	get_cpu_gdt_table(cpu)[0x40 / 8] = save_desc_40;
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 	put_cpu();
 
 	/* If we get here and this is set then the PnP BIOS faulted on us. */
@@ -468,16 +490,24 @@ int pnp_bios_read_escd(char *data, u32 n
 	return status;
 }
 
-void pnpbios_calls_init(union pnp_bios_install_struct *header)
+void __init pnpbios_calls_init(union pnp_bios_install_struct *header)
 {
 	int i;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	unsigned long cr0;
+#endif
+
 	spin_lock_init(&pnp_bios_lock);
 	pnp_bios_callpoint.offset = header->fields.pm16offset;
 	pnp_bios_callpoint.segment = PNP_CS16;
 
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_open_kernel(cr0);
+#endif
+
 	bad_bios_desc.a = 0;
-	bad_bios_desc.b = 0x00409200;
+	bad_bios_desc.b = 0x00409300;
 
 	set_base(bad_bios_desc, __va((unsigned long)0x40 << 4));
 	_set_limit((char *)&bad_bios_desc, 4095 - (0x40 << 4));
@@ -491,4 +521,9 @@ void pnpbios_calls_init(union pnp_bios_i
 		set_base(gdt[GDT_ENTRY_PNPBIOS_DS],
 			 __va(header->fields.pm16dseg));
 	}
+
+#ifdef CONFIG_PAX_KERNEXEC
+	pax_close_kernel(cr0);
+#endif
+
 }
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pnp/quirks.c linux-2.6.26.8-pax/drivers/pnp/quirks.c
--- linux-2.6.26.8/drivers/pnp/quirks.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pnp/quirks.c	2008-07-14 03:52:23.000000000 +0200
@@ -319,7 +319,7 @@ static struct pnp_fixup pnp_fixups[] = {
 	/* PnP resources that might overlap PCI BARs */
 	{"PNP0c01", quirk_system_pci_resources},
 	{"PNP0c02", quirk_system_pci_resources},
-	{""}
+	{"", NULL}
 };
 
 void pnp_fixup_device(struct pnp_dev *dev)
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/pnp/resource.c linux-2.6.26.8-pax/drivers/pnp/resource.c
--- linux-2.6.26.8/drivers/pnp/resource.c	2008-07-14 03:51:41.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/pnp/resource.c	2008-07-14 03:52:23.000000000 +0200
@@ -378,7 +378,7 @@ int pnp_check_irq(struct pnp_dev *dev, s
 		return 1;
 
 	/* check if the resource is valid */
-	if (*irq < 0 || *irq > 15)
+	if (*irq > 15)
 		return 0;
 
 	/* check if the resource is reserved */
@@ -451,7 +451,7 @@ int pnp_check_dma(struct pnp_dev *dev, s
 		return 1;
 
 	/* check if the resource is valid */
-	if (*dma < 0 || *dma == 4 || *dma > 7)
+	if (*dma == 4 || *dma > 7)
 		return 0;
 
 	/* check if the resource is reserved */
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/scsi/scsi_logging.h linux-2.6.26.8-pax/drivers/scsi/scsi_logging.h
--- linux-2.6.26.8/drivers/scsi/scsi_logging.h	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/scsi/scsi_logging.h	2008-07-14 03:52:23.000000000 +0200
@@ -51,7 +51,7 @@ do {								\
 		} while (0);					\
 } while (0)
 #else
-#define SCSI_CHECK_LOGGING(SHIFT, BITS, LEVEL, CMD)
+#define SCSI_CHECK_LOGGING(SHIFT, BITS, LEVEL, CMD) do {} while (0)
 #endif /* CONFIG_SCSI_LOGGING */
 
 /*
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/serial/8250_pci.c linux-2.6.26.8-pax/drivers/serial/8250_pci.c
--- linux-2.6.26.8/drivers/serial/8250_pci.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/serial/8250_pci.c	2008-07-14 03:52:23.000000000 +0200
@@ -2844,7 +2844,7 @@ static struct pci_device_id serial_pci_t
 		PCI_ANY_ID, PCI_ANY_ID,
 		PCI_CLASS_COMMUNICATION_MULTISERIAL << 8,
 		0xffff00, pbn_default },
-	{ 0, }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 
 static struct pci_driver serial_pci_driver = {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/class/cdc-acm.c linux-2.6.26.8-pax/drivers/usb/class/cdc-acm.c
--- linux-2.6.26.8/drivers/usb/class/cdc-acm.c	2008-09-08 13:54:29.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/class/cdc-acm.c	2008-09-08 13:54:36.000000000 +0200
@@ -1264,7 +1264,7 @@ static struct usb_device_id acm_ids[] = 
 		USB_CDC_ACM_PROTO_AT_CDMA) },
 
 	/* NOTE:  COMM/ACM/0xff is likely MSFT RNDIS ... NOT a modem!! */
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (usb, acm_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/class/usblp.c linux-2.6.26.8-pax/drivers/usb/class/usblp.c
--- linux-2.6.26.8/drivers/usb/class/usblp.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/class/usblp.c	2008-07-14 03:52:23.000000000 +0200
@@ -227,7 +227,7 @@ static const struct quirk_printer_struct
 	{ 0x0409, 0xf1be, USBLP_QUIRK_BIDIR }, /* NEC Picty800 (HP OEM) */
 	{ 0x0482, 0x0010, USBLP_QUIRK_BIDIR }, /* Kyocera Mita FS 820, by zut <kernel@zut.de> */
 	{ 0x04b8, 0x0202, USBLP_QUIRK_BAD_CLASS }, /* Seiko Epson Receipt Printer M129C */
-	{ 0, 0 }
+	{ 0, 0, 0 }
 };
 
 static int usblp_wwait(struct usblp *usblp, int nonblock);
@@ -1401,7 +1401,7 @@ static struct usb_device_id usblp_ids []
 	{ USB_INTERFACE_INFO(7, 1, 2) },
 	{ USB_INTERFACE_INFO(7, 1, 3) },
 	{ USB_DEVICE(0x04b8, 0x0202) },	/* Seiko Epson Receipt Printer M129C */
-	{ }						/* Terminating entry */
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }		/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE (usb, usblp_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/core/hub.c linux-2.6.26.8-pax/drivers/usb/core/hub.c
--- linux-2.6.26.8/drivers/usb/core/hub.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/core/hub.c	2008-07-14 03:52:23.000000000 +0200
@@ -3045,7 +3045,7 @@ static struct usb_device_id hub_id_table
       .bDeviceClass = USB_CLASS_HUB},
     { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,
       .bInterfaceClass = USB_CLASS_HUB},
-    { }						/* Terminating entry */
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }						/* Terminating entry */
 };
 
 MODULE_DEVICE_TABLE (usb, hub_id_table);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/host/ehci-pci.c linux-2.6.26.8-pax/drivers/usb/host/ehci-pci.c
--- linux-2.6.26.8/drivers/usb/host/ehci-pci.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/host/ehci-pci.c	2008-07-14 03:52:23.000000000 +0200
@@ -390,7 +390,7 @@ static const struct pci_device_id pci_id
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),
 	.driver_data =	(unsigned long) &ehci_pci_hc_driver,
 	},
-	{ /* end: all zeroes */ }
+	{ 0, 0, 0, 0, 0, 0, 0 }
 };
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/host/uhci-hcd.c linux-2.6.26.8-pax/drivers/usb/host/uhci-hcd.c
--- linux-2.6.26.8/drivers/usb/host/uhci-hcd.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/host/uhci-hcd.c	2008-07-14 03:52:23.000000000 +0200
@@ -928,7 +928,7 @@ static const struct pci_device_id uhci_p
 	/* handle any USB UHCI controller */
 	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
 	.driver_data =	(unsigned long) &uhci_driver,
-	}, { /* end: all zeroes */ }
+	}, { 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE(pci, uhci_pci_ids);
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/storage/debug.h linux-2.6.26.8-pax/drivers/usb/storage/debug.h
--- linux-2.6.26.8/drivers/usb/storage/debug.h	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/storage/debug.h	2008-07-14 03:52:23.000000000 +0200
@@ -56,9 +56,9 @@ void usb_stor_show_sense( unsigned char 
 #define US_DEBUGPX(x...) printk( x )
 #define US_DEBUG(x) x 
 #else
-#define US_DEBUGP(x...)
-#define US_DEBUGPX(x...)
-#define US_DEBUG(x)
+#define US_DEBUGP(x...) do {} while (0)
+#define US_DEBUGPX(x...) do {} while (0)
+#define US_DEBUG(x) do {} while (0)
 #endif
 
 #endif
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/usb/storage/usb.c linux-2.6.26.8-pax/drivers/usb/storage/usb.c
--- linux-2.6.26.8/drivers/usb/storage/usb.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/usb/storage/usb.c	2008-07-14 03:52:23.000000000 +0200
@@ -137,7 +137,7 @@ static struct usb_device_id storage_usb_
 #undef UNUSUAL_DEV
 #undef USUAL_DEV
 	/* Terminating entry */
-	{ }
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
 };
 
 MODULE_DEVICE_TABLE (usb, storage_usb_ids);
@@ -177,7 +177,7 @@ static struct us_unusual_dev us_unusual_
 #	undef USUAL_DEV
 
 	/* Terminating entry */
-	{ NULL }
+	{ NULL, NULL, 0, 0, NULL }
 };
 
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/fbcmap.c linux-2.6.26.8-pax/drivers/video/fbcmap.c
--- linux-2.6.26.8/drivers/video/fbcmap.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/fbcmap.c	2008-07-14 03:52:23.000000000 +0200
@@ -250,8 +250,7 @@ int fb_set_user_cmap(struct fb_cmap_user
 	int rc, size = cmap->len * sizeof(u16);
 	struct fb_cmap umap;
 
-	if (cmap->start < 0 || (!info->fbops->fb_setcolreg &&
-			        !info->fbops->fb_setcmap))
+	if (!info->fbops->fb_setcolreg && !info->fbops->fb_setcmap)
 		return -EINVAL;
 
 	memset(&umap, 0, sizeof(struct fb_cmap));
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/fbmem.c linux-2.6.26.8-pax/drivers/video/fbmem.c
--- linux-2.6.26.8/drivers/video/fbmem.c	2008-09-08 13:54:29.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/fbmem.c	2008-09-08 13:54:36.000000000 +0200
@@ -395,7 +395,7 @@ static void fb_do_show_logo(struct fb_in
 			image->dx += image->width + 8;
 		}
 	} else if (rotate == FB_ROTATE_UD) {
-		for (x = 0; x < num && image->dx >= 0; x++) {
+		for (x = 0; x < num && (__s32)image->dx >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dx -= image->width + 8;
 		}
@@ -407,7 +407,7 @@ static void fb_do_show_logo(struct fb_in
 			image->dy += image->height + 8;
 		}
 	} else if (rotate == FB_ROTATE_CCW) {
-		for (x = 0; x < num && image->dy >= 0; x++) {
+		for (x = 0; x < num && (__s32)image->dy >= 0; x++) {
 			info->fbops->fb_imageblit(info, image);
 			image->dy -= image->height + 8;
 		}
@@ -1084,7 +1084,7 @@ fb_ioctl(struct inode *inode, struct fil
 			return - EFAULT;
 		if (con2fb.console < 1 || con2fb.console > MAX_NR_CONSOLES)
 		    return -EINVAL;
-		if (con2fb.framebuffer < 0 || con2fb.framebuffer >= FB_MAX)
+		if (con2fb.framebuffer >= FB_MAX)
 		    return -EINVAL;
 #ifdef CONFIG_KMOD
 		if (!registered_fb[con2fb.framebuffer])
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/fbmon.c linux-2.6.26.8-pax/drivers/video/fbmon.c
--- linux-2.6.26.8/drivers/video/fbmon.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/fbmon.c	2008-07-14 03:52:23.000000000 +0200
@@ -45,7 +45,7 @@
 #ifdef DEBUG
 #define DPRINTK(fmt, args...) printk(fmt,## args)
 #else
-#define DPRINTK(fmt, args...)
+#define DPRINTK(fmt, args...) do {} while (0)
 #endif
 
 #define FBMON_FIX_HEADER  1
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/i810/i810_accel.c linux-2.6.26.8-pax/drivers/video/i810/i810_accel.c
--- linux-2.6.26.8/drivers/video/i810/i810_accel.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/i810/i810_accel.c	2008-07-14 03:52:23.000000000 +0200
@@ -73,6 +73,7 @@ static inline int wait_for_space(struct 
 		}
 	}
 	printk("ringbuffer lockup!!!\n");
+	printk("head:%u tail:%u iring.size:%u space:%u\n", head, tail, par->iring.size, space);
 	i810_report_error(mmio); 
 	par->dev_flags |= LOCKUP;
 	info->pixmap.scan_align = 1;
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/i810/i810_main.c linux-2.6.26.8-pax/drivers/video/i810/i810_main.c
--- linux-2.6.26.8/drivers/video/i810/i810_main.c	2008-04-17 04:49:44.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/i810/i810_main.c	2008-07-14 03:52:23.000000000 +0200
@@ -120,7 +120,7 @@ static struct pci_device_id i810fb_pci_t
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4 },
 	{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82815_CGC,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5 },
-	{ 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 static struct pci_driver i810fb_driver = {
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/modedb.c linux-2.6.26.8-pax/drivers/video/modedb.c
--- linux-2.6.26.8/drivers/video/modedb.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/modedb.c	2008-07-14 03:52:23.000000000 +0200
@@ -38,232 +38,232 @@ static const struct fb_videomode modedb[
     {
 	/* 640x400 @ 70 Hz, 31.5 kHz hsync */
 	NULL, 70, 640, 400, 39721, 40, 24, 39, 9, 96, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
 	NULL, 60, 640, 480, 39721, 40, 24, 32, 11, 96, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 56 Hz, 35.15 kHz hsync */
 	NULL, 56, 800, 600, 27777, 128, 24, 22, 1, 72, 2,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 87 Hz interlaced, 35.5 kHz hsync */
 	NULL, 87, 1024, 768, 22271, 56, 24, 33, 8, 160, 8,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x400 @ 85 Hz, 37.86 kHz hsync */
 	NULL, 85, 640, 400, 31746, 96, 32, 41, 1, 64, 3,
-	FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 72 Hz, 36.5 kHz hsync */
 	NULL, 72, 640, 480, 31746, 144, 40, 30, 8, 40, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 75 Hz, 37.50 kHz hsync */
 	NULL, 75, 640, 480, 31746, 120, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 800, 600, 25000, 88, 40, 23, 1, 128, 4,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 85 Hz, 43.27 kHz hsync */
 	NULL, 85, 640, 480, 27777, 80, 56, 25, 1, 56, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 89 Hz interlaced, 44 kHz hsync */
 	NULL, 89, 1152, 864, 15384, 96, 16, 110, 1, 216, 10,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 800, 600, 20000, 64, 56, 23, 37, 120, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 60 Hz, 48.4 kHz hsync */
 	NULL, 60, 1024, 768, 15384, 168, 8, 29, 3, 144, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 640x480 @ 100 Hz, 53.01 kHz hsync */
 	NULL, 100, 640, 480, 21834, 96, 32, 36, 8, 96, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 60 Hz, 53.5 kHz hsync */
 	NULL, 60, 1152, 864, 11123, 208, 64, 16, 4, 256, 8,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 85 Hz, 55.84 kHz hsync */
 	NULL, 85, 800, 600, 16460, 160, 64, 36, 16, 64, 5,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 70 Hz, 56.5 kHz hsync */
 	NULL, 70, 1024, 768, 13333, 144, 24, 29, 3, 136, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 87 Hz interlaced, 51 kHz hsync */
 	NULL, 87, 1280, 1024, 12500, 56, 16, 128, 1, 216, 12,
-	0, FB_VMODE_INTERLACED
+	0, FB_VMODE_INTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 800x600 @ 100 Hz, 64.02 kHz hsync */
 	NULL, 100, 800, 600, 14357, 160, 64, 30, 4, 64, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 76 Hz, 62.5 kHz hsync */
 	NULL, 76, 1024, 768, 11764, 208, 8, 36, 16, 120, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 70 Hz, 62.4 kHz hsync */
 	NULL, 70, 1152, 864, 10869, 106, 56, 20, 1, 160, 10,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 61 Hz, 64.2 kHz hsync */
 	NULL, 61, 1280, 1024, 9090, 200, 48, 26, 1, 184, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 60Hz, 63.9 kHz hsync */
 	NULL, 60, 1400, 1050, 9259, 136, 40, 13, 1, 112, 3,
-	0, FB_VMODE_NONINTERLACED   	
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 75,107 Hz, 82,392 kHz +hsync +vsync*/
 	NULL, 75, 1400, 1050, 7190, 120, 56, 23, 10, 112, 13,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1400x1050 @ 60 Hz, ? kHz +hsync +vsync*/
         NULL, 60, 1400, 1050, 9259, 128, 40, 12, 0, 112, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 85 Hz, 70.24 kHz hsync */
 	NULL, 85, 1024, 768, 10111, 192, 32, 34, 14, 160, 6,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 78 Hz, 70.8 kHz hsync */
 	NULL, 78, 1152, 864, 9090, 228, 88, 32, 0, 84, 12,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 70 Hz, 74.59 kHz hsync */
 	NULL, 70, 1280, 1024, 7905, 224, 32, 28, 8, 160, 8,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 60Hz, 75.00 kHz hsync */
 	NULL, 60, 1600, 1200, 6172, 304, 64, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 84 Hz, 76.0 kHz hsync */
 	NULL, 84, 1152, 864, 7407, 184, 312, 32, 0, 128, 12,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 74 Hz, 78.85 kHz hsync */
 	NULL, 74, 1280, 1024, 7407, 256, 32, 34, 3, 144, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1024x768 @ 100Hz, 80.21 kHz hsync */
 	NULL, 100, 1024, 768, 8658, 192, 32, 21, 3, 192, 10,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 76 Hz, 81.13 kHz hsync */
 	NULL, 76, 1280, 1024, 7407, 248, 32, 34, 3, 104, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 70 Hz, 87.50 kHz hsync */
 	NULL, 70, 1600, 1200, 5291, 304, 64, 46, 1, 192, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x864 @ 100 Hz, 89.62 kHz hsync */
 	NULL, 100, 1152, 864, 7264, 224, 32, 17, 2, 128, 19,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 85 Hz, 91.15 kHz hsync */
 	NULL, 85, 1280, 1024, 6349, 224, 64, 44, 1, 160, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 75 Hz, 93.75 kHz hsync */
 	NULL, 75, 1600, 1200, 4938, 304, 64, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1680x1050 @ 60 Hz, 65.191 kHz hsync */
 	NULL, 60, 1680, 1050, 6848, 280, 104, 30, 3, 176, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1600x1200 @ 85 Hz, 105.77 kHz hsync */
 	NULL, 85, 1600, 1200, 4545, 272, 16, 37, 4, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1280x1024 @ 100 Hz, 107.16 kHz hsync */
 	NULL, 100, 1280, 1024, 5502, 256, 32, 26, 7, 128, 15,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1800x1440 @ 64Hz, 96.15 kHz hsync  */
 	NULL, 64, 1800, 1440, 4347, 304, 96, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1800x1440 @ 70Hz, 104.52 kHz hsync  */
 	NULL, 70, 1800, 1440, 4000, 304, 96, 46, 1, 192, 3,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 512x384 @ 78 Hz, 31.50 kHz hsync */
 	NULL, 78, 512, 384, 49603, 48, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 512x384 @ 85 Hz, 34.38 kHz hsync */
 	NULL, 85, 512, 384, 45454, 48, 16, 16, 1, 64, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x200 @ 70 Hz, 31.5 kHz hsync, 8:5 aspect ratio */
 	NULL, 70, 320, 200, 79440, 16, 16, 20, 4, 48, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x240 @ 60 Hz, 31.5 kHz hsync, 4:3 aspect ratio */
 	NULL, 60, 320, 240, 79440, 16, 16, 16, 5, 48, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 320x240 @ 72 Hz, 36.5 kHz hsync */
 	NULL, 72, 320, 240, 63492, 16, 16, 16, 4, 48, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 56 Hz, 35.2 kHz hsync, 4:3 aspect ratio */
 	NULL, 56, 400, 300, 55555, 64, 16, 10, 1, 32, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 400, 300, 50000, 48, 16, 11, 1, 64, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 400x300 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 400, 300, 40000, 32, 24, 11, 19, 64, 3,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 56 Hz, 35.2 kHz hsync, 8:5 aspect ratio */
 	NULL, 56, 480, 300, 46176, 80, 16, 10, 1, 40, 1,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 60 Hz, 37.8 kHz hsync */
 	NULL, 60, 480, 300, 41858, 56, 16, 11, 1, 80, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 63 Hz, 39.6 kHz hsync */
 	NULL, 63, 480, 300, 40000, 56, 16, 11, 1, 80, 2,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 480x300 @ 72 Hz, 48.0 kHz hsync */
 	NULL, 72, 480, 300, 33386, 40, 24, 11, 19, 80, 3,
-	0, FB_VMODE_DOUBLE
+	0, FB_VMODE_DOUBLE, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1920x1200 @ 60 Hz, 74.5 Khz hsync */
 	NULL, 60, 1920, 1200, 5177, 128, 336, 1, 38, 208, 3,
 	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	FB_VMODE_NONINTERLACED
+	FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1152x768, 60 Hz, PowerBook G4 Titanium I and II */
 	NULL, 60, 1152, 768, 14047, 158, 26, 29, 3, 136, 6,
-	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     }, {
 	/* 1366x768, 60 Hz, 47.403 kHz hsync, WXGA 16:9 aspect ratio */
 	NULL, 60, 1366, 768, 13806, 120, 10, 14, 3, 32, 5,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
    }, {
 	/* 1280x800, 60 Hz, 47.403 kHz hsync, WXGA 16:10 aspect ratio */
 	NULL, 60, 1280, 800, 12048, 200, 64, 24, 1, 136, 3,
-	0, FB_VMODE_NONINTERLACED
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_UNKNOWN
     },
 };
 
diff -NurpX linux-2.6.26.8-pax/Documentation/dontdiff linux-2.6.26.8/drivers/video/uvesafb.c linux-2.6.26.8-pax/drivers/video/uvesafb.c
--- linux-2.6.26.8/drivers/video/uvesafb.c	2008-07-14 03:51:42.000000000 +0200
+++ linux-2.6.26.8-pax/drivers/video/uvesafb.c	2008-07-29 16:22:18.000000000 +0200
@@ -18,6 +18,7 @@
 #include <linux/fb.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#include <linux/moduleloader.h>
 #include <video/edid.h>
 #include <video/uvesafb.h>
 #ifdef CONFIG_X86
@@ -117,7 +118,7 @@ static int uvesafb_helper_start(void)
 		NULL,
 	};
 
-	return call_usermodehelper(v86d_path, argv, envp, 1);
+	return call_usermodehelper(v86d_path, argv, envp, UMH_WAIT_PROC);
 }
 
 /*
@@ -569,10 +570,34 @@ static int __devinit uvesafb_vbe_getpmi(
 	if ((task->t.regs.eax & 0xffff) != 0x4f || task->t.regs.es < 0xc000) {
 		par->pmi_setpal = par->ypan = 0;
 	} else {
+
+#ifdef CONFIG_PAX_KERNEXEC
+#ifdef CONFIG_MODULES
+		unsigned long cr0;
+
+		par->pmi_code = module_alloc_exec((u16)task->t.regs.ecx);
+#endif
+		if (!par->pmi_code) {
+			par->pmi_setpal = par->ypan = 0;
+			return 0;
+		}
+#endif
+
 		par->pmi_base = (u16 *)phys_to_virt(((u32)task->t.regs.es << 4)
 						+ task->t.regs.edi);
+
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+		pax_open_kernel(cr0);
+		memcpy(par->pmi_code, par->pmi_base, (u16)task->t.regs.ecx);
+		pax_close_kernel(cr0);
+
+		par->pmi_start = ktva_ktla(par->pmi_code + par->pmi_base[1]);
+		par->pmi_pal = ktva_ktla(par->pmi_code + par->pmi_base[2]);
+#else
 		par->pmi_start = (u8 *)par->pmi_base + par->pmi_base[1];
 		par->pmi_pal = (u8 *)par->pmi_base + par->pmi_base[2];
+#endif
+
 		printk(KERN_INFO "uvesafb: protected mode interface info at "
 				 "%04x:%04x\n",
 				 (u16)task->t.regs.es, (u16)task->t.regs.edi);
@@ -1827,6 +1852,11 @@ out:
 	if (par->vbe_modes)
 		kfree(par->vbe_modes);
 
+#if defined(CONFIG_MODULES) && defined(CONFIG_PAX_KERNEXEC)
+	if (par->pmi_code)
+		module_free_exec(NULL, par->pmi_code);
+#endif
+
 	framebuffer_re